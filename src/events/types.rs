/// Event Types and Data Structures
///
/// Defines the core types used by the events system for categorizing
/// and structuring event data.
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;

// =============================================================================
// EVENT CATEGORIES
// =============================================================================

/// Event categories for organizing different types of bot activities
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum EventCategory {
    /// Swap execution events (Jupiter, DEX interactions)
    Swap,

    /// Blockchain transaction events (send, receive, confirm)
    Transaction,

    /// Pool discovery, analysis, and price calculation events
    Pool,

    /// Learning system events (pattern detection, model updates)
    Learner,

    /// Token-related events (blacklist, metadata, decimals)
    Token,

    /// System lifecycle events (startup, shutdown, errors)
    System,

    /// Position management events (open, close, P&L updates)
    Position,

    /// Wallet events (balance changes, ATA management)
    Wallet,

    /// Entry signal and trading decision events
    Entry,

    /// RPC and external API interaction events
    Rpc,

    /// Security and risk assessment events
    Security,

    /// Other events (with custom category name)
    Other(String),
}

impl EventCategory {
    /// Convert to string for database storage
    pub fn to_string(&self) -> String {
        match self {
            EventCategory::Swap => "swap".to_string(),
            EventCategory::Transaction => "transaction".to_string(),
            EventCategory::Pool => "pool".to_string(),
            EventCategory::Learner => "learner".to_string(),
            EventCategory::Token => "token".to_string(),
            EventCategory::System => "system".to_string(),
            EventCategory::Position => "position".to_string(),
            EventCategory::Wallet => "wallet".to_string(),
            EventCategory::Entry => "entry".to_string(),
            EventCategory::Rpc => "rpc".to_string(),
            EventCategory::Security => "security".to_string(),
            EventCategory::Other(name) => name.clone(),
        }
    }

    /// Parse from string (for database loading)
    pub fn from_string(s: &str) -> Self {
        match s {
            "swap" => EventCategory::Swap,
            "transaction" => EventCategory::Transaction,
            "pool" => EventCategory::Pool,
            "learner" => EventCategory::Learner,
            "token" => EventCategory::Token,
            "system" => EventCategory::System,
            "position" => EventCategory::Position,
            "wallet" => EventCategory::Wallet,
            "entry" => EventCategory::Entry,
            "rpc" => EventCategory::Rpc,
            "security" => EventCategory::Security,
            other => EventCategory::Other(other.to_string()),
        }
    }
}

// =============================================================================
// SEVERITY LEVELS
// =============================================================================

/// Event severity levels
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Severity {
    /// Informational events (normal operations)
    Info,

    /// Warning events (potential issues, recoverable errors)
    Warn,

    /// Error events (failures, exceptions)
    Error,

    /// Debug events (detailed tracing, development)
    Debug,
}

impl Severity {
    /// Convert to string for database storage
    pub fn to_string(&self) -> String {
        match self {
            Severity::Info => "info".to_string(),
            Severity::Warn => "warn".to_string(),
            Severity::Error => "error".to_string(),
            Severity::Debug => "debug".to_string(),
        }
    }

    /// Parse from string (for database loading)
    pub fn from_string(s: &str) -> Self {
        match s {
            "info" => Severity::Info,
            "warn" => Severity::Warn,
            "error" => Severity::Error,
            "debug" => Severity::Debug,
            _ => Severity::Info, // Default fallback
        }
    }
}

// =============================================================================
// EVENT STRUCTURE
// =============================================================================

/// Core event structure containing all event metadata and payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    /// Unique event ID (auto-generated by database)
    pub id: Option<i64>,

    /// Event timestamp (UTC)
    pub event_time: DateTime<Utc>,

    /// Event category
    pub category: EventCategory,

    /// Optional subtype for more specific categorization
    /// Examples: "JupiterQuote", "RaydiumCPMM", "PatternDetected"
    pub subtype: Option<String>,

    /// Event severity level
    pub severity: Severity,

    /// Associated token mint (if applicable)
    pub mint: Option<String>,

    /// Reference ID for correlation (tx signature, pool address, position ID, etc.)
    pub reference_id: Option<String>,

    /// Structured event data as JSON
    pub payload: Value,

    /// Database creation timestamp (auto-generated)
    pub created_at: Option<DateTime<Utc>>,
}

impl Event {
    /// Create a new event with current timestamp
    pub fn new(
        category: EventCategory,
        subtype: Option<String>,
        severity: Severity,
        mint: Option<String>,
        reference_id: Option<String>,
        payload: Value,
    ) -> Self {
        Self {
            id: None,
            event_time: Utc::now(),
            category,
            subtype,
            severity,
            mint,
            reference_id,
            payload,
            created_at: None,
        }
    }

    /// Create an info-level event
    pub fn info(
        category: EventCategory,
        subtype: Option<String>,
        mint: Option<String>,
        reference_id: Option<String>,
        payload: Value,
    ) -> Self {
        Self::new(
            category,
            subtype,
            Severity::Info,
            mint,
            reference_id,
            payload,
        )
    }

    /// Create a warning-level event
    pub fn warn(
        category: EventCategory,
        subtype: Option<String>,
        mint: Option<String>,
        reference_id: Option<String>,
        payload: Value,
    ) -> Self {
        Self::new(
            category,
            subtype,
            Severity::Warn,
            mint,
            reference_id,
            payload,
        )
    }

    /// Create an error-level event
    pub fn error(
        category: EventCategory,
        subtype: Option<String>,
        mint: Option<String>,
        reference_id: Option<String>,
        payload: Value,
    ) -> Self {
        Self::new(
            category,
            subtype,
            Severity::Error,
            mint,
            reference_id,
            payload,
        )
    }

    /// Create a debug-level event
    pub fn debug(
        category: EventCategory,
        subtype: Option<String>,
        mint: Option<String>,
        reference_id: Option<String>,
        payload: Value,
    ) -> Self {
        Self::new(
            category,
            subtype,
            Severity::Debug,
            mint,
            reference_id,
            payload,
        )
    }
}

// =============================================================================
// COMMON EVENT PAYLOADS
// =============================================================================

/// Common payload structures for different event types
/// These provide standardized schemas for frequently-used events

/// Swap event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapEventPayload {
    pub input_mint: String,
    pub output_mint: String,
    pub amount_in: u64,
    pub amount_out: u64,
    pub slippage_bps: u16,
    pub route: Option<String>,
    pub fees_lamports: Option<u64>,
    pub success: bool,
    pub error_message: Option<String>,
}

/// Transaction event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransactionEventPayload {
    pub signature: String,
    pub block_time: Option<i64>,
    pub slot: Option<u64>,
    pub confirmation_status: String,
    pub fee: Option<u64>,
    pub success: bool,
    pub error_message: Option<String>,
    pub instruction_count: usize,
}

/// Pool event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoolEventPayload {
    pub pool_address: String,
    pub program_id: String,
    pub pool_type: String,
    pub token_a_mint: String,
    pub token_b_mint: String,
    pub reserves_a: Option<u64>,
    pub reserves_b: Option<u64>,
    pub price_sol: Option<f64>,
    pub liquidity_usd: Option<f64>,
}

/// Token event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenEventPayload {
    pub symbol: Option<String>,
    pub name: Option<String>,
    pub decimals: Option<u8>,
    pub supply: Option<u64>,
    pub action: String, // "discovered", "blacklisted", "whitelisted", etc.
    pub reason: Option<String>,
}

/// Position event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PositionEventPayload {
    pub position_id: String,
    pub action: String, // "opened", "closed", "updated"
    pub amount_sol: f64,
    pub amount_tokens: u64,
    pub entry_price: Option<f64>,
    pub current_price: Option<f64>,
    pub pnl_sol: Option<f64>,
    pub pnl_percent: Option<f64>,
}

/// Entry signal event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntryEventPayload {
    pub signal_type: String, // "momentum", "volume_spike", "price_drop", etc.
    pub timeframe: String,   // "5m", "15m", "1h", etc.
    pub strength: f64,       // Signal strength 0.0-1.0
    pub price_sol: f64,
    pub volume_24h: Option<f64>,
    pub market_cap: Option<f64>,
    pub decision: String, // "buy", "skip", "wait"
    pub reason: Option<String>,
}

/// System event payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemEventPayload {
    pub component: String, // "trader", "pool_service", "wallet", etc.
    pub action: String,    // "started", "stopped", "error", "config_changed"
    pub details: Option<Value>,
    pub memory_mb: Option<f64>,
    pub cpu_percent: Option<f64>,
}
