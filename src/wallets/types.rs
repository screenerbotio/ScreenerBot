//! Wallet types and data structures
//!
//! Core types for multi-wallet management system.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use solana_sdk::signature::Keypair;
use solana_sdk::signer::Signer;

// =============================================================================
// ENUMS
// =============================================================================

/// Role of a wallet in the system
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum WalletRole {
    /// Primary trading wallet - shown everywhere, used for auto-trading
    Main,
    /// Additional wallets for tools, volume aggregator, manual operations
    Secondary,
    /// Inactive/backup wallets - not used for operations
    Archive,
}

impl std::fmt::Display for WalletRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WalletRole::Main => write!(f, "main"),
            WalletRole::Secondary => write!(f, "secondary"),
            WalletRole::Archive => write!(f, "archive"),
        }
    }
}

impl std::str::FromStr for WalletRole {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "main" => Ok(WalletRole::Main),
            "secondary" => Ok(WalletRole::Secondary),
            "archive" => Ok(WalletRole::Archive),
            _ => Err(format!("Invalid wallet role: {}", s)),
        }
    }
}

/// Type of wallet based on how it was created
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum WalletType {
    /// Generated by the app using secure random generation
    Generated,
    /// Imported from an existing private key
    Imported,
    /// Migrated from legacy config.toml storage
    Migrated,
}

impl std::fmt::Display for WalletType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WalletType::Generated => write!(f, "generated"),
            WalletType::Imported => write!(f, "imported"),
            WalletType::Migrated => write!(f, "migrated"),
        }
    }
}

impl std::str::FromStr for WalletType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "generated" => Ok(WalletType::Generated),
            "imported" => Ok(WalletType::Imported),
            "migrated" => Ok(WalletType::Migrated),
            _ => Err(format!("Invalid wallet type: {}", s)),
        }
    }
}

// =============================================================================
// DATA STRUCTURES
// =============================================================================

/// Wallet information (without private key)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallet {
    /// Unique database ID
    pub id: i64,
    /// User-friendly name
    pub name: String,
    /// Solana public key (base58)
    pub address: String,
    /// Role in the system
    pub role: WalletRole,
    /// How the wallet was created
    pub wallet_type: WalletType,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last time wallet was used for a transaction
    pub last_used_at: Option<DateTime<Utc>>,
    /// User notes/description
    pub notes: Option<String>,
    /// Whether wallet is active (not archived/deleted)
    pub is_active: bool,
}

impl Wallet {
    /// Check if this is the main wallet
    pub fn is_main(&self) -> bool {
        self.role == WalletRole::Main
    }

    /// Check if wallet can be used for operations
    pub fn is_usable(&self) -> bool {
        self.is_active && self.role != WalletRole::Archive
    }
}

/// Wallet with decrypted keypair (for operations requiring signing)
pub struct WalletWithKey {
    /// Wallet metadata
    pub wallet: Wallet,
    /// Decrypted Solana keypair
    pub keypair: Keypair,
}

impl WalletWithKey {
    /// Get the public key address
    pub fn address(&self) -> String {
        self.keypair.pubkey().to_string()
    }
}

/// Summary of all wallets for dashboard
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletsSummary {
    /// Total number of wallets
    pub total_count: u32,
    /// Number of active wallets
    pub active_count: u32,
    /// Main wallet address (if any)
    pub main_wallet: Option<String>,
    /// Main wallet name (if any)
    pub main_wallet_name: Option<String>,
    /// Total SOL across all active wallets (placeholder, populated by balance fetching)
    pub total_sol: f64,
}

/// Request to create a new wallet
#[derive(Debug, Clone, Deserialize)]
pub struct CreateWalletRequest {
    /// Name for the new wallet
    pub name: String,
    /// Optional notes
    pub notes: Option<String>,
    /// Set as main wallet immediately
    #[serde(default)]
    pub set_as_main: bool,
}

/// Request to import an existing wallet
#[derive(Debug, Clone, Deserialize)]
pub struct ImportWalletRequest {
    /// Name for the wallet
    pub name: String,
    /// Private key (base58 or array format)
    pub private_key: String,
    /// Optional notes
    pub notes: Option<String>,
    /// Set as main wallet immediately
    #[serde(default)]
    pub set_as_main: bool,
}

/// Request to update wallet metadata
#[derive(Debug, Clone, Deserialize)]
pub struct UpdateWalletRequest {
    /// New name (optional)
    pub name: Option<String>,
    /// New notes (optional)
    pub notes: Option<String>,
    /// New role (optional)
    pub role: Option<WalletRole>,
}

/// Response after exporting a wallet
#[derive(Debug, Clone, Serialize)]
pub struct ExportWalletResponse {
    /// Wallet address
    pub address: String,
    /// Private key in base58 format
    pub private_key: String,
    /// Warning message
    pub warning: String,
}

// =============================================================================
// TOKEN BALANCE TYPES
// =============================================================================

/// Cached token balance for a wallet
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenBalance {
    /// Wallet database ID
    pub wallet_id: i64,
    /// Token mint address
    pub mint: String,
    /// Raw balance (in smallest units)
    pub balance: u64,
    /// UI-friendly balance (with decimals applied)
    pub ui_amount: f64,
    /// Token decimals
    pub decimals: u8,
    /// Token symbol (if known)
    pub symbol: Option<String>,
    /// Token name (if known)
    pub name: Option<String>,
    /// Whether this is a Token-2022 token
    pub is_token_2022: bool,
    /// When this balance was last updated
    pub updated_at: DateTime<Utc>,
}

// =============================================================================
// WALLET WITH TOKEN BALANCE TYPES
// =============================================================================

/// Wallet with specific token balance information
#[derive(Clone, Debug, Serialize)]
pub struct WalletWithTokenBalance {
    /// The wallet
    pub wallet: Wallet,
    /// SOL balance in SOL (not lamports)
    pub sol_balance: f64,
    /// Token balance (UI amount with decimals applied)
    pub token_balance: f64,
    /// Token decimals
    pub token_decimals: u8,
    /// Whether this wallet needs SOL top-up for transaction fees
    pub needs_sol_topup: bool,
    /// Amount of SOL needed for top-up (if any)
    pub topup_amount: f64,
}

/// Simple token balance for summary
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SimpleTokenBalance {
    /// Token mint address
    pub mint: String,
    /// Token symbol (if known)
    pub symbol: Option<String>,
    /// UI-friendly balance (with decimals applied)
    pub balance: f64,
    /// Token decimals
    pub decimals: u8,
}

/// Wallet balance summary for consolidation UI
#[derive(Clone, Debug, Serialize)]
pub struct WalletBalanceSummary {
    /// Wallet database ID
    pub wallet_id: i64,
    /// Wallet name
    pub wallet_name: String,
    /// Wallet address (base58)
    pub address: String,
    /// SOL balance in SOL (not lamports)
    pub sol_balance: f64,
    /// Number of tokens held (excluding empty ATAs)
    pub token_count: u32,
    /// Token balances
    pub tokens: Vec<SimpleTokenBalance>,
    /// Number of empty ATAs (token accounts with 0 balance)
    pub empty_ata_count: u32,
    /// Reclaimable SOL from closing empty ATAs (~0.00089088 per ATA)
    pub reclaimable_sol: f64,
}
