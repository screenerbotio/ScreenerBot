// Core data structures and type definitions for the transactions module
//
// This module contains all the essential types use/// Transaction type classification with detailed context
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TransactionType {
    SwapSolToToken {
        token_mint: String,
        sol_amount: f64,
        token_amount: f64,
        router: String,
    },
    SwapTokenToSol {
        token_mint: String,
        token_amount: f64,
        sol_amount: f64,
        router: String,
    },
    SwapTokenToToken {
        from_mint: String,
        to_mint: String,
        from_amount: f64,
        to_amount: f64,
        router: String,
    },
    SolTransfer {
        amount: f64,
        from: String,
        to: String,
    },
    TokenTransfer {
        mint: String,
        amount: f64,
        from: String,
        to: String,
    },
    AtaClose {
        recovered_sol: f64,
        token_mint: String,
    },
    Other {
        description: String,
        details: String,
    },
    #[default]
    Unknown,
}

impl Default for TransactionType {
    fn default() -> Self {
        TransactionType::Unknown
    }
}the transactions system.
// It provides clean separation of data structures from implementation logic.

use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use solana_sdk::{pubkey::Pubkey, signature::Signature};
use tabled::Tabled;
use std::collections::HashMap;

// =============================================================================
// CORE CONSTANTS
// =============================================================================

/// Analysis cache versioning (bump when snapshot schema changes)
pub const ANALYSIS_CACHE_VERSION: u32 = 2;

/// Standard ATA creation/closure cost in SOL
pub const ATA_RENT_COST_SOL: f64 = 0.00203928;

// Swap and fee constants
pub const DEFAULT_COMPUTE_UNIT_PRICE: u64 = 1000; // Default compute unit price (micro-lamports)
pub const WSOL_MINT: &str = "So11111111111111111111111111111111111111112"; // Wrapped SOL mint address

// RPC and processing constants
pub const RPC_BATCH_SIZE: usize = 1000; // Transaction signatures fetch batch size
pub const PROCESS_BATCH_SIZE: usize = 50; // Transaction processing batch size
pub const TRANSACTION_DATA_BATCH_SIZE: usize = 1; // Transaction data fetch batch size

/// Tolerance for ATA rent variations (lamports)
pub const ATA_RENT_TOLERANCE_LAMPORTS: i64 = 10000;

/// Default compute unit price (micro-lamports)
pub const DEFAULT_COMPUTE_UNIT_PRICE: u64 = 1000;

/// Wrapped SOL mint address
pub const WSOL_MINT: &str = "So11111111111111111111111111111111111111112";

/// Transaction signatures fetch batch size
pub const RPC_BATCH_SIZE: usize = 1000;

/// Transaction processing batch size
pub const PROCESS_BATCH_SIZE: usize = 50;

/// Transaction data fetch batch size
pub const TRANSACTION_DATA_BATCH_SIZE: usize = 1;

// =============================================================================
// CORE TRANSACTION STRUCTURES
// =============================================================================

/// Main Transaction structure used throughout the bot
/// Contains all Solana data + our calculations and analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    // Core identification
    pub signature: String,
    pub slot: Option<u64>,
    pub block_time: Option<i64>,
    pub timestamp: DateTime<Utc>,

    // Transaction status (consolidated from commitment_state, confirmation_status, finalized)
    pub status: TransactionStatus,

    // Transaction type and analysis - NEVER CACHED - always calculated fresh
    #[serde(skip_serializing, default)]
    pub transaction_type: TransactionType,
    #[serde(skip_serializing, default)]
    pub direction: TransactionDirection,

    // Success/failure status from blockchain
    pub success: bool,
    pub error_message: Option<String>,

    // Blockchain data (cached for performance)
    pub fee_lamports: Option<u64>,
    pub compute_units_consumed: Option<u64>,
    pub instructions_count: usize,
    pub accounts_count: usize,

    // Balance changes (calculated fresh each time)
    #[serde(skip_serializing, default)]
    pub sol_balance_change: Option<SolBalanceChange>,
    #[serde(skip_serializing, default)]
    pub token_balance_changes: Vec<TokenBalanceChange>,

    // Swap analysis (calculated fresh each time)
    #[serde(skip_serializing, default)]
    pub token_swap_info: Option<TokenSwapInfo>,
    #[serde(skip_serializing, default)]
    pub swap_pnl_info: Option<SwapPnLInfo>,

    // ATA operations (calculated fresh each time)
    #[serde(skip_serializing, default)]
    pub ata_operations: Vec<AtaOperation>,

    // Token transfers (calculated fresh each time)
    #[serde(skip_serializing, default)]
    pub token_transfers: Vec<TokenTransfer>,

    // Instruction analysis (calculated fresh each time)
    #[serde(skip_serializing, default)]
    pub instruction_info: Vec<InstructionInfo>,

    // Analysis performance metrics
    #[serde(skip_serializing, default)]
    pub analysis_duration_ms: Option<u64>,
    #[serde(skip_serializing, default)]
    pub cached_analysis: Option<CachedAnalysis>,
}

/// Transaction status enumeration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum TransactionStatus {
    Pending,
    Confirmed,
    Finalized,
    Failed(String),
}

impl Default for TransactionStatus {
    fn default() -> Self {
        TransactionStatus::Pending
    }
}

/// Transaction type classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
pub enum TransactionType {
    #[default]
    Unknown,
    Buy,
    Sell,
    Transfer,
    AtaOperation,
    Failed,
    Compute,
    Other(String),
}

/// Transaction direction from wallet perspective
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
pub enum TransactionDirection {
    #[default]
    Unknown,
    Incoming,
    Outgoing,
    Internal,
}

// =============================================================================
// SWAP AND BALANCE ANALYSIS STRUCTURES
// =============================================================================

/// SOL balance change information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SolBalanceChange {
    pub before_lamports: u64,
    pub after_lamports: u64,
    pub change_lamports: i64,
    pub change_sol: f64,
    pub fee_lamports: u64,
    pub net_change_lamports: i64,
    pub net_change_sol: f64,
}

/// Token balance change information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenBalanceChange {
    pub mint: String,
    pub token_account: String,
    pub before_amount: u64,
    pub after_amount: u64,
    pub change_amount: i64,
    pub change_ui_amount: f64,
    pub decimals: u8,
}

/// Token swap information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenSwapInfo {
    pub router: String, // "Jupiter", "Raydium", "Orca", etc.
    pub swap_type: String, // "token_to_sol", "sol_to_token", "token_to_token"
    pub input_mint: String,
    pub output_mint: String,
    pub input_amount: u64,
    pub output_amount: u64,
    pub input_ui_amount: f64,
    pub output_ui_amount: f64,
    pub pool_address: Option<String>,
    pub program_id: String,
}

/// Swap P&L calculation information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapPnLInfo {
    pub sol_spent: f64,
    pub sol_received: f64,
    pub tokens_bought: f64,
    pub tokens_sold: f64,
    pub net_sol_change: f64,
    pub estimated_token_value_sol: Option<f64>,
    pub estimated_pnl_sol: Option<f64>,
    pub fees_paid_sol: f64,
}

/// Token transfer information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenTransfer {
    pub mint: String,
    pub from_account: String,
    pub to_account: String,
    pub amount: u64,
    pub ui_amount: f64,
    pub decimals: u8,
    pub transfer_type: String, // "incoming", "outgoing", "internal"
}

// =============================================================================
// ATA OPERATION STRUCTURES
// =============================================================================

/// ATA (Associated Token Account) operation information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AtaOperation {
    pub operation_type: AtaOperationType,
    pub mint: String,
    pub ata_address: String,
    pub rent_cost_lamports: Option<i64>,
    pub rent_cost_sol: Option<f64>,
}

/// ATA operation type enumeration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum AtaOperationType {
    Create,
    Close,
    Initialize,
}

/// ATA analysis summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AtaAnalysis {
    pub operations: Vec<AtaOperation>,
    pub total_rent_cost_lamports: i64,
    pub total_rent_cost_sol: f64,
    pub net_ata_change: i32, // positive = more ATAs, negative = fewer ATAs
}

// =============================================================================
// INSTRUCTION AND ANALYSIS STRUCTURES  
// =============================================================================

/// Instruction analysis information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstructionInfo {
    pub program_id: String,
    pub instruction_type: String,
    pub accounts_involved: Vec<String>,
    pub data_size: usize,
}

/// Cached analysis information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedAnalysis {
    pub version: u32,
    pub created_at: DateTime<Utc>,
    pub analysis_type: String,
    pub cache_hit: bool,
}

/// Deferred retry record for signatures that timed out/dropped
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeferredRetry {
    pub signature: String,
    pub next_retry_at: DateTime<Utc>,
    pub remaining_attempts: i32,
    pub current_delay_secs: i64,
    pub last_error: Option<String>,
}

// =============================================================================
// STATISTICS AND METRICS
// =============================================================================

/// Transaction statistics for monitoring and reporting
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TransactionStats {
    pub total_transactions: u64,
    pub new_transactions_count: u64,
    pub known_signatures_count: u64,
    pub pending_transactions_count: u64,
    pub failed_transactions_count: u64,
    pub successful_transactions_count: u64,
}

/// Pending transaction processing statistics
#[derive(Default, Debug, Clone)]
pub struct PendingProcessStats {
    pub rechecked: usize,
    pub confirmed: usize,
    pub failed: usize,
    pub not_found: usize,
    pub ttl_evicted: usize,
    pub remaining: usize,
}

// =============================================================================
// DISPLAY IMPLEMENTATIONS
// =============================================================================

impl std::fmt::Display for TransactionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransactionStatus::Pending => write!(f, "Pending"),
            TransactionStatus::Confirmed => write!(f, "Confirmed"),
            TransactionStatus::Finalized => write!(f, "Finalized"),
            TransactionStatus::Failed(msg) => write!(f, "Failed: {}", msg),
        }
    }
}

impl std::fmt::Display for TransactionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransactionType::Unknown => write!(f, "Unknown"),
            TransactionType::Buy => write!(f, "Buy"),
            TransactionType::Sell => write!(f, "Sell"),
            TransactionType::Transfer => write!(f, "Transfer"),
            TransactionType::AtaOperation => write!(f, "ATA Operation"),
            TransactionType::Failed => write!(f, "Failed"),
            TransactionType::Compute => write!(f, "Compute"),
            TransactionType::Other(desc) => write!(f, "Other: {}", desc),
        }
    }
}

impl std::fmt::Display for TransactionDirection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransactionDirection::Unknown => write!(f, "Unknown"),
            TransactionDirection::Incoming => write!(f, "Incoming"),
            TransactionDirection::Outgoing => write!(f, "Outgoing"),
            TransactionDirection::Internal => write!(f, "Internal"),
        }
    }
}

// =============================================================================
// HELPER METHODS
// =============================================================================

impl Transaction {
    /// Create a new empty transaction with the given signature
    pub fn new(signature: String) -> Self {
        Self {
            signature,
            slot: None,
            block_time: None,
            timestamp: Utc::now(),
            status: TransactionStatus::Pending,
            transaction_type: TransactionType::Unknown,
            direction: TransactionDirection::Unknown,
            success: false,
            error_message: None,
            fee_lamports: None,
            compute_units_consumed: None,
            instructions_count: 0,
            accounts_count: 0,
            sol_balance_change: None,
            token_balance_changes: Vec::new(),
            token_swap_info: None,
            swap_pnl_info: None,
            ata_operations: Vec::new(),
            token_transfers: Vec::new(),
            instruction_info: Vec::new(),
            analysis_duration_ms: None,
            cached_analysis: None,
        }
    }

    /// Check if transaction is finalized
    pub fn is_finalized(&self) -> bool {
        matches!(self.status, TransactionStatus::Finalized)
    }

    /// Check if transaction is successful
    pub fn is_successful(&self) -> bool {
        self.success && !matches!(self.status, TransactionStatus::Failed(_))
    }

    /// Get short signature for logging
    pub fn short_signature(&self) -> String {
        if self.signature.len() >= 8 {
            self.signature[..8].to_string()
        } else {
            self.signature.clone()
        }
    }

    /// Get age in seconds
    pub fn age_seconds(&self) -> i64 {
        (Utc::now() - self.timestamp).num_seconds()
    }
}

impl TransactionStats {
    /// Create new empty statistics
    pub fn new() -> Self {
        Self::default()
    }

    /// Get success rate as percentage
    pub fn success_rate(&self) -> f64 {
        if self.total_transactions == 0 {
            0.0
        } else {
            (self.successful_transactions_count as f64 / self.total_transactions as f64) * 100.0
        }
    }

    /// Get failure rate as percentage  
    pub fn failure_rate(&self) -> f64 {
        if self.total_transactions == 0 {
            0.0
        } else {
            (self.failed_transactions_count as f64 / self.total_transactions as f64) * 100.0
        }
    }
}