use anyhow::Result;
use std::collections::HashMap;
use std::str::FromStr;
use std::path::Path;
use std::convert::TryInto;
use reqwest;
use solana_client::rpc_client::RpcClient;
use solana_sdk::pubkey::Pubkey;

use crate::logger::{ log, LogTag };
use crate::decimal_cache::{ DecimalCache, fetch_or_cache_decimals };
use crate::global::is_debug_pool_prices_enabled;

// SOL and WSOL mint constants
const SOL_MINT: &str = "So11111111111111111111111111111111111111112"; // Native SOL
const WSOL_MINT: &str = "So11111111111111111111111111111111111111112"; // Wrapped SOL (same as native)

/// Helper function for conditional debug logging - only shows when --debug-pool-prices is used
fn debug_log(log_type: &str, message: &str) {
    if is_debug_pool_prices_enabled() {
        log(LogTag::Pool, log_type, message);
    }
}

/// Helper function for regular pool logging - always visible for important operations
fn pool_log(log_type: &str, message: &str) {
    log(LogTag::Pool, log_type, message);
}

pub mod types;
pub mod decoder;
pub mod cache;

// Re-export main types for backwards compatibility
pub use types::*;
pub use decoder::*;
pub use cache::*;

// =============================================================================
// MAIN POOL DISCOVERY AND PRICE CALCULATOR
// =============================================================================

pub struct PoolDiscoveryAndPricing {
    rpc_client: RpcClient,
    http_client: reqwest::Client,
}

impl PoolDiscoveryAndPricing {
    pub fn new(rpc_url: &str) -> Self {
        Self {
            rpc_client: RpcClient::new(rpc_url.to_string()),
            http_client: reqwest::Client::new(),
        }
    }

    /// Check if a mint address is SOL or WSOL
    fn is_sol_mint(&self, mint_address: &str) -> bool {
        mint_address == SOL_MINT || mint_address == WSOL_MINT
    }

    /// Discover all pools for a given token mint address
    pub async fn discover_pools(&self, token_mint: &str) -> Result<Vec<DiscoveredPool>> {
        let url = format!("{}/{}", DEXSCREENER_API_BASE, token_mint);

        pool_log("INFO", &format!("Discovering pools for token: {}", token_mint));

        let response = self.http_client.get(&url).send().await?;

        if !response.status().is_success() {
            pool_log(
                "ERROR",
                &format!("DexScreener API failed: {} for token {}", response.status(), token_mint)
            );
            return Err(
                anyhow::anyhow!("DexScreener API request failed with status: {}", response.status())
            );
        }

        let pairs: Vec<serde_json::Value> = response.json().await?;
        let mut discovered_pools = Vec::new();

        debug_log("DEBUG", &format!("Received {} pairs from API", pairs.len()));

        if pairs.is_empty() {
            pool_log("WARN", &format!("No pools found for token: {}", token_mint));
            return Ok(discovered_pools);
        }

        let pairs_count = pairs.len();

        for pair in pairs {
            if let Ok(pool) = self.parse_pool_from_api_response(&pair) {
                log(
                    LogTag::Pool,
                    "DEBUG",
                    &format!(
                        "Parsed pool: {} ({}) with ${:.2} liquidity",
                        pool.pair_address,
                        pool.dex_id,
                        pool.liquidity_usd
                    )
                );
                discovered_pools.push(pool);
            } else {
                log(
                    LogTag::Pool,
                    "WARN",
                    &format!(
                        "Failed to parse pool: {}",
                        pair
                            .get("pairAddress")
                            .and_then(|v| v.as_str())
                            .unwrap_or("unknown")
                    )
                );
            }
        }

        // Log results - detailed in debug mode, summary otherwise
        if is_debug_pool_price_enabled() {
            pool_log(
                "SUCCESS",
                &format!(
                    "Found {} valid pools out of {} for token {}",
                    discovered_pools.len(),
                    pairs_count,
                    token_mint
                )
            );
        } else if discovered_pools.len() > 0 {
            log_pool_summary("Discovery", discovered_pools.len(), pairs_count);
        }

        if discovered_pools.is_empty() {
            pool_log(
                "WARN",
                &format!(
                    "No valid pools found despite {} API pairs for token: {}",
                    pairs_count,
                    token_mint
                )
            );
        }

        Ok(discovered_pools)
    }

    /// Parse a single pool from DexScreener API response
    fn parse_pool_from_api_response(&self, pair: &serde_json::Value) -> Result<DiscoveredPool> {
        let pair_address = pair["pairAddress"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing pairAddress"))?
            .to_string();

        let dex_id = pair["dexId"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing dexId"))?
            .to_string();

        let base_token = PoolToken {
            address: pair["baseToken"]["address"].as_str().unwrap_or("").to_string(),
            name: pair["baseToken"]["name"].as_str().unwrap_or("").to_string(),
            symbol: pair["baseToken"]["symbol"].as_str().unwrap_or("").to_string(),
        };

        let quote_token = PoolToken {
            address: pair["quoteToken"]["address"].as_str().unwrap_or("").to_string(),
            name: pair["quoteToken"]["name"].as_str().unwrap_or("").to_string(),
            symbol: pair["quoteToken"]["symbol"].as_str().unwrap_or("").to_string(),
        };

        let price_native = pair["priceNative"].as_str().unwrap_or("0").to_string();
        let price_usd = pair["priceUsd"].as_str().unwrap_or("0").to_string();

        let liquidity_usd = pair["liquidity"]["usd"].as_f64().unwrap_or(0.0);
        let volume_24h = pair["volume"]["h24"].as_f64().unwrap_or(0.0);

        let labels = pair["labels"]
            .as_array()
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str().map(|s| s.to_string()))
                    .collect::<Vec<String>>()
            })
            .unwrap_or_else(Vec::new);

        Ok(DiscoveredPool {
            pair_address,
            dex_id,
            base_token,
            quote_token,
            price_native,
            price_usd,
            liquidity_usd,
            volume_24h,
            labels,
        })
    }

    /// Get fresh pool price data using cached pool address
    async fn get_fresh_pool_price_from_address(
        &self,
        cached_address: &PoolAddressCacheEntry
    ) -> Result<Vec<PoolPriceResult>> {
        debug_log(
            "FRESH",
            &format!("Fetching fresh price for cached pool: {}", cached_address.pool_address)
        );

        // Create a DiscoveredPool from cached address data
        let discovered_pool = DiscoveredPool {
            pair_address: cached_address.pool_address.clone(),
            dex_id: cached_address.dex_id.clone(),
            base_token: PoolToken {
                address: cached_address.token_a_mint.clone(),
                name: "TOKEN".to_string(),
                symbol: "TOKEN".to_string(),
            },
            quote_token: PoolToken {
                address: cached_address.token_b_mint.clone(),
                name: "SOL".to_string(),
                symbol: "SOL".to_string(),
            },
            price_native: "0".to_string(), // We'll calculate fresh
            price_usd: "0".to_string(), // We'll calculate fresh
            liquidity_usd: 0.0, // We'll calculate fresh
            volume_24h: 0.0, // We'll calculate fresh
            labels: vec![],
        };

        // Calculate fresh price
        let result = self.calculate_pool_price_with_discovery(&discovered_pool).await;

        if result.calculation_successful {
            debug_log(
                "SUCCESS",
                &format!("Fresh price calculated: ${:.8} SOL", result.calculated_price)
            );
        } else {
            debug_log(
                "ERROR",
                &format!(
                    "Fresh price calculation failed: {}",
                    result.error_message.as_ref().unwrap_or(&"Unknown error".to_string())
                )
            );
        }

        Ok(vec![result])
    }

    /// Get pool prices for all discovered pools of a token
    pub async fn get_token_pool_prices(&self, token_mint: &str) -> Result<Vec<PoolPriceResult>> {
        // Check if token should be skipped due to previous failures
        if should_skip_token(token_mint) {
            debug_log("SKIP", &format!("Skipping token {} due to previous failures", token_mint));
            return Ok(vec![]);
        }

        // Check address cache first for biggest pool (5-minute cache for addresses only)
        if let Some(cached_address) = get_cached_pool_address(token_mint) {
            debug_log(
                "CACHE",
                &format!(
                    "Using cached pool address for token: {} -> {}",
                    token_mint,
                    cached_address.pool_address
                )
            );

            // We have the cached pool address, now fetch fresh price/balance data
            return self.get_fresh_pool_price_from_address(&cached_address).await;
        }

        pool_log("FETCH", &format!("Discovering pools for token: {}", token_mint));

        let discovered_pools = match self.discover_pools(token_mint).await {
            Ok(pools) => pools,
            Err(e) => {
                let error_msg = format!("Pool discovery failed: {}", e);
                pool_log("ERROR", &error_msg);

                // Record failure for future skipping
                if let Err(cache_err) = record_failed_token(token_mint, &error_msg) {
                    debug_log("ERROR", &format!("Failed to record failed token: {}", cache_err));
                }
                return Err(e);
            }
        };

        if discovered_pools.is_empty() {
            let error_msg = "No pools found";
            debug_log("WARN", &format!("No pools found for token: {}", token_mint));

            // Record failure for future skipping
            if let Err(cache_err) = record_failed_token(token_mint, error_msg) {
                debug_log("ERROR", &format!("Failed to record failed token: {}", cache_err));
            }
            return Ok(vec![]);
        }

        let mut results = Vec::new();
        let mut biggest_pool_info: Option<(Pool, f64, f64)> = None; // (pool, price_sol, liquidity_usd)

        debug_log(
            "PROCESS",
            &format!("Processing {} pools for token: {}", discovered_pools.len(), token_mint)
        );

        for pool in discovered_pools {
            let result = self.calculate_pool_price_with_discovery(&pool).await;

            if !result.calculation_successful {
                debug_log(
                    "ERROR",
                    &format!(
                        "Price calculation failed for pool {} ({}): {}",
                        result.pool_address,
                        result.dex_id,
                        result.error_message.as_ref().unwrap_or(&"Unknown error".to_string())
                    )
                );
            } else {
                debug_log(
                    "SUCCESS",
                    &format!(
                        "Calculated price for pool {} ({}): ${:.8} SOL",
                        result.pool_address,
                        result.dex_id,
                        result.calculated_price
                    )
                );

                // Track biggest pool for caching
                if result.is_sol_pair && result.liquidity_usd > 0.0 {
                    if
                        biggest_pool_info.is_none() ||
                        result.liquidity_usd > biggest_pool_info.as_ref().unwrap().2
                    {
                        let pool = Pool {
                            address: result.pool_address.clone(),
                            dex: result.dex_id.clone(),
                            base_token: token_mint.to_string(),
                            quote_token: "SOL".to_string(),
                            liquidity_usd: Some(result.liquidity_usd),
                            volume_24h: Some(result.volume_24h),
                            fee: None,
                            url: None,
                            price_sol: Some(result.calculated_price),
                            price_usd: None,
                        };
                        biggest_pool_info = Some((
                            pool,
                            result.calculated_price,
                            result.liquidity_usd,
                        ));
                    }
                }
            }

            results.push(result);
        }

        // Cache the biggest pool address if found
        if let Some((biggest_pool, _price_sol, _)) = biggest_pool_info {
            // Determine if this pool has separate reserve accounts (like PumpFun)
            let reserve_accounts = if biggest_pool.dex.to_lowercase().contains("pumpfun") {
                // For PumpFun, we'd need to extract the reserve account addresses
                // This would need to be implemented based on the pool data structure
                None // For now, implement later when we have the specific data
            } else {
                None
            };

            if
                let Err(e) = cache_pool_address(
                    token_mint,
                    &biggest_pool.address,
                    &biggest_pool.dex,
                    "Unknown", // Pool type would need to be determined
                    &biggest_pool.base_token,
                    &biggest_pool.quote_token,
                    reserve_accounts
                )
            {
                debug_log("ERROR", &format!("Failed to cache pool address: {}", e));
            } else {
                debug_log(
                    "CACHE",
                    &format!(
                        "Cached biggest pool address for token: {} -> {}",
                        token_mint,
                        biggest_pool.address
                    )
                );
            }
        } else {
            // Record failure if no valid pools found
            let error_msg = "No valid pools with SOL pairs found";
            debug_log("WARN", &error_msg);
            if let Err(e) = record_failed_token(token_mint, error_msg) {
                debug_log("ERROR", &format!("Failed to record failed token: {}", e));
            }
        }

        // Sort by liquidity (highest first) for better results
        results.sort_by(|a, b|
            b.liquidity_usd.partial_cmp(&a.liquidity_usd).unwrap_or(std::cmp::Ordering::Equal)
        );

        // Log summary
        let successful_pools = results
            .iter()
            .filter(|r| r.calculation_successful)
            .count();

        if successful_pools > 0 {
            pool_log(
                "SUCCESS",
                &format!(
                    "Completed: {}/{} pools successful for {}",
                    successful_pools,
                    results.len(),
                    token_mint
                )
            );
        } else {
            pool_log("WARN", &format!("No successful pools for token: {}", token_mint));
        }

        Ok(results)
    }

    /// Get program ID string for a given pool type
    fn get_program_id_for_pool_type(&self, pool_type: PoolType) -> String {
        match pool_type {
            PoolType::RaydiumCpmm => RAYDIUM_CPMM_PROGRAM_ID.to_string(),
            PoolType::RaydiumAmm => RAYDIUM_AMM_PROGRAM_ID.to_string(),
            PoolType::MeteoraDlmm => METEORA_DLMM_PROGRAM_ID.to_string(),
            PoolType::MeteoraDammV2 => METEORA_DAMM_V2_PROGRAM_ID.to_string(),
            PoolType::RaydiumLaunchLab => RAYDIUM_LAUNCHLAB_PROGRAM_ID.to_string(),
            PoolType::OrcaWhirlpool => ORCA_WHIRLPOOL_PROGRAM_ID.to_string(),
            PoolType::PumpfunAmm => PUMPFUN_AMM_PROGRAM_ID.to_string(),
            PoolType::PumpfunBondingCurve => PUMPFUN_BONDING_CURVE_PROGRAM_ID.to_string(),
            _ => "Unknown".to_string(),
        }
    }

    /// Get biggest pool for token with caching (5-minute expiration)
    pub async fn get_biggest_pool_cached(
        &self,
        token_mint: &str
    ) -> Result<Option<PoolPriceResult>> {
        // Check if token should be skipped
        if should_skip_token(token_mint) {
            debug_log("SKIP", &format!("Skipping token {} due to previous failures", token_mint));
            return Ok(None);
        }

        // Check cache first (5-minute cache)
        if let Some(cached_entry) = get_cached_pool_address(token_mint) {
            debug_log(
                "CACHE",
                &format!("Using cached biggest pool address for token: {}", token_mint)
            );

            // Get fresh price data from cached address
            if let Ok(fresh_results) = self.get_fresh_pool_price_from_address(&cached_entry).await {
                if
                    let Some(fresh_result) = fresh_results
                        .into_iter()
                        .find(|r| r.calculation_successful && r.is_sol_pair)
                {
                    debug_log(
                        "CACHE",
                        &format!(
                            "Got fresh price from cached address: ${:.8}",
                            fresh_result.calculated_price
                        )
                    );
                    return Ok(Some(fresh_result));
                } else {
                    debug_log(
                        "CACHE",
                        "No successful results from cached address, falling back to discovery"
                    );
                }
            } else {
                debug_log(
                    "CACHE",
                    "Failed to get fresh price from cached address, falling back to discovery"
                );
            }
        }

        pool_log("FETCH", &format!("Fetching biggest pool for token: {}", token_mint));

        // Fetch all pool prices (which will cache the biggest one)
        let pool_results = self.get_token_pool_prices(token_mint).await?;

        // Find the biggest successful pool (by liquidity)
        let biggest_pool = pool_results
            .into_iter()
            .filter(|p| p.calculation_successful && p.is_sol_pair)
            .max_by(|a, b|
                a.liquidity_usd.partial_cmp(&b.liquidity_usd).unwrap_or(std::cmp::Ordering::Equal)
            );

        if let Some(pool) = biggest_pool {
            pool_log(
                "SUCCESS",
                &format!(
                    "Found biggest pool for {}: {} (${:.2} liquidity)",
                    token_mint,
                    pool.dex_id,
                    pool.liquidity_usd
                )
            );
            Ok(Some(pool))
        } else {
            pool_log("WARN", &format!("No valid pools found for token: {}", token_mint));
            Ok(None)
        }
    }

    /// Get program IDs for token (simplified - discover from pools)
    pub async fn get_program_ids_cached(&self, token_mint: &str) -> Result<Vec<String>> {
        debug_log("FETCH", &format!("Getting program IDs for token: {}", token_mint));

        let discovered_pools = self.discover_pools(token_mint).await?;
        let mut program_ids = Vec::new();

        for pool in discovered_pools {
            if let Ok(pool_type) = self.detect_pool_type(&pool.pair_address).await {
                let program_id = match pool_type {
                    PoolType::RaydiumCpmm => RAYDIUM_CPMM_PROGRAM_ID.to_string(),
                    PoolType::RaydiumAmm => RAYDIUM_AMM_PROGRAM_ID.to_string(),
                    PoolType::MeteoraDlmm => METEORA_DLMM_PROGRAM_ID.to_string(),
                    PoolType::MeteoraDammV2 => METEORA_DAMM_V2_PROGRAM_ID.to_string(),
                    PoolType::RaydiumLaunchLab => RAYDIUM_LAUNCHLAB_PROGRAM_ID.to_string(),
                    PoolType::OrcaWhirlpool => ORCA_WHIRLPOOL_PROGRAM_ID.to_string(),
                    PoolType::PumpfunAmm => PUMPFUN_AMM_PROGRAM_ID.to_string(),
                    PoolType::PumpfunBondingCurve => PUMPFUN_BONDING_CURVE_PROGRAM_ID.to_string(),
                    _ => {
                        continue;
                    } // Skip unknown types
                };

                if !program_ids.contains(&program_id) {
                    program_ids.push(program_id);
                }
            }
        }

        debug_log(
            "SUCCESS",
            &format!("Found {} program IDs for token {}", program_ids.len(), token_mint)
        );
        Ok(program_ids)
    }

    /// Cleanup function for the new cache system
    pub fn cleanup_expired_cache(&self) {
        // Use the global cache cleanup function
        if let Err(e) = cleanup_expired_pools() {
            debug_log("ERROR", &format!("Failed to cleanup expired pools: {}", e));
        } else {
            debug_log("SUCCESS", "Cleaned up expired pool cache entries");
        }
    }

    /// Calculate on-chain pool price using discovered pool info
    async fn calculate_pool_price_with_discovery(
        &self,
        discovered_pool: &DiscoveredPool
    ) -> PoolPriceResult {
        // ALWAYS use program ID detection - ignore DexScreener classification completely
        pool_log(
            "INFO",
            &format!(
                "Detecting actual pool type for {} (ignoring DexScreener dex_id: '{}')",
                discovered_pool.pair_address,
                discovered_pool.dex_id
            )
        );

        let pool_type = match self.detect_pool_type(&discovered_pool.pair_address).await {
            Ok(detected_type) => {
                pool_log(
                    "SUCCESS",
                    &format!(
                        "Program ID detection: {:?} (DexScreener said: '{}')",
                        detected_type,
                        discovered_pool.dex_id
                    )
                );
                detected_type
            }
            Err(e) => {
                pool_log(
                    "ERROR",
                    &format!("Failed to detect pool type via program ID: {} - defaulting to Unknown", e)
                );
                PoolType::Unknown
            }
        };

        let dexscreener_price = discovered_pool.price_native.parse::<f64>().unwrap_or(0.0);

        let is_sol_pair =
            self.is_sol_mint(&discovered_pool.base_token.address) ||
            self.is_sol_mint(&discovered_pool.quote_token.address);

        // Only support pools with SOL/WSOL on one side
        if !is_sol_pair {
            let error_msg = format!(
                "Pool rejected: No SOL/WSOL pair (base: {}, quote: {})",
                discovered_pool.base_token.address,
                discovered_pool.quote_token.address
            );
            pool_log("WARN", &error_msg);

            return PoolPriceResult {
                pool_address: discovered_pool.pair_address.clone(),
                pool_type,
                dex_id: discovered_pool.dex_id.clone(),
                token_a_mint: discovered_pool.base_token.address.clone(),
                token_b_mint: discovered_pool.quote_token.address.clone(),
                token_a_symbol: discovered_pool.base_token.symbol.clone(),
                token_b_symbol: discovered_pool.quote_token.symbol.clone(),
                calculated_price: 0.0,
                dexscreener_price,
                price_difference_percent: 0.0,
                liquidity_usd: discovered_pool.liquidity_usd,
                volume_24h: discovered_pool.volume_24h,
                is_sol_pair: false,
                calculation_successful: false,
                error_message: Some(error_msg),
            };
        }

        // Try to calculate on-chain price with detected pool type
        let (calculated_price, calculation_successful, error_message) = match
            self.calculate_pool_price_with_type(&discovered_pool.pair_address, pool_type).await
        {
            Ok((price, _, _, _)) => {
                if price <= 0.0 {
                    let error_msg =
                        format!("Invalid price calculated: {} (price must be > 0)", price);
                    pool_log("WARN", &error_msg);
                    (price, false, Some(error_msg))
                } else {
                    pool_log(
                        "SUCCESS",
                        &format!("Price calculated successfully: {} for {:?}", price, pool_type)
                    );
                    (price, true, None)
                }
            }
            Err(e) => {
                let error_msg = format!("Failed to calculate on-chain price: {}", e);
                pool_log(
                    "ERROR",
                    &format!(
                        "Pool calculation failed - Address: {}, Type: {:?}, Error: {}",
                        discovered_pool.pair_address,
                        pool_type,
                        e
                    )
                );
                (0.0, false, Some(error_msg))
            }
        };

        let price_difference_percent = if dexscreener_price > 0.0 && calculated_price > 0.0 {
            ((calculated_price - dexscreener_price).abs() / dexscreener_price) * 100.0
        } else {
            0.0
        };

        PoolPriceResult {
            pool_address: discovered_pool.pair_address.clone(),
            pool_type,
            dex_id: discovered_pool.dex_id.clone(),
            token_a_mint: discovered_pool.base_token.address.clone(),
            token_b_mint: discovered_pool.quote_token.address.clone(),
            token_a_symbol: discovered_pool.base_token.symbol.clone(),
            token_b_symbol: discovered_pool.quote_token.symbol.clone(),
            calculated_price,
            dexscreener_price,
            price_difference_percent,
            liquidity_usd: discovered_pool.liquidity_usd,
            volume_24h: discovered_pool.volume_24h,
            is_sol_pair,
            calculation_successful,
            error_message,
        }
    }

    /// Universal pool price calculation method
    pub async fn calculate_pool_price(
        &self,
        pool_address: &str
    ) -> Result<(f64, String, String, PoolType)> {
        pool_log("INFO", &format!("Starting price calculation for pool: {}", pool_address));

        // First detect the pool type
        let pool_type = self.detect_pool_type(pool_address).await?;
        debug_log("DEBUG", &format!("Pool type detected: {:?}", pool_type));

        // Parse the pool data based on type
        let pool_data = self.parse_pool_data(pool_address, pool_type).await?;
        debug_log("DEBUG", "Pool data parsed successfully");

        // Calculate price using the universal method
        let price = self.calculate_price_from_pool_data(&pool_data).await?;
        pool_log(
            "SUCCESS",
            &format!("Price calculation completed: {} (pool type: {:?})", price, pool_type)
        );

        Ok((price, pool_data.token_a.mint.clone(), pool_data.token_b.mint.clone(), pool_type))
    }

    /// Calculate price with explicit pool type (for manual override)
    pub async fn calculate_pool_price_with_type(
        &self,
        pool_address: &str,
        pool_type: PoolType
    ) -> Result<(f64, String, String, PoolType)> {
        log(
            LogTag::Pool,
            "INFO",
            &format!(
                "Calculating price with explicit type {:?} for pool: {}",
                pool_type,
                pool_address
            )
        );
        let pool_data = self.parse_pool_data(pool_address, pool_type).await?;
        let price = self.calculate_price_from_pool_data(&pool_data).await?;

        Ok((price, pool_data.token_a.mint.clone(), pool_data.token_b.mint.clone(), pool_type))
    }

    /// Legacy method for backward compatibility
    pub async fn calculate_raydium_cpmm_price(
        &self,
        pool_address: &str
    ) -> Result<(f64, String, String)> {
        let (price, token_a, token_b, _) = self.calculate_pool_price_with_type(
            pool_address,
            PoolType::RaydiumCpmm
        ).await?;
        Ok((price, token_a, token_b))
    }

    /// Legacy method for backward compatibility
    pub async fn calculate_meteora_dlmm_price(
        &self,
        pool_address: &str
    ) -> Result<(f64, String, String)> {
        let (price, token_a, token_b, _) = self.calculate_pool_price_with_type(
            pool_address,
            PoolType::MeteoraDlmm
        ).await?;
        Ok((price, token_a, token_b))
    }

    /// Auto-detect pool type based on pool address and program ID owner
    pub async fn detect_pool_type(&self, pool_address: &str) -> Result<PoolType> {
        let pool_pubkey = match Pubkey::from_str(pool_address) {
            Ok(pubkey) => pubkey,
            Err(e) => {
                log(
                    LogTag::Pool,
                    "ERROR",
                    &format!(
                        "❌ INVALID POOL ADDRESS\n\
                    Pool Address: {}\n\
                    Error: Failed to parse as Pubkey - {}",
                        pool_address,
                        e
                    )
                );
                return Err(anyhow::anyhow!("Invalid pool address: {}", e));
            }
        };

        let account_info = match self.rpc_client.get_account(&pool_pubkey) {
            Ok(info) => info,
            Err(e) => {
                log(
                    LogTag::Pool,
                    "ERROR",
                    &format!(
                        "❌ FAILED TO FETCH POOL ACCOUNT\n\
                    Pool Address: {}\n\
                    Error: RPC call failed - {}",
                        pool_address,
                        e
                    )
                );
                return Err(anyhow::anyhow!("Failed to fetch pool account: {}", e));
            }
        };

        // Get the program ID that owns this account
        let program_id = account_info.owner.to_string();

        debug_log("DEBUG", &format!("Pool account data size: {} bytes", account_info.data.len()));

        pool_log(
            "INFO",
            &format!("Detecting pool type for {} (program: {})", pool_address, program_id)
        );

        // Determine pool type based on program ID
        match program_id.as_str() {
            // Raydium CPMM Program ID
            id if id == RAYDIUM_CPMM_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Raydium CPMM pool");
                Ok(PoolType::RaydiumCpmm)
            }
            // Meteora DLMM Program ID
            id if id == METEORA_DLMM_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Meteora DLMM pool");
                Ok(PoolType::MeteoraDlmm)
            }
            // Meteora DAMM v2 Program ID
            id if id == METEORA_DAMM_V2_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Meteora DAMM v2 pool");
                Ok(PoolType::MeteoraDammV2)
            }
            // Raydium LaunchLab Program ID
            id if id == RAYDIUM_LAUNCHLAB_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Raydium LaunchLab pool");
                Ok(PoolType::RaydiumLaunchLab)
            }
            // Orca Whirlpool Program ID
            id if id == ORCA_WHIRLPOOL_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Orca Whirlpool pool");
                Ok(PoolType::OrcaWhirlpool)
            }
            // Pump.fun AMM Program ID
            id if id == PUMPFUN_AMM_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Pump.fun AMM pool");
                Ok(PoolType::PumpfunAmm)
            }
            // Pump.fun Bonding Curve Program ID
            id if id == PUMPFUN_BONDING_CURVE_PROGRAM_ID => {
                pool_log("SUCCESS", "Detected: Pump.fun Bonding Curve pool");
                Ok(PoolType::PumpfunBondingCurve)
            }
            // Add other DEX program IDs as needed
            // Phoenix, Orca, etc.

            // Unknown program ID
            _ => {
                pool_log(
                    "WARN",
                    &format!(
                        "⚠️ UNKNOWN PROGRAM ID\n\
                    Pool Address: {}\n\
                    Program ID: {}\n\
                    Data Size: {} bytes\n\
                    Falling back to size-based detection",
                        pool_address,
                        program_id,
                        account_info.data.len()
                    )
                );

                // Fallback to size-based detection as a last resort
                let account_data = account_info.data.clone();
                log(
                    LogTag::Pool,
                    "DEBUG",
                    &format!(
                        "Using fallback detection with data size: {} bytes",
                        account_data.len()
                    )
                );

                if account_data.len() >= 800 {
                    log(
                        LogTag::Pool,
                        "WARN",
                        "Guessing: Meteora DLMM (based on data size >= 800 bytes)"
                    );
                    Ok(PoolType::MeteoraDlmm)
                } else if account_data.len() >= 600 {
                    log(
                        LogTag::Pool,
                        "WARN",
                        "Guessing: Raydium CPMM (based on data size >= 600 bytes)"
                    );
                    Ok(PoolType::RaydiumCpmm)
                } else {
                    log(
                        LogTag::Pool,
                        "ERROR",
                        &format!(
                            "❌ POOL TYPE DETECTION FAILED\n\
                        Pool Address: {}\n\
                        Program ID: {}\n\
                        Data Size: {} bytes\n\
                        Defaulting to: Raydium CPMM",
                            pool_address,
                            program_id,
                            account_data.len()
                        )
                    );
                    Ok(PoolType::RaydiumCpmm)
                }
            }
        }
    }

    /*
    /// Batch fetch all required account data for a pool in a single RPC call
    pub async fn batch_fetch_pool_accounts(
        &self,
        pool_address: &str,
        vault_addresses: &[String],
        mint_addresses: &[String]
    ) -> Result<(Vec<u8>, Vec<Option<Vec<u8>>>, Vec<Option<Vec<u8>>>)> {
        let pool_pubkey = Pubkey::from_str(pool_address)?;
        
        // Collect all account pubkeys to fetch in one call
        let mut all_pubkeys = vec![pool_pubkey];
        
        // Add vault pubkeys
        for vault_addr in vault_addresses {
            if let Ok(vault_pubkey) = Pubkey::from_str(vault_addr) {
                all_pubkeys.push(vault_pubkey);
            }
        }
        
        // Add mint pubkeys
        for mint_addr in mint_addresses {
            if let Ok(mint_pubkey) = Pubkey::from_str(mint_addr) {
                all_pubkeys.push(mint_pubkey);
            }
        }

        pool_log("INFO", &format!(
            "Batch fetching {} accounts (1 pool + {} vaults + {} mints)",
            all_pubkeys.len(), vault_addresses.len(), mint_addresses.len()
        ));

        // Make single getMultipleAccounts RPC call
        let accounts = self.rpc_client.get_multiple_accounts(&all_pubkeys)?;
        
        // Extract pool account data (first account, always required)
        let pool_data = accounts[0].as_ref()
            .ok_or_else(|| anyhow::anyhow!("Pool account not found"))?
            .data.clone();

        // Extract vault account data
        let vault_count = vault_addresses.len();
        let vault_data: Vec<Option<Vec<u8>>> = accounts[1..1+vault_count]
            .iter()
            .map(|acc| acc.as_ref().map(|a| a.data.clone()))
            .collect();

        // Extract mint account data  
        let mint_data: Vec<Option<Vec<u8>>> = accounts[1+vault_count..]
            .iter()
            .map(|acc| acc.as_ref().map(|a| a.data.clone()))
            .collect();

        debug_log("SUCCESS", &format!(
            "Batch fetched: pool={} bytes, {} vaults, {} mints",
            pool_data.len(), vault_data.len(), mint_data.len()
        ));

        Ok((pool_data, vault_data, mint_data))
    }

    /// Extract token balance from vault account data
    fn extract_token_balance_from_data(vault_data: &[u8]) -> Result<u64> {
        // Token account balance is stored at offset 64 (8 bytes, little-endian)
        if vault_data.len() < 72 {
            return Err(anyhow::anyhow!("Token account data too short"));
        }

        let balance_bytes: [u8; 8] = vault_data[64..72].try_into()?;
        let balance = u64::from_le_bytes(balance_bytes);
        Ok(balance)
    }

    /// Extract token decimals from mint account data
    fn extract_token_decimals_from_data(mint_data: &[u8]) -> Result<u8> {
        // For SPL Token mints, decimals is stored at offset 44 (1 byte)
        if mint_data.len() < 45 {
            return Err(anyhow::anyhow!("Mint account data too short"));
        }

        // Decimals is at offset 44 (1 byte)
        let decimals = mint_data[44];
        Ok(decimals)
    }

    /// Universal pool data parser with optimized batched account fetching
    pub async fn parse_pool_data_batched(
        &self,
        pool_address: &str,
        pool_type: PoolType
    ) -> Result<PoolData> {
        // First get basic pool data to determine vault and mint addresses
        let pool_pubkey = Pubkey::from_str(pool_address)?;
        let pool_account_data = self.rpc_client.get_account_data(&pool_pubkey)?;

        match pool_type {
            PoolType::RaydiumCpmm => {
                let raw_data = parse_raydium_cpmm_data(&pool_account_data)?;

                // Batch fetch vault balances and mint decimals
                let vault_addresses = vec![raw_data.token_0_vault.clone(), raw_data.token_1_vault.clone()];
                let mint_addresses = vec![raw_data.token_0_mint.clone(), raw_data.token_1_mint.clone()];
                
                let (_, vault_data, mint_data) = self.batch_fetch_pool_accounts(
                    pool_address,
                    &vault_addresses,
                    &mint_addresses
                ).await?;

                // Extract balances and decimals from batched data
                let token_0_balance = vault_data[0].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let token_1_balance = vault_data[1].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let token_0_decimals = mint_data[0].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(raw_data.mint_0_decimals);

                let token_1_decimals = mint_data[1].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(raw_data.mint_1_decimals);

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_0_mint,
                        decimals: token_0_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_1_mint,
                        decimals: token_1_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_0_vault,
                        balance: token_0_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_1_vault,
                        balance: token_1_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumCpmm {
                        lp_mint: "".to_string(), // Not available in current parser, would need additional parsing
                        observation_key: "".to_string(), // Not available in current parser
                    },
                })
            }
            PoolType::MeteoraDlmm => {
                let raw_data = parse_meteora_dlmm_data(&pool_account_data)?;

                // Batch fetch reserve balances and mint decimals
                let vault_addresses = vec![raw_data.reserve_x.clone(), raw_data.reserve_y.clone()];
                let mint_addresses = vec![raw_data.token_x_mint.clone(), raw_data.token_y_mint.clone()];
                
                let (_, vault_data, mint_data) = self.batch_fetch_pool_accounts(
                    pool_address,
                    &vault_addresses,
                    &mint_addresses
                ).await?;

                // Extract balances and decimals from batched data
                let reserve_x_balance = vault_data[0].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let reserve_y_balance = vault_data[1].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let token_x_decimals = mint_data[0].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(9); // Default for unknown tokens

                let token_y_decimals = mint_data[1].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(9);

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_x_mint,
                        decimals: token_x_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_y_mint,
                        decimals: token_y_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.reserve_x,
                        balance: reserve_x_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.reserve_y,
                        balance: reserve_y_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDlmm {
                        active_id: raw_data.active_id,
                        bin_step: raw_data.bin_step,
                        oracle: "".to_string(), // DLMM doesn't use oracle in this context
                    },
                })
            }
            PoolType::MeteoraDammV2 => {
                let raw_data = parse_meteora_damm_v2_data(&pool_account_data)?;

                // Batch fetch vault balances and mint decimals
                let vault_addresses = vec![raw_data.token_a_vault.clone(), raw_data.token_b_vault.clone()];
                let mint_addresses = vec![raw_data.token_a_mint.clone(), raw_data.token_b_mint.clone()];
                
                let (_, vault_data, mint_data) = self.batch_fetch_pool_accounts(
                    pool_address,
                    &vault_addresses,
                    &mint_addresses
                ).await?;

                // Extract balances and decimals from batched data
                let token_a_balance = vault_data[0].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let token_b_balance = vault_data[1].as_ref()
                    .map(|data| Self::extract_token_balance_from_data(data))
                    .transpose()?
                    .unwrap_or(0);

                let token_a_decimals = mint_data[0].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(9);

                let token_b_decimals = mint_data[1].as_ref()
                    .map(|data| Self::extract_token_decimals_from_data(data))
                    .transpose()?
                    .unwrap_or(9);

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_a_mint,
                        decimals: token_a_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_b_mint,
                        decimals: token_b_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_a_vault,
                        balance: token_a_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_b_vault,
                        balance: token_b_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDammV2 {
                        sqrt_price: raw_data.sqrt_price,
                        liquidity: raw_data.liquidity,
                    },
                })
            }
            // For other pool types, fall back to the original method for now
            _ => {
                self.parse_pool_data_legacy(pool_address, pool_type).await
            }
        }
    }
    */

    /// Universal pool data parser - uses optimized batched fetching by default
    pub async fn parse_pool_data(
        &self,
        pool_address: &str,
        pool_type: PoolType
    ) -> Result<PoolData> {
        // Use the legacy method for now until batched version is fixed
        self.parse_pool_data_legacy(pool_address, pool_type).await
    }

    /// NEW: Batch-optimized pool data parser - reduces RPC calls from 5 to 1
    pub async fn parse_pool_data_with_batch_rpc(
        &self,
        pool_address: &str,
        pool_type: PoolType
    ) -> Result<PoolData> {
        // Simple batched implementation for now - can be expanded
        match pool_type {
            PoolType::RaydiumCpmm => {
                // Get pool data first
                let pool_pubkey = Pubkey::from_str(pool_address)?;
                let pool_data = self.rpc_client.get_account_data(&pool_pubkey)?;
                let raw_data = parse_raydium_cpmm_data(&pool_data)?;

                // Batch fetch vault and mint accounts
                let vault_0_pubkey = Pubkey::from_str(&raw_data.token_0_vault)?;
                let vault_1_pubkey = Pubkey::from_str(&raw_data.token_1_vault)?;
                let mint_0_pubkey = Pubkey::from_str(&raw_data.token_0_mint)?;
                let mint_1_pubkey = Pubkey::from_str(&raw_data.token_1_mint)?;
                
                let accounts_to_fetch = vec![vault_0_pubkey, vault_1_pubkey, mint_0_pubkey, mint_1_pubkey];
                
                pool_log("INFO", &format!("Batch fetching 4 accounts for Raydium CPMM pool"));
                let accounts = self.rpc_client.get_multiple_accounts(&accounts_to_fetch)?;
                
                // Extract balances and decimals
                let token_0_balance = if let Some(vault_0_account) = &accounts[0] {
                    let balance_bytes: [u8; 8] = vault_0_account.data[64..72].try_into()?;
                    u64::from_le_bytes(balance_bytes)
                } else { 0 };
                
                let token_1_balance = if let Some(vault_1_account) = &accounts[1] {
                    let balance_bytes: [u8; 8] = vault_1_account.data[64..72].try_into()?;
                    u64::from_le_bytes(balance_bytes)
                } else { 0 };
                
                let token_0_decimals = if let Some(mint_0_account) = &accounts[2] {
                    mint_0_account.data[44]
                } else { raw_data.mint_0_decimals };
                
                let token_1_decimals = if let Some(mint_1_account) = &accounts[3] {
                    mint_1_account.data[44]
                } else { raw_data.mint_1_decimals };

                pool_log("SUCCESS", &format!("Batched RPC: 1 call instead of 5 for Raydium CPMM"));

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_0_mint,
                        decimals: token_0_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_1_mint,
                        decimals: token_1_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_0_vault,
                        balance: token_0_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_1_vault,
                        balance: token_1_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumCpmm {
                        lp_mint: "".to_string(),
                        observation_key: "".to_string(),
                    },
                })
            }
            // For other pool types, fall back to legacy method for now
            _ => {
                pool_log("INFO", &format!("Using legacy method for pool type: {:?}", pool_type));
                self.parse_pool_data_legacy(pool_address, pool_type).await
            }
        }
    }

    /// Legacy pool data parser (original implementation for compatibility/fallback)
    pub async fn parse_pool_data_legacy(
        &self,
        pool_address: &str,
        pool_type: PoolType
    ) -> Result<PoolData> {
        let pool_pubkey = Pubkey::from_str(pool_address)?;
        let account_data = self.rpc_client.get_account_data(&pool_pubkey)?;

        match pool_type {
            PoolType::RaydiumCpmm => {
                let raw_data = parse_raydium_cpmm_data(&account_data)?;

                // Get token vault balances
                let token_0_vault_pubkey = Pubkey::from_str(&raw_data.token_0_vault)?;
                let token_1_vault_pubkey = Pubkey::from_str(&raw_data.token_1_vault)?;

                let token_0_balance = self.get_token_balance(&token_0_vault_pubkey).await?;
                let token_1_balance = self.get_token_balance(&token_1_vault_pubkey).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_0_mint,
                        decimals: raw_data.mint_0_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_1_mint,
                        decimals: raw_data.mint_1_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_0_vault,
                        balance: token_0_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_1_vault,
                        balance: token_1_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumCpmm {
                        lp_mint: "".to_string(), // Not available in current parser
                        observation_key: "".to_string(), // Not available in current parser
                    },
                })
            }
            PoolType::RaydiumAmm => {
                let raw_data = parse_raydium_amm_data(&account_data)?;

                // Get token vault balances
                let base_vault_pubkey = Pubkey::from_str(&raw_data.base_vault)?;
                let quote_vault_pubkey = Pubkey::from_str(&raw_data.quote_vault)?;

                let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                // Get decimals for both tokens
                let base_decimals = self.get_token_decimals(&raw_data.base_mint).await?;
                let quote_decimals = self.get_token_decimals(&raw_data.quote_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.base_mint,
                        decimals: base_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.quote_mint,
                        decimals: quote_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.base_vault.clone(),
                        balance: base_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.quote_vault.clone(),
                        balance: quote_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumAmm {
                        base_vault: raw_data.base_vault,
                        quote_vault: raw_data.quote_vault,
                    },
                })
            }
            PoolType::MeteoraDlmm => {
                let raw_data = parse_meteora_dlmm_data(&account_data)?;

                // Get token reserve balances
                let reserve_x_pubkey = Pubkey::from_str(&raw_data.reserve_x)?;
                let reserve_y_pubkey = Pubkey::from_str(&raw_data.reserve_y)?;

                let reserve_x_balance = self.get_token_balance(&reserve_x_pubkey).await?;
                let reserve_y_balance = self.get_token_balance(&reserve_y_pubkey).await?;

                // Get decimals for both tokens
                let token_x_decimals = self.get_token_decimals(&raw_data.token_x_mint).await?;
                let token_y_decimals = self.get_token_decimals(&raw_data.token_y_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_x_mint,
                        decimals: token_x_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_y_mint,
                        decimals: token_y_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.reserve_x,
                        balance: reserve_x_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.reserve_y,
                        balance: reserve_y_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDlmm {
                        active_id: raw_data.active_id,
                        bin_step: raw_data.bin_step,
                        oracle: "".to_string(), // Not available in current parser
                    },
                })
            }
            PoolType::MeteoraDammV2 => {
                let raw_data = parse_meteora_damm_v2_data(&account_data)?;

                // Get token vault balances
                let token_a_vault_pubkey = Pubkey::from_str(&raw_data.token_a_vault)?;
                let token_b_vault_pubkey = Pubkey::from_str(&raw_data.token_b_vault)?;

                let token_a_balance = self.get_token_balance(&token_a_vault_pubkey).await?;
                let token_b_balance = self.get_token_balance(&token_b_vault_pubkey).await?;

                // Get decimals for both tokens
                let token_a_decimals = self.get_token_decimals(&raw_data.token_a_mint).await?;
                let token_b_decimals = self.get_token_decimals(&raw_data.token_b_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_a_mint,
                        decimals: token_a_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_b_mint,
                        decimals: token_b_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_a_vault,
                        balance: token_a_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_b_vault,
                        balance: token_b_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDammV2 {
                        sqrt_price: raw_data.sqrt_price,
                        liquidity: raw_data.liquidity,
                    },
                })
            }
            PoolType::RaydiumLaunchLab => {
                let raw_data = parse_raydium_launchlab_data(&account_data)?;

                // Get token vault balances (with fallback error handling)
                let base_vault_pubkey = Pubkey::from_str(&raw_data.base_vault)?;
                let quote_vault_pubkey = Pubkey::from_str(&raw_data.quote_vault)?;

                let base_balance = match self.get_token_balance(&base_vault_pubkey).await {
                    Ok(balance) => balance,
                    Err(e) => {
                        pool_log("WARN", &format!("Failed to get base vault balance: {}", e));
                        0 // Use 0 as fallback for balance calculation
                    }
                };

                let quote_balance = match self.get_token_balance(&quote_vault_pubkey).await {
                    Ok(balance) => balance,
                    Err(e) => {
                        pool_log("WARN", &format!("Failed to get quote vault balance: {}", e));
                        0 // Use 0 as fallback for balance calculation
                    }
                };

                // Get decimals for both tokens
                let base_decimals = self.get_token_decimals(&raw_data.base_mint).await?;
                let quote_decimals = self.get_token_decimals(&raw_data.quote_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.base_mint,
                        decimals: base_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.quote_mint,
                        decimals: quote_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.base_vault.clone(),
                        balance: base_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.quote_vault.clone(),
                        balance: quote_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumLaunchLab {
                        total_base_sell: raw_data.total_base_sell,
                        real_base: raw_data.real_base,
                        real_quote: raw_data.real_quote,
                    },
                })
            }
            PoolType::OrcaWhirlpool => {
                let raw_data = parse_orca_whirlpool_data(&account_data)?;

                // Get decimals for both tokens (required)
                let token_a_decimals = self.get_token_decimals(&raw_data.token_mint_a).await?;
                let token_b_decimals = self.get_token_decimals(&raw_data.token_mint_b).await?;

                // Try to get token vault balances (optional - for fallback calculation)
                let (token_a_balance, token_b_balance) = match
                    (
                        Pubkey::from_str(&raw_data.token_vault_a),
                        Pubkey::from_str(&raw_data.token_vault_b),
                    )
                {
                    (Ok(vault_a), Ok(vault_b)) => {
                        let balance_a = self.get_token_balance(&vault_a).await.unwrap_or(0);
                        let balance_b = self.get_token_balance(&vault_b).await.unwrap_or(0);
                        debug_log("DEBUG", &format!("Got Orca vault balances: A={}, B={}", balance_a, balance_b));
                        (balance_a, balance_b)
                    }
                    _ => {
                        debug_log("WARN", "Failed to get Orca vault balances, using sqrt_price calculation");
                        (0, 0)
                    }
                };

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_mint_a,
                        decimals: token_a_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_mint_b,
                        decimals: token_b_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_vault_a,
                        balance: token_a_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_vault_b,
                        balance: token_b_balance,
                    },
                    specific_data: PoolSpecificData::OrcaWhirlpool {
                        sqrt_price: raw_data.sqrt_price,
                        liquidity: raw_data.liquidity,
                        tick_current_index: raw_data.tick_current_index,
                        tick_spacing: raw_data.tick_spacing,
                        fee_rate: raw_data.fee_rate,
                        protocol_fee_rate: raw_data.protocol_fee_rate,
                    },
                })
            }
            PoolType::PumpfunAmm => {
                let raw_data = parse_pumpfun_amm_pool(&account_data)?;

                // Extract the specific data
                if let PoolSpecificData::PumpfunAmm { .. } = &raw_data.specific_data {
                    // Get token vault balances from the parsed data
                    let base_vault_pubkey = Pubkey::from_str(&raw_data.reserve_a.vault_address)?;
                    let quote_vault_pubkey = Pubkey::from_str(&raw_data.reserve_b.vault_address)?;

                    let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                    let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                    // Update the balance data
                    let mut updated_data = raw_data.clone();
                    updated_data.reserve_a.balance = base_balance;
                    updated_data.reserve_b.balance = quote_balance;

                    Ok(updated_data)
                } else {
                    Err(anyhow::anyhow!("Expected PumpfunAmm specific data"))
                }
            }
            PoolType::PumpfunBondingCurve => {
                // For now, try to parse as AMM - bonding curve might use similar structure
                // If this fails, we'll need to create a separate parser for bonding curve
                match parse_pumpfun_amm_pool(&account_data) {
                    Ok(raw_data) => {
                        // Extract the specific data and convert to bonding curve
                        if
                            let PoolSpecificData::PumpfunAmm {
                                pool_bump,
                                index,
                                creator,
                                lp_mint,
                                lp_supply,
                                coin_creator,
                            } = &raw_data.specific_data
                        {
                            // Get token vault balances from the parsed data
                            let base_vault_pubkey = Pubkey::from_str(
                                &raw_data.reserve_a.vault_address
                            )?;
                            let quote_vault_pubkey = Pubkey::from_str(
                                &raw_data.reserve_b.vault_address
                            )?;

                            let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                            let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                            Ok(PoolData {
                                pool_type,
                                token_a: raw_data.token_a.clone(),
                                token_b: raw_data.token_b.clone(),
                                reserve_a: ReserveInfo {
                                    vault_address: raw_data.reserve_a.vault_address.clone(),
                                    balance: base_balance,
                                },
                                reserve_b: ReserveInfo {
                                    vault_address: raw_data.reserve_b.vault_address.clone(),
                                    balance: quote_balance,
                                },
                                specific_data: PoolSpecificData::PumpfunBondingCurve {
                                    pool_bump: *pool_bump,
                                    index: *index,
                                    creator: creator.clone(),
                                    lp_mint: lp_mint.clone(),
                                    lp_supply: *lp_supply,
                                    coin_creator: coin_creator.clone(),
                                },
                            })
                        } else {
                            Err(
                                anyhow::anyhow!(
                                    "Expected PumpfunAmm specific data for bonding curve conversion"
                                )
                            )
                        }
                    }
                    Err(e) => {
                        pool_log("WARN", &format!("Pump.fun bonding curve parsing failed: {}", e));
                        // Return error for now - we'll implement proper bonding curve parser if needed
                        Err(
                            anyhow::anyhow!(
                                "Pump.fun bonding curve parsing not yet implemented: {}",
                                e
                            )
                        )
                    }
                }
            }
            _ => {
                return Err(anyhow::anyhow!("Unsupported pool type: {:?}", pool_type));
            }
        }
    }

        match pool_type {
            PoolType::RaydiumCpmm => {
                let raw_data = parse_raydium_cpmm_data(&account_data)?;

                // Get token vault balances
                let token_0_vault_pubkey = Pubkey::from_str(&raw_data.token_0_vault)?;
                let token_1_vault_pubkey = Pubkey::from_str(&raw_data.token_1_vault)?;

                let token_0_balance = self.get_token_balance(&token_0_vault_pubkey).await?;
                let token_1_balance = self.get_token_balance(&token_1_vault_pubkey).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_0_mint,
                        decimals: raw_data.mint_0_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_1_mint,
                        decimals: raw_data.mint_1_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_0_vault,
                        balance: token_0_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_1_vault,
                        balance: token_1_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumCpmm {
                        lp_mint: "".to_string(),
                        observation_key: "".to_string(),
                    },
                })
            }
            PoolType::RaydiumAmm => {
                let raw_data = parse_raydium_amm_data(&account_data)?;

                // Get token vault balances
                let base_vault_pubkey = Pubkey::from_str(&raw_data.base_vault)?;
                let quote_vault_pubkey = Pubkey::from_str(&raw_data.quote_vault)?;

                let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                // Get decimals for both tokens
                let base_decimals = self.get_token_decimals(&raw_data.base_mint).await?;
                let quote_decimals = self.get_token_decimals(&raw_data.quote_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.base_mint,
                        decimals: base_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.quote_mint,
                        decimals: quote_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.base_vault.clone(),
                        balance: base_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.quote_vault.clone(),
                        balance: quote_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumAmm {
                        base_vault: raw_data.base_vault,
                        quote_vault: raw_data.quote_vault,
                    },
                })
            }
            PoolType::MeteoraDlmm => {
                let raw_data = parse_meteora_dlmm_data(&account_data)?;

                // Get token reserve balances
                let reserve_x_pubkey = Pubkey::from_str(&raw_data.reserve_x)?;
                let reserve_y_pubkey = Pubkey::from_str(&raw_data.reserve_y)?;

                let reserve_x_balance = self.get_token_balance(&reserve_x_pubkey).await?;
                let reserve_y_balance = self.get_token_balance(&reserve_y_pubkey).await?;

                // Get decimals for both tokens
                let token_x_decimals = self.get_token_decimals(&raw_data.token_x_mint).await?;
                let token_y_decimals = self.get_token_decimals(&raw_data.token_y_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_x_mint,
                        decimals: token_x_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_y_mint,
                        decimals: token_y_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.reserve_x,
                        balance: reserve_x_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.reserve_y,
                        balance: reserve_y_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDlmm {
                        active_id: raw_data.active_id,
                        bin_step: raw_data.bin_step,
                        oracle: "".to_string(),
                    },
                })
            }
            PoolType::MeteoraDammV2 => {
                let raw_data = parse_meteora_damm_v2_data(&account_data)?;

                // Get token vault balances
                let token_a_vault_pubkey = Pubkey::from_str(&raw_data.token_a_vault)?;
                let token_b_vault_pubkey = Pubkey::from_str(&raw_data.token_b_vault)?;

                let token_a_balance = self.get_token_balance(&token_a_vault_pubkey).await?;
                let token_b_balance = self.get_token_balance(&token_b_vault_pubkey).await?;

                // Get decimals for both tokens
                let token_a_decimals = self.get_token_decimals(&raw_data.token_a_mint).await?;
                let token_b_decimals = self.get_token_decimals(&raw_data.token_b_mint).await?;

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_a_mint,
                        decimals: token_a_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_b_mint,
                        decimals: token_b_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_a_vault,
                        balance: token_a_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_b_vault,
                        balance: token_b_balance,
                    },
                    specific_data: PoolSpecificData::MeteoraDammV2 {
                        sqrt_price: raw_data.sqrt_price,
                        liquidity: raw_data.liquidity,
                    },
                })
            }
            PoolType::RaydiumLaunchLab => {
                let raw_data = parse_raydium_launchlab_data(&account_data)?;

                // Get token vault balances - handle cases where vaults might not exist
                let base_vault_pubkey = Pubkey::from_str(&raw_data.base_vault)?;
                let quote_vault_pubkey = Pubkey::from_str(&raw_data.quote_vault)?;

                let base_balance = match self.get_token_balance(&base_vault_pubkey).await {
                    Ok(balance) => balance,
                    Err(e) => {
                        log(
                            LogTag::Pool,
                            "WARN",
                            &format!("Failed to get base vault balance, using real_base: {}", e)
                        );
                        raw_data.real_base
                    }
                };

                let quote_balance = match self.get_token_balance(&quote_vault_pubkey).await {
                    Ok(balance) => balance,
                    Err(e) => {
                        log(
                            LogTag::Pool,
                            "WARN",
                            &format!("Failed to get quote vault balance, using real_quote: {}", e)
                        );
                        raw_data.real_quote
                    }
                };

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.base_mint,
                        decimals: raw_data.base_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.quote_mint,
                        decimals: raw_data.quote_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.base_vault,
                        balance: base_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.quote_vault,
                        balance: quote_balance,
                    },
                    specific_data: PoolSpecificData::RaydiumLaunchLab {
                        total_base_sell: raw_data.total_base_sell,
                        real_base: raw_data.real_base,
                        real_quote: raw_data.real_quote,
                    },
                })
            }
            PoolType::OrcaWhirlpool => {
                let raw_data = parse_orca_whirlpool_data(&account_data)?;

                // Get decimals for both tokens (required)
                let token_a_decimals = self.get_token_decimals(&raw_data.token_mint_a).await?;
                let token_b_decimals = self.get_token_decimals(&raw_data.token_mint_b).await?;

                // Try to get token vault balances (optional - for fallback calculation)
                let (token_a_balance, token_b_balance) = match
                    (
                        Pubkey::from_str(&raw_data.token_vault_a),
                        Pubkey::from_str(&raw_data.token_vault_b),
                    )
                {
                    (Ok(vault_a), Ok(vault_b)) => {
                        let balance_a = self.get_token_balance(&vault_a).await.unwrap_or(0);
                        let balance_b = self.get_token_balance(&vault_b).await.unwrap_or(0);
                        log(
                            LogTag::Pool,
                            "DEBUG",
                            &format!("Got Orca vault balances: A={}, B={}", balance_a, balance_b)
                        );
                        (balance_a, balance_b)
                    }
                    _ => {
                        log(
                            LogTag::Pool,
                            "WARN",
                            "Failed to get Orca vault balances, using sqrt_price calculation"
                        );
                        (0, 0)
                    }
                };

                Ok(PoolData {
                    pool_type,
                    token_a: TokenInfo {
                        mint: raw_data.token_mint_a,
                        decimals: token_a_decimals,
                    },
                    token_b: TokenInfo {
                        mint: raw_data.token_mint_b,
                        decimals: token_b_decimals,
                    },
                    reserve_a: ReserveInfo {
                        vault_address: raw_data.token_vault_a,
                        balance: token_a_balance,
                    },
                    reserve_b: ReserveInfo {
                        vault_address: raw_data.token_vault_b,
                        balance: token_b_balance,
                    },
                    specific_data: PoolSpecificData::OrcaWhirlpool {
                        sqrt_price: raw_data.sqrt_price,
                        liquidity: raw_data.liquidity,
                        tick_current_index: raw_data.tick_current_index,
                        tick_spacing: raw_data.tick_spacing,
                        fee_rate: raw_data.fee_rate,
                        protocol_fee_rate: raw_data.protocol_fee_rate,
                    },
                })
            }
            PoolType::PumpfunAmm => {
                let raw_data = parse_pumpfun_amm_pool(&account_data)?;

                // Extract the specific data
                if let PoolSpecificData::PumpfunAmm { .. } = &raw_data.specific_data {
                    // Get token vault balances from the parsed data
                    let base_vault_pubkey = Pubkey::from_str(&raw_data.reserve_a.vault_address)?;
                    let quote_vault_pubkey = Pubkey::from_str(&raw_data.reserve_b.vault_address)?;

                    let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                    let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                    // Update the balance data
                    let mut updated_data = raw_data.clone();
                    updated_data.reserve_a.balance = base_balance;
                    updated_data.reserve_b.balance = quote_balance;

                    Ok(updated_data)
                } else {
                    Err(anyhow::anyhow!("Expected PumpfunAmm specific data"))
                }
            }
            PoolType::PumpfunBondingCurve => {
                // For now, try to parse as AMM - bonding curve might use similar structure
                // If this fails, we'll need to create a separate parser for bonding curve
                match parse_pumpfun_amm_pool(&account_data) {
                    Ok(raw_data) => {
                        // Extract the specific data and convert to bonding curve
                        if
                            let PoolSpecificData::PumpfunAmm {
                                pool_bump,
                                index,
                                creator,
                                lp_mint,
                                lp_supply,
                                coin_creator,
                            } = &raw_data.specific_data
                        {
                            // Get token vault balances from the parsed data
                            let base_vault_pubkey = Pubkey::from_str(
                                &raw_data.reserve_a.vault_address
                            )?;
                            let quote_vault_pubkey = Pubkey::from_str(
                                &raw_data.reserve_b.vault_address
                            )?;

                            let base_balance = self.get_token_balance(&base_vault_pubkey).await?;
                            let quote_balance = self.get_token_balance(&quote_vault_pubkey).await?;

                            Ok(PoolData {
                                pool_type,
                                token_a: raw_data.token_a.clone(),
                                token_b: raw_data.token_b.clone(),
                                reserve_a: ReserveInfo {
                                    vault_address: raw_data.reserve_a.vault_address.clone(),
                                    balance: base_balance,
                                },
                                reserve_b: ReserveInfo {
                                    vault_address: raw_data.reserve_b.vault_address.clone(),
                                    balance: quote_balance,
                                },
                                specific_data: PoolSpecificData::PumpfunBondingCurve {
                                    pool_bump: *pool_bump,
                                    index: *index,
                                    creator: creator.clone(),
                                    lp_mint: lp_mint.clone(),
                                    lp_supply: *lp_supply,
                                    coin_creator: coin_creator.clone(),
                                },
                            })
                        } else {
                            Err(
                                anyhow::anyhow!(
                                    "Expected PumpfunAmm specific data for bonding curve conversion"
                                )
                            )
                        }
                    }
                    Err(e) => {
                        pool_log("WARN", &format!("Pump.fun bonding curve parsing failed: {}", e));
                        // Return error for now - we'll implement proper bonding curve parser if needed
                        Err(
                            anyhow::anyhow!(
                                "Pump.fun bonding curve parsing not yet implemented: {}",
                                e
                            )
                        )
                    }
                }
            }
            _ => {
                return Err(anyhow::anyhow!("Unsupported pool type: {:?}", pool_type));
            }
        }
    }

    /// Universal price calculation method with smart SOL/Token orientation
    pub async fn calculate_price_from_pool_data(&self, pool_data: &PoolData) -> Result<f64> {
        // Load decimal cache
        let cache_path = Path::new("decimal_cache.json");
        let mut decimal_cache = match DecimalCache::load_from_file(cache_path) {
            Ok(cache) => {
                debug_log("DEBUG", "Decimal cache loaded successfully");
                cache
            }
            Err(e) => {
                pool_log("WARN", &format!("Failed to load decimal cache: {}", e));
                DecimalCache::new()
            }
        };

        // Get actual token decimals from cache or fetch from chain
        let mints_to_check = vec![pool_data.token_a.mint.clone(), pool_data.token_b.mint.clone()];
        debug_log("DEBUG", &format!("Checking decimals for {} tokens", mints_to_check.len()));

        let decimal_map = match
            fetch_or_cache_decimals(
                &self.rpc_client,
                &mints_to_check,
                &mut decimal_cache,
                cache_path
            ).await
        {
            Ok(map) => {
                debug_log("DEBUG", "Successfully fetched/cached token decimals");
                map
            }
            Err(e) => {
                pool_log("WARN", &format!("Failed to fetch decimals from cache: {}", e));
                debug_log("DEBUG", "Using fallback decimals from pool data");
                // Create fallback map using pool data decimals
                let mut fallback_map = HashMap::new();
                fallback_map.insert(pool_data.token_a.mint.clone(), pool_data.token_a.decimals);
                fallback_map.insert(pool_data.token_b.mint.clone(), pool_data.token_b.decimals);
                fallback_map
            }
        };

        let token_a_decimals = decimal_map
            .get(&pool_data.token_a.mint)
            .copied()
            .unwrap_or(pool_data.token_a.decimals);
        let token_b_decimals = decimal_map
            .get(&pool_data.token_b.mint)
            .copied()
            .unwrap_or(pool_data.token_b.decimals);

        // Calculate UI amounts (considering actual decimals from cache)
        let token_a_ui_amount =
            (pool_data.reserve_a.balance as f64) / (10_f64).powi(token_a_decimals as i32);
        let token_b_ui_amount =
            (pool_data.reserve_b.balance as f64) / (10_f64).powi(token_b_decimals as i32);

        log(
            LogTag::Pool,
            "DEBUG",
            &format!(
                "Token A UI amount: {} (cached decimals: {} vs pool decimals: {}) - {}",
                token_a_ui_amount,
                token_a_decimals,
                pool_data.token_a.decimals,
                if self.is_sol_mint(&pool_data.token_a.mint) {
                    "SOL"
                } else {
                    "TOKEN"
                }
            )
        );
        log(
            LogTag::Pool,
            "DEBUG",
            &format!(
                "Token B UI amount: {} (cached decimals: {} vs pool decimals: {}) - {}",
                token_b_ui_amount,
                token_b_decimals,
                pool_data.token_b.decimals,
                if self.is_sol_mint(&pool_data.token_b.mint) {
                    "SOL"
                } else {
                    "TOKEN"
                }
            )
        );

        // Smart price calculation: Always return SOL per Token regardless of internal ordering
        let (sol_amount, token_amount, sol_symbol, token_symbol) = if
            self.is_sol_mint(&pool_data.token_a.mint)
        {
            // Token A is SOL, Token B is the token
            (token_a_ui_amount, token_b_ui_amount, "SOL", &pool_data.token_b.mint[0..8])
        } else if self.is_sol_mint(&pool_data.token_b.mint) {
            // Token B is SOL, Token A is the token
            (token_b_ui_amount, token_a_ui_amount, "SOL", &pool_data.token_a.mint[0..8])
        } else {
            // Neither is SOL, use original order (Token A per Token B)
            (
                token_a_ui_amount,
                token_b_ui_amount,
                &pool_data.token_a.mint[0..8],
                &pool_data.token_b.mint[0..8],
            )
        };

        // For LaunchLab pools, we can use real_base and real_quote for more accurate pricing
        let price = if pool_data.pool_type == PoolType::RaydiumLaunchLab {
            if
                let PoolSpecificData::RaydiumLaunchLab { real_base, real_quote, .. } =
                    &pool_data.specific_data
            {
                // Use cached decimals for more accurate calculation
                let ui_real_base = (*real_base as f64) / (10_f64).powi(token_a_decimals as i32);
                let ui_real_quote = (*real_quote as f64) / (10_f64).powi(token_b_decimals as i32);

                log(
                    LogTag::Pool,
                    "DEBUG",
                    &format!(
                        "LaunchLab Real Values - Base: {} (raw: {}, decimals: {}), Quote: {} (raw: {}, decimals: {})",
                        ui_real_base,
                        *real_base,
                        token_a_decimals,
                        ui_real_quote,
                        *real_quote,
                        token_b_decimals
                    )
                );

                if ui_real_quote > 0.0 {
                    let adjusted_price = ui_real_base / ui_real_quote;
                    log(
                        LogTag::Pool,
                        "DEBUG",
                        &format!("LaunchLab price calculated using real values: {}", adjusted_price)
                    );
                    adjusted_price
                } else {
                    log(
                        LogTag::Pool,
                        "WARN",
                        "LaunchLab real_quote is zero, falling back to standard calculation"
                    );
                    if token_amount > 0.0 {
                        sol_amount / token_amount
                    } else {
                        0.0
                    }
                }
            } else {
                log(
                    LogTag::Pool,
                    "WARN",
                    "LaunchLab pool missing specific data, using standard calculation"
                );
                if token_amount > 0.0 {
                    sol_amount / token_amount
                } else {
                    0.0
                }
            }
        } else if pool_data.pool_type == PoolType::OrcaWhirlpool {
            if let PoolSpecificData::OrcaWhirlpool { sqrt_price, .. } = &pool_data.specific_data {
                let adjusted_price = self.calculate_price_from_sqrt_price(
                    *sqrt_price,
                    token_a_decimals,
                    token_b_decimals
                );
                log(
                    LogTag::Pool,
                    "DEBUG",
                    &format!("Orca Whirlpool price calculated from sqrt_price: {}", adjusted_price)
                );
                adjusted_price
            } else {
                log(
                    LogTag::Pool,
                    "WARN",
                    "Orca Whirlpool pool missing sqrt_price, using standard calculation"
                );
                if token_amount > 0.0 {
                    sol_amount / token_amount
                } else {
                    0.0
                }
            }
        } else if pool_data.pool_type == PoolType::MeteoraDammV2 {
            if let PoolSpecificData::MeteoraDammV2 { sqrt_price, .. } = &pool_data.specific_data {
                let adjusted_price = self.calculate_price_from_sqrt_price(
                    *sqrt_price,
                    token_a_decimals,
                    token_b_decimals
                );
                log(
                    LogTag::Pool,
                    "DEBUG",
                    &format!("Meteora DAMM v2 price calculated from sqrt_price: {}", adjusted_price)
                );
                adjusted_price
            } else {
                log(
                    LogTag::Pool,
                    "WARN",
                    "Meteora DAMM v2 pool missing sqrt_price, using standard calculation"
                );
                if token_amount > 0.0 {
                    sol_amount / token_amount
                } else {
                    0.0
                }
            }
        } else {
            // Standard AMM calculation for all other pool types
            if token_amount > 0.0 {
                sol_amount / token_amount
            } else {
                0.0
            }
        };

        log(
            LogTag::Pool,
            "DEBUG",
            &format!(
                "Price calculation result: {} {} per {} (using {} calculation)",
                price,
                sol_symbol,
                token_symbol,
                match pool_data.pool_type {
                    PoolType::RaydiumLaunchLab => "LaunchLab real values",
                    PoolType::OrcaWhirlpool => "Whirlpool sqrt_price",
                    PoolType::MeteoraDammV2 => "DAMM v2 sqrt_price",
                    _ => "Standard AMM",
                }
            )
        );

        Ok(price)
    }

    /// Calculate price from sqrt_price for concentrated liquidity pools
    fn calculate_price_from_sqrt_price(
        &self,
        sqrt_price: u128,
        token_a_decimals: u8,
        token_b_decimals: u8
    ) -> f64 {
        // sqrt_price is Q64.96 format (96 fractional bits)
        let q96 = (2_u128).pow(96);
        let price_ratio = (sqrt_price as f64) / (q96 as f64);
        let price_squared = price_ratio * price_ratio;

        // Adjust for token decimals
        let decimal_adjustment = (10_f64).powi(
            (token_a_decimals as i32) - (token_b_decimals as i32)
        );
        price_squared * decimal_adjustment
    }

    /// Get token account balance using RPC
    pub async fn get_token_balance(&self, token_account: &Pubkey) -> Result<u64> {
        let account_info = self.rpc_client.get_account(token_account)?;

        // Parse token account data to get balance
        // Token account balance is stored at offset 64 (8 bytes, little-endian)
        if account_info.data.len() < 72 {
            return Err(anyhow::anyhow!("Token account data too short"));
        }

        let balance_bytes: [u8; 8] = account_info.data[64..72].try_into()?;
        let balance = u64::from_le_bytes(balance_bytes);

        Ok(balance)
    }

    /// Get token decimals from mint account
    pub async fn get_token_decimals(&self, mint_address: &str) -> Result<u8> {
        let mint_pubkey = Pubkey::from_str(mint_address)?;
        let account_info = self.rpc_client.get_account(&mint_pubkey)?;

        // For SPL Token mints, decimals is stored at offset 44 (1 byte)
        if account_info.data.len() < 45 {
            return Err(anyhow::anyhow!("Mint account data too short"));
        }

        // Decimals is at offset 44 (1 byte)
        let decimals = account_info.data[44];

        Ok(decimals)
    }

    /// Get pool metadata (token symbols, names, etc.)
    pub async fn get_pool_metadata(
        &self,
        token_0_mint: &str,
        token_1_mint: &str
    ) -> Result<(String, String)> {
        // This would integrate with your existing token discovery system
        // For now, return mint addresses as symbols
        Ok((
            if token_0_mint == "So11111111111111111111111111111111111111112" {
                "SOL".to_string()
            } else {
                format!("{}..{}", &token_0_mint[..4], &token_0_mint[token_0_mint.len() - 4..])
            },
            format!("{}..{}", &token_1_mint[..4], &token_1_mint[token_1_mint.len() - 4..]),
        ))
    }

    /// Generate a comprehensive pool price report for a token
    pub async fn generate_pool_price_report(&self, token_mint: &str) -> Result<String> {
        let pool_results = self.get_token_pool_prices(token_mint).await?;

        if pool_results.is_empty() {
            return Ok(format!("❌ No pools found for token: {}", token_mint));
        }

        let mut report = String::new();
        report.push_str(&format!("\n🎯 Pool Price Analysis for Token: {}\n", &token_mint[0..8]));
        report.push_str("═══════════════════════════════════════════════════════════════\n");

        let mut sol_pairs = Vec::new();
        let mut other_pairs = Vec::new();

        for result in &pool_results {
            if result.is_sol_pair {
                sol_pairs.push(result);
            } else {
                other_pairs.push(result);
            }
        }

        if !sol_pairs.is_empty() {
            report.push_str("\n💰 SOL-Paired Pools:\n");
            report.push_str("─────────────────────\n");
            for (i, result) in sol_pairs.iter().enumerate() {
                let status = if result.calculation_successful { "✅" } else { "❌" };
                report.push_str(
                    &format!(
                        "{}. {} | {} | ${:.8} | ${:.2}K liq | {:.1}% diff\n",
                        i + 1,
                        status,
                        result.dex_id,
                        result.calculated_price,
                        result.liquidity_usd / 1000.0,
                        result.price_difference_percent
                    )
                );
            }
        }

        if !other_pairs.is_empty() {
            report.push_str("\n🔄 Other Pairs:\n");
            report.push_str("──────────────\n");
            for (i, result) in other_pairs.iter().enumerate() {
                let status = if result.calculation_successful { "✅" } else { "❌" };
                report.push_str(
                    &format!(
                        "{}. {} | {} | ${:.8} | ${:.2}K liq\n",
                        i + 1,
                        status,
                        result.dex_id,
                        result.calculated_price,
                        result.liquidity_usd / 1000.0
                    )
                );
            }
        }

        let successful_count = pool_results
            .iter()
            .filter(|r| r.calculation_successful)
            .count();
        report.push_str(
            &format!(
                "\n📊 Summary: {}/{} pools calculated successfully\n",
                successful_count,
                pool_results.len()
            )
        );

        Ok(report)
    }
}

// =============================================================================
// HELPER FUNCTIONS - Legacy compatibility functions
// =============================================================================

/// Decode Raydium AMM pool data from account - legacy compatibility function
pub fn decode_raydium_amm(
    rpc: &RpcClient,
    pool_pk: &Pubkey,
    acct: &Account
) -> Result<(u64, u64, Pubkey, Pubkey)> {
    if acct.data.len() < 264 {
        return Err(anyhow::anyhow!("AMM account too short"));
    }

    // Extract mint addresses from pool account
    let base_mint = Pubkey::new_from_array(acct.data[168..200].try_into()?);
    let quote_mint = Pubkey::new_from_array(acct.data[216..248].try_into()?);

    let base_vault = Pubkey::new_from_array(acct.data[200..232].try_into()?);
    let quote_vault = Pubkey::new_from_array(acct.data[232..264].try_into()?);

    let base = rpc.get_token_account_balance(&base_vault)?.amount.parse::<u64>().unwrap_or(0);
    let quote = rpc.get_token_account_balance(&quote_vault)?.amount.parse::<u64>().unwrap_or(0);

    use num_format::{ Locale, ToFormattedString };
    println!(
        "✅ Raydium AMM   → Base: {} | Quote: {}",
        base.to_formatted_string(&Locale::en),
        quote.to_formatted_string(&Locale::en)
    );
    Ok((base, quote, base_mint, quote_mint))
}

/// Decode Raydium AMM from account - wrapper function for legacy compatibility
pub fn decode_raydium_amm_from_account(
    rpc: &RpcClient,
    pool_pk: &Pubkey,
    acct: &Account
) -> Result<(u64, u64, Pubkey, Pubkey)> {
    decode_raydium_amm(rpc, pool_pk, acct)
}

/// Legacy compatibility struct and implementation
impl PoolPriceResult {
    fn pool_type_display(&self) -> String {
        match self.pool_type {
            PoolType::RaydiumCpmm => "CPMM".to_string(),
            PoolType::RaydiumAmm => "AMM".to_string(),
            PoolType::MeteoraDlmm => "DLMM".to_string(),
            PoolType::MeteoraDammV2 => "DAMM v2".to_string(),
            PoolType::Orca => "Orca".to_string(),
            PoolType::OrcaWhirlpool => "Whirlpool".to_string(),
            PoolType::Phoenix => "Phoenix".to_string(),
            PoolType::RaydiumLaunchLab => "LaunchLab".to_string(),
            PoolType::PumpfunAmm => "Pump.fun AMM".to_string(),
            PoolType::PumpfunBondingCurve => "Pump.fun Bonding Curve".to_string(),
            PoolType::Unknown => "Unknown".to_string(),
        }
    }
}

// Import required types for legacy functions
use solana_sdk::account::Account;
