<div class="services-container">
  <div class="services-toolbar">
    <div class="toolbar-left">
      <input
        id="serviceSearch"
        class="input"
        type="text"
        placeholder="Search services..."
      />
      <select id="statusFilter" class="input">
        <option value="all">All statuses</option>
        <option value="healthy">Healthy</option>
        <option value="degraded">Degraded</option>
        <option value="starting">Starting</option>
        <option value="unhealthy">Unhealthy</option>
      </select>
      <label class="toggle"
        ><input type="checkbox" id="enabledOnly" /> Enabled only</label
      >
    </div>
    <div class="toolbar-right">
      <div class="chip">Total <span id="totalServices">-</span></div>
      <div class="chip chip-success">
        Healthy <span id="healthyServices">-</span>
      </div>
      <div class="chip chip-warn">
        Starting <span id="startingServices">-</span>
      </div>
      <div class="chip chip-error">
        Unhealthy <span id="unhealthyServices">-</span>
      </div>
      <div class="chip" title="Process-wide CPU">
        CPU <span id="processCpu">-</span>
      </div>
      <div class="chip" title="Process-wide Memory">
        Mem <span id="processMemory">-</span>
      </div>
      <button class="btn btn-primary" onclick="refreshServices()">
        üîÑ Refresh
      </button>
    </div>
  </div>

  <div class="table-scroll">
    <table class="table services-table" id="servicesTable">
      <thead>
        <tr>
          <th data-sort="name">Name</th>
          <th data-sort="health">Health</th>
          <th data-sort="priority">Priority</th>
          <th data-sort="enabled">Enabled</th>
          <th data-sort="uptime">Uptime</th>
          <th data-sort="activity" title="Poll time ratio (busyness)">
            Activity
          </th>
          <th data-sort="poll">Avg Poll</th>
          <th data-sort="pps">Polls/s</th>
          <th data-sort="tasks">Tasks</th>
          <th data-sort="ops">Ops/s</th>
          <th data-sort="errors">Errors</th>
          <th>Dependencies</th>
        </tr>
      </thead>
      <tbody id="servicesTableBody">
        <tr>
          <td
            colspan="12"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading services...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<style>
  .services-container {
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
  }
  .services-toolbar {
    display: flex;
    gap: 1rem;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }
  .toolbar-left,
  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .input {
    background: var(--bg-card);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 0.4rem 0.6rem;
  }
  .toggle {
    color: var(--text-muted);
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }
  .chip {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 999px;
    padding: 0.25rem 0.6rem;
    font-size: 0.85rem;
  }
  .chip-success {
    background: #064e3b;
    color: #34d399;
    border-color: #065f46;
  }
  .chip-warn {
    background: #4a3000;
    color: #fbbf24;
    border-color: #92400e;
  }
  .chip-error {
    background: #4c0519;
    color: #fb7185;
    border-color: #7f1d1d;
  }

  /* Activity bar */
  .activity-cell {
    min-width: 140px;
  }
  .activity-track {
    background: #1f2937;
    border-radius: 6px;
    height: 8px;
    width: 100%;
    overflow: hidden;
  }
  .activity-fill {
    height: 100%;
    border-radius: 6px;
    background: #10b981;
    transition: width 0.25s ease;
  }
  .activity-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 4px;
  }

  /* Sortable headers */
  .services-table th[data-sort] {
    cursor: pointer;
    user-select: none;
  }
  .services-table th[data-sort].asc::after {
    content: " \25B2";
    color: var(--text-muted);
  }
  .services-table th[data-sort].desc::after {
    content: " \25BC";
    color: var(--text-muted);
  }

  /* Dependencies */
  .dependency-badge {
    font-size: 0.75rem;
    background: var(--bg-secondary);
    padding: 0.25rem 0.6rem;
    border-radius: 12px;
    display: inline-block;
    margin: 2px;
  }

  /* Health badges reuse existing theme */
  .badge.success {
    background: var(--badge-online);
    color: #fff;
  }
  .badge.warning {
    background: var(--badge-loading);
    color: #fff;
  }
  .badge.error {
    background: var(--badge-error);
    color: #fff;
  }
  .badge.secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
  }
</style>

<script>
  // Prevent multiple script instances from interfering
  (function () {
    // Create a new controller instance on every page visit
    const servicePageController = {
      servicesData: null,
      sortKey: "priority",
      sortDir: "asc",
      servicesFallbackInterval: null,
      activeFetchController: null,
      activeFetchTimeout: null,

      clearActiveFetch: function (reason, shouldAbort = true) {
        if (this.activeFetchTimeout) {
          clearTimeout(this.activeFetchTimeout);
          this.activeFetchTimeout = null;
        }
        if (this.activeFetchController) {
          if (shouldAbort) {
            try {
              this.activeFetchController.abort();
            } catch (_) {}
          }
          this.activeFetchController = null;
        }
        if (reason) {
          console.debug(
            "[Services] Cleared active fetch:",
            reason,
            "abort:",
            shouldAbort
          );
        }
      },

      loadServices: async function (options = {}) {
        const { showLoader = false } = options;

        // Cancel any existing fetch before starting
        this.clearActiveFetch("new-request");

        const controller = new AbortController();
        this.activeFetchController = controller;

        this.activeFetchTimeout = setTimeout(() => {
          console.warn("[Services] ‚è∞ Fetch timeout after 5s");
          controller.abort();
        }, 5000);

        try {
          console.log("[Services] üîÑ Starting services fetch", {
            showLoader,
            timestamp: new Date().toISOString(),
          });

          if (showLoader) {
            this.setServicesLoading();
          }

          const response = await fetch("/api/services/overview", {
            headers: { "X-Requested-With": "fetch" },
            signal: controller.signal,
            cache: "no-cache",
          });

          if (this.activeFetchTimeout) {
            clearTimeout(this.activeFetchTimeout);
            this.activeFetchTimeout = null;
          }

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          this.clearActiveFetch("success", false);

          console.log("[Services] ‚úÖ Data loaded", {
            serviceCount: data?.services?.length || 0,
          });

          this.handleServicesSnapshot(data);
        } catch (error) {
          this.clearActiveFetch("error", false);

          if (error?.name === "AbortError") {
            console.debug("[Services] Fetch aborted");
            return;
          }

          console.error("[Services] ‚ùå Failed to load services:", error);
          this.showServicesError(
            "Failed to load services: " + (error?.message || "Network error")
          );
        }
      },

      setServicesLoading: function () {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
                        <tr>
                            <td colspan="12" style="text-align:center; padding: 20px; color: var(--text-muted);">
                                Loading services...
                            </td>
                        </tr>
                    `;
      },

      showServicesError: function (message) {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
                        <tr>
                            <td colspan="12" style="text-align:center; padding: 20px; color: #ef4444;">
                                ${message}
                            </td>
                        </tr>
                    `;
      },

      handleServicesSnapshot: function (snapshot) {
        if (!snapshot || !Array.isArray(snapshot.services)) {
          this.showServicesError("No services available");
          return;
        }

        this.servicesData = snapshot;
        console.log("[Services] ‚úÖ Snapshot applied", {
          serviceCount: snapshot.services.length,
        });

        this.bindToolbarEventsOnce();
        this.bindSortHandlersOnce();
        this.renderServicesTable();
      },

      startServicesFallback: function (intervalMs = 30000) {
        this.stopServicesFallback();
        const self = this;
        this.servicesFallbackInterval = setInterval(() => {
          console.log("[Services] üîÅ Polling services via fallback HTTP");
          self.loadServices({ showLoader: false });
        }, intervalMs);
        console.debug("[Services] Fallback polling enabled");
      },

      stopServicesFallback: function () {
        if (this.servicesFallbackInterval) {
          clearInterval(this.servicesFallbackInterval);
          this.servicesFallbackInterval = null;
          console.debug("[Services] Fallback polling stopped");
        }
      },

      currentFilters: function () {
        const q = (
          document.getElementById("serviceSearch")?.value || ""
        ).toLowerCase();
        const status = document.getElementById("statusFilter")?.value || "all";
        const enabledOnly =
          document.getElementById("enabledOnly")?.checked || false;
        return { q, status, enabledOnly };
      },

      filteredAndSortedServices: function () {
        if (!this.servicesData) return [];
        const { q, status, enabledOnly } = this.currentFilters();
        let arr = this.servicesData.services.slice();

        // Filter
        arr = arr.filter((s) => {
          const matchesText = !q || s.name.toLowerCase().includes(q);
          const matchesStatus = status === "all" || s.health?.status === status;
          const matchesEnabled = !enabledOnly || s.enabled;
          return matchesText && matchesStatus && matchesEnabled;
        });

        // Sort
        const getKey = (s) => {
          const m = s.metrics || {};
          switch (this.sortKey) {
            case "name":
              return s.name || "";
            case "health":
              return this.healthRank(s.health?.status);
            case "priority":
              return s.priority || 0;
            case "enabled":
              return s.enabled ? 1 : 0;
            case "uptime":
              return s.uptime_seconds || 0;
            case "activity": {
              const total =
                (m.total_poll_duration_ns || 0) +
                (m.total_idle_duration_ns || 0);
              return total > 0 ? (m.total_poll_duration_ns || 0) / total : 0;
            }
            case "poll":
              return m.mean_poll_duration_ns || 0;
            case "pps":
              return s.uptime_seconds > 0
                ? (m.total_polls || 0) / s.uptime_seconds
                : 0;
            case "tasks":
              return m.task_count || 0;
            case "ops":
              return m.operations_per_second || 0;
            case "errors":
              return m.errors_total || 0;
            default:
              return s.priority || 0;
          }
        };

        const sortDir = this.sortDir;
        arr.sort((a, b) => {
          const ka = getKey(a);
          const kb = getKey(b);
          if (ka < kb) return sortDir === "asc" ? -1 : 1;
          if (ka > kb) return sortDir === "asc" ? 1 : -1;
          return 0;
        });

        return arr;
      },

      renderServicesTable: function () {
        if (!this.servicesData) return;

        // Verify the DOM still exists before rendering
        if (!document.getElementById("servicesTableBody")) {
          console.debug("[Services] DOM not ready for rendering");
          return;
        }

        // Update summary chips
        document.getElementById("totalServices").textContent =
          this.servicesData.summary.total_services;
        document.getElementById("healthyServices").textContent =
          this.servicesData.summary.healthy_services;
        document.getElementById("startingServices").textContent =
          this.servicesData.summary.starting_services;
        const unhealthyTotal =
          (this.servicesData.summary.unhealthy_services || 0) +
          (this.servicesData.summary.degraded_services || 0);
        document.getElementById("unhealthyServices").textContent =
          unhealthyTotal;

        // Process-wide metrics
        if (
          this.servicesData.services &&
          this.servicesData.services.length > 0
        ) {
          const m0 = this.servicesData.services[0].metrics || {};
          const cpu = Number.isFinite(m0.process_cpu_percent)
            ? m0.process_cpu_percent
            : 0;
          document.getElementById("processCpu").textContent = `${cpu.toFixed(
            1
          )}%`;
          document.getElementById("processMemory").textContent =
            Utils.formatBytes(m0.process_memory_bytes || 0);
        }

        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;

        const filtered = this.filteredAndSortedServices();
        const rows = filtered
          .map((service) => {
            const m = service.metrics || {};
            const deps =
              service.dependencies && service.dependencies.length
                ? service.dependencies
                    .map(
                      (dep) => `<span class="dependency-badge">${dep}</span>`
                    )
                    .join(" ")
                : '<span class="detail-value">None</span>';

            const total =
              (m.total_poll_duration_ns || 0) + (m.total_idle_duration_ns || 0);
            const activity =
              total > 0 ? ((m.total_poll_duration_ns || 0) / total) * 100 : 0;
            const activityColor =
              activity > 80
                ? "#10b981"
                : activity > 50
                ? "#3b82f6"
                : activity > 20
                ? "#f59e0b"
                : activity > 5
                ? "#6b7280"
                : "#9ca3af";
            const avgPoll = Utils.formatDuration(m.mean_poll_duration_ns || 0);
            const pps =
              service.uptime_seconds > 0
                ? ((m.total_polls || 0) / service.uptime_seconds).toFixed(2)
                : "0.00";

            const taskInfo =
              m.task_count > 0
                ? `${m.task_count} tasks\nPoll: ${Utils.formatDuration(
                    m.mean_poll_duration_ns
                  )}\nIdle: ${Utils.formatDuration(
                    m.mean_idle_duration_ns
                  )}\nTotal Polls: ${m.total_polls || 0}`
                : "No instrumented tasks";

            return `
                            <tr>
                                <td style="font-weight:600;">${
                                  service.name
                                }</td>
                                <td><span class="badge ${this.getHealthBadgeClass(
                                  service.health
                                )}">${this.getHealthStatus(
              service.health
            )}</span></td>
                                <td>${service.priority}</td>
                                <td>${service.enabled ? "‚úÖ" : "‚ùå"}</td>
                                <td>${Utils.formatUptime(
                                  service.uptime_seconds,
                                  { style: "compact" }
                                )}</td>
                                <td class="activity-cell" title="${activity.toFixed(
                                  1
                                )}% busy">
                                    <div class="activity-track"><div class="activity-fill" style="width:${activity.toFixed(
                                      1
                                    )}%; background:${activityColor}"></div></div>
                                    <div class="activity-meta"><span>${activity.toFixed(
                                      1
                                    )}%</span><span>${
              m.total_polls || 0
            } polls</span></div>
                                </td>
                                <td title="Average duration per poll">${avgPoll}</td>
                                <td title="Polls per second">${pps}</td>
                                <td title="${taskInfo}">${
              m.task_count || 0
            }</td>
                                <td title="Operations per second">${(
                                  m.operations_per_second || 0
                                ).toFixed(2)}</td>
                                <td title="Total errors">${
                                  m.errors_total || 0
                                }</td>
                                <td>${deps}</td>
                            </tr>`;
          })
          .join("");

        tbody.innerHTML =
          rows ||
          `
                        <tr>
                            <td colspan="12" style="text-align:center; padding: 20px; color: var(--text-muted);">No services</td>
                        </tr>`;
      },

      bindToolbarEventsOnce: function () {
        if (this.bindToolbarEventsOnce._bound) return;
        this.bindToolbarEventsOnce._bound = true;

        const self = this;
        document
          .getElementById("serviceSearch")
          ?.addEventListener("input", () => self.renderServicesTable());
        document
          .getElementById("statusFilter")
          ?.addEventListener("change", () => self.renderServicesTable());
        document
          .getElementById("enabledOnly")
          ?.addEventListener("change", () => self.renderServicesTable());
      },

      bindSortHandlersOnce: function () {
        if (this.bindSortHandlersOnce._bound) return;
        this.bindSortHandlersOnce._bound = true;

        const self = this;
        document
          .querySelectorAll("#servicesTable thead th[data-sort]")
          .forEach((th) => {
            th.addEventListener("click", () => {
              const key = th.getAttribute("data-sort");
              if (!key) return;
              if (self.sortKey === key) {
                self.sortDir = self.sortDir === "asc" ? "desc" : "asc";
              } else {
                self.sortKey = key;
                self.sortDir = "asc";
              }
              document
                .querySelectorAll("#servicesTable thead th[data-sort]")
                .forEach((h) => {
                  h.classList.remove("asc", "desc");
                });
              th.classList.add(self.sortDir);
              self.renderServicesTable();
            });
          });
      },

      healthRank: function (status) {
        switch (status) {
          case "healthy":
            return 3;
          case "degraded":
            return 2;
          case "starting":
            return 1;
          case "unhealthy":
            return 0;
          default:
            return -1;
        }
      },

      getHealthStatus: function (health) {
        if (health?.status === "healthy") return "‚úÖ Healthy";
        if (health?.status === "starting") return "‚è≥ Starting";
        if (health?.status === "degraded") return "‚ö†Ô∏è Degraded";
        if (health?.status === "unhealthy") return "‚ùå Unhealthy";
        return "‚è∏Ô∏è " + (health?.status || "unknown");
      },

      getHealthBadgeClass: function (health) {
        if (health?.status === "healthy") return "success";
        if (health?.status === "starting") return "warning";
        if (health?.status === "degraded") return "warning";
        if (health?.status === "unhealthy") return "error";
        return "secondary";
      },

      initialize: function () {
        console.log("[Services] üöÄ Initializing page controller");

        // Clean up any previous state
        this.clearActiveFetch("init");
        this.stopServicesFallback();

        // Start fresh
        this.loadServices({ showLoader: true });
      },
    };

    window.PageRealtime = window.PageRealtime || {};
    window.PageRealtime.services = {
      channels: {
        services: (snapshot) => {
          servicePageController.stopServicesFallback();
          servicePageController.handleServicesSnapshot(snapshot);
        },
        _disconnected: () => {
          console.warn(
            "[Services] WebSocket disconnected, enabling fallback polling"
          );
          servicePageController.startServicesFallback(30000);
        },
        _failed: () => {
          console.error(
            "[Services] WebSocket error, keeping fallback polling active"
          );
          servicePageController.startServicesFallback(30000);
        },
        _connected: () => {
          console.info(
            "[Services] WebSocket connected, stopping fallback polling"
          );
          servicePageController.stopServicesFallback();
        },
      },
      onInitial(status) {
        if (status === "connected") {
          servicePageController.stopServicesFallback();
        } else {
          servicePageController.startServicesFallback(30000);
        }
      },
      onUnavailable() {
        console.warn("[Services] WebSocket unavailable, using HTTP polling");
        servicePageController.startServicesFallback(30000);
      },
      onExit() {
        servicePageController.stopServicesFallback();
        servicePageController.clearActiveFetch("page-exit");
      },
    };

    // Set the global refresh handler
    window.refreshServices = function () {
      console.info("[Services] Manual refresh requested");
      servicePageController.loadServices({ showLoader: true });
    };

    // Global init function for Router
    window.initServicesPage = function () {
      // Always create a new controller on page init
      console.log("[Services] üöÄ Initializing page");
      servicePageController.initialize();
    };

    // Initialize immediately if not in SPA mode
    if (!window.Router) {
      servicePageController.initialize();
    }
  })();
</script>
