<style>
  .services-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .services-toolbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .services-toolbar .toolbar-left,
  .services-toolbar .toolbar-right {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.75rem;
  }

  .services-toolbar .toolbar-left .input {
    min-width: 180px;
  }

  .services-toolbar .chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.35rem 0.65rem;
    border-radius: 999px;
    font-size: 0.85rem;
    font-weight: 600;
  }

  .services-toolbar .chip span {
    font-weight: 700;
  }

  .services-toolbar .chip-success {
    background: rgba(16, 185, 129, 0.15);
    color: #10b981;
  }

  .services-toolbar .chip-warn {
    background: rgba(245, 158, 11, 0.15);
    color: #f59e0b;
  }

  .services-toolbar .chip-error {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
  }

  .table-scroll {
    border-radius: 12px;
    border: 1px solid var(--border-color);
    overflow: hidden;
  }

  .services-table {
    width: 100%;
    border-collapse: collapse;
  }

  .services-table th,
  .services-table td {
    padding: 0.65rem 0.75rem;
    text-align: left;
    vertical-align: middle;
  }

  .services-table tbody tr:nth-child(even) {
    background: var(--bg-secondary);
  }

  .services-table th[data-sort] {
    cursor: pointer;
    user-select: none;
    position: relative;
    white-space: nowrap;
  }

  .services-table th[data-sort].asc::after {
    content: " ‚ñ≤";
    color: var(--text-muted);
  }

  .services-table th[data-sort].desc::after {
    content: " ‚ñº";
    color: var(--text-muted);
  }

  .activity-cell {
    min-width: 170px;
  }

  .activity-track {
    width: 100%;
    height: 6px;
    border-radius: 999px;
    overflow: hidden;
    background: var(--bg-secondary);
    margin-bottom: 4px;
  }

  .activity-fill {
    height: 100%;
    border-radius: 999px;
  }

  .activity-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-secondary);
  }

  .dependency-badge {
    font-size: 0.75rem;
    background: var(--bg-secondary);
    padding: 0.25rem 0.6rem;
    border-radius: 12px;
    display: inline-block;
    margin: 2px;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    padding: 0.15rem 0.5rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.8rem;
  }

  .badge.success {
    background: var(--badge-online);
    color: #fff;
  }

  .badge.warning {
    background: var(--badge-loading);
    color: #fff;
  }

  .badge.error {
    background: var(--badge-error);
    color: #fff;
  }

  .badge.secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
  }

  @media (max-width: 900px) {
    .services-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }

    .services-toolbar .toolbar-right {
      width: 100%;
      justify-content: flex-start;
    }
  }
</style>
<div class="services-container">
  <div class="services-toolbar">
    <div class="toolbar-left">
      <input
        id="serviceSearch"
        class="input"
        type="text"
        placeholder="Search services..."
      />
      <select id="statusFilter" class="input">
        <option value="all">All statuses</option>
        <option value="healthy">Healthy</option>
        <option value="degraded">Degraded</option>
        <option value="starting">Starting</option>
        <option value="unhealthy">Unhealthy</option>
      </select>
      <label class="toggle">
        <input type="checkbox" id="enabledOnly" />
        Enabled only
      </label>
    </div>
    <div class="toolbar-right">
      <div class="chip">Total <span id="totalServices">-</span></div>
      <div class="chip chip-success">
        Healthy <span id="healthyServices">-</span>
      </div>
      <div class="chip chip-warn">
        Starting <span id="startingServices">-</span>
      </div>
      <div class="chip chip-error">
        Unhealthy <span id="unhealthyServices">-</span>
      </div>
      <div class="chip" title="Process-wide CPU">
        CPU <span id="processCpu">-</span>
      </div>
      <div class="chip" title="Process-wide Memory">
        Mem <span id="processMemory">-</span>
      </div>
      <button class="btn btn-primary" onclick="refreshServices()">
        üîÑ Refresh
      </button>
    </div>
  </div>

  <div class="table-scroll">
    <table class="table services-table" id="servicesTable">
      <thead>
        <tr>
          <th data-sort="name">Name</th>
          <th data-sort="health">Health</th>
          <th data-sort="priority">Priority</th>
          <th data-sort="enabled">Enabled</th>
          <th data-sort="uptime">Uptime</th>
          <th data-sort="activity" title="Poll time ratio (busyness)">
            Activity
          </th>
          <th data-sort="lastCycle">Last Cycle</th>
          <th data-sort="avgCycle">Avg Cycle</th>
          <th data-sort="avgPoll">Avg Poll</th>
          <th data-sort="cycleRate">Cycles/s</th>
          <th data-sort="tasks">Tasks</th>
          <th data-sort="ops">Ops/s</th>
          <th data-sort="errors">Errors</th>
          <th>Dependencies</th>
        </tr>
      </thead>
      <tbody id="servicesTableBody">
        <tr>
          <td
            colspan="14"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading services...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
  (function () {
    const controller = {
      servicesData: null,
      sortKey: "priority",
      sortDir: "asc",
      hasInitialSnapshot: false,
      toolbarBound: false,
      sortBound: false,
      snapshotState: {
        inProgress: false,
        started: false,
        requestId: null,
        context: null,
        totalAvailable: 0,
        timeoutHandle: null,
        lastTimerReason: null,
      },
      SNAPSHOT_TIMEOUT_MS: 10000,

      initialize() {
        console.log("[Services] Initializing controller");
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.setLoading("Waiting for realtime data...");
        this.bindToolbarEventsOnce();
        this.bindSortHandlersOnce();
        // Note: Do NOT request snapshot here - it will be requested by onEnter after Realtime.activate()
      },

      reset() {
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.snapshotState.inProgress = false;
        this.snapshotState.started = false;
        this.snapshotState.requestId = null;
        this.snapshotState.context = null;
        this.snapshotState.totalAvailable = 0;
        this.clearSnapshotTimer();
      },

      clearSnapshotTimer() {
        if (this.snapshotState.timeoutHandle) {
          clearTimeout(this.snapshotState.timeoutHandle);
          this.snapshotState.timeoutHandle = null;
        }
        this.snapshotState.lastTimerReason = null;
      },

      scheduleSnapshotTimer(reason) {
        this.clearSnapshotTimer();

        if (
          !Number.isFinite(this.SNAPSHOT_TIMEOUT_MS) ||
          this.SNAPSHOT_TIMEOUT_MS <= 0
        ) {
          return;
        }

        this.snapshotState.lastTimerReason = reason || null;
        this.snapshotState.timeoutHandle = setTimeout(() => {
          this.snapshotState.timeoutHandle = null;
          if (!this.snapshotState.inProgress) {
            return;
          }

          console.warn(
            `[Services] Snapshot timeout (${
              this.snapshotState.lastTimerReason || "unknown"
            })`
          );

          if (this.servicesData) {
            this.handleSnapshotCompletion({
              topic: "services.metrics",
              context: Object.assign(
                {
                  request_id: this.snapshotState.requestId,
                  total_services: this.snapshotState.totalAvailable,
                },
                this.snapshotState.context || {}
              ),
            });
          } else {
            this.setLoading("Snapshot timed out ‚Äî retrying...");
            this.requestSnapshot("timeout-retry");
          }
        }, this.SNAPSHOT_TIMEOUT_MS);
      },

      setLoading(message = "Loading services...") {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
              ${message}
            </td>
          </tr>
        `;
      },

      showError(message) {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: #ef4444;">
              ${message}
            </td>
          </tr>
        `;
      },

      updateSummary(summary) {
        const total = document.getElementById("totalServices");
        const healthy = document.getElementById("healthyServices");
        const starting = document.getElementById("startingServices");
        const unhealthy = document.getElementById("unhealthyServices");
        if (total) {
          total.textContent =
            summary?.total_services != null ? summary.total_services : "-";
        }
        if (healthy) {
          healthy.textContent =
            summary?.healthy_services != null ? summary.healthy_services : "-";
        }
        if (starting) {
          starting.textContent =
            summary?.starting_services != null
              ? summary.starting_services
              : "-";
        }
        if (unhealthy) {
          const degraded = summary?.degraded_services || 0;
          const unhealthyCount = summary?.unhealthy_services || 0;
          unhealthy.textContent =
            summary && summary.unhealthy_services != null
              ? unhealthyCount + degraded
              : "-";
        }
      },

      updateProcessMetrics(firstService) {
        const cpuEl = document.getElementById("processCpu");
        const memEl = document.getElementById("processMemory");
        const metrics = firstService?.metrics || {};
        if (cpuEl) {
          const cpu = Number.isFinite(metrics.process_cpu_percent)
            ? metrics.process_cpu_percent.toFixed(1) + "%"
            : "-";
          cpuEl.textContent = cpu;
        }
        if (memEl) {
          const mem = metrics.process_memory_bytes
            ? Utils.formatBytes(metrics.process_memory_bytes)
            : "-";
          memEl.textContent = mem;
        }
      },

      currentFilters() {
        const q = (
          document.getElementById("serviceSearch")?.value || ""
        ).toLowerCase();
        const status = document.getElementById("statusFilter")?.value || "all";
        const enabledOnly =
          document.getElementById("enabledOnly")?.checked || false;
        return { q, status, enabledOnly };
      },

      filteredAndSortedServices() {
        if (!this.servicesData) return [];
        const { q, status, enabledOnly } = this.currentFilters();
        const items = Array.isArray(this.servicesData.services)
          ? this.servicesData.services.slice()
          : [];

        const filtered = items.filter((service) => {
          const name = (service.name || "").toLowerCase();
          const matchesText = !q || name.includes(q);
          const matchesStatus =
            status === "all" || service.health?.status === status;
          const matchesEnabled = !enabledOnly || !!service.enabled;
          return matchesText && matchesStatus && matchesEnabled;
        });

        const sortKey = this.sortKey;
        const sortDir = this.sortDir === "asc" ? 1 : -1;

        const getKey = (service) => {
          const metrics = service.metrics || {};
          switch (sortKey) {
            case "name":
              return service.name || "";
            case "health":
              return this.healthRank(service.health?.status);
            case "priority":
              return service.priority || 0;
            case "enabled":
              return service.enabled ? 1 : 0;
            case "uptime":
              return service.uptime_seconds || 0;
            case "activity": {
              const total =
                (metrics.total_poll_duration_ns || 0) +
                (metrics.total_idle_duration_ns || 0);
              return total > 0
                ? (metrics.total_poll_duration_ns || 0) / total
                : 0;
            }
            case "lastCycle":
              return metrics.last_cycle_duration_ns || 0;
            case "avgCycle":
              return metrics.avg_cycle_duration_ns || 0;
            case "avgPoll":
              return metrics.mean_poll_duration_ns || 0;
            case "cycleRate":
              return metrics.cycles_per_second || 0;
            case "tasks":
              return metrics.task_count || 0;
            case "ops":
              return metrics.operations_per_second || 0;
            case "errors":
              return metrics.errors_total || 0;
            default:
              return service.priority || 0;
          }
        };

        filtered.sort((a, b) => {
          const aKey = getKey(a);
          const bKey = getKey(b);
          if (aKey < bKey) return -1 * sortDir;
          if (aKey > bKey) return 1 * sortDir;
          return 0;
        });

        return filtered;
      },

      renderServicesTable() {
        if (!this.servicesData) return;

        this.updateSummary(this.servicesData.summary);
        if (Array.isArray(this.servicesData.services)) {
          this.updateProcessMetrics(this.servicesData.services[0]);
        }

        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;

        const rows = this.filteredAndSortedServices()
          .map((service) => this.renderRow(service))
          .join("");

        if (!rows) {
          tbody.innerHTML = `
            <tr>
              <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
                No services match your filters
              </td>
            </tr>
          `;
        } else {
          tbody.innerHTML = rows;
        }
      },

      renderRow(service) {
        const metrics = service.metrics || {};
        const dependencies = Array.isArray(service.dependencies)
          ? service.dependencies.map(
              (dep) => `<span class="dependency-badge">${dep}</span>`
            )
          : [];

        const total =
          (metrics.total_poll_duration_ns || 0) +
          (metrics.total_idle_duration_ns || 0);
        const activity =
          total > 0 ? ((metrics.total_poll_duration_ns || 0) / total) * 100 : 0;
        const activityColor =
          activity > 80
            ? "#10b981"
            : activity > 50
            ? "#3b82f6"
            : activity > 20
            ? "#f59e0b"
            : activity > 5
            ? "#6b7280"
            : "#9ca3af";

        const lastCycle = Utils.formatDuration(
          metrics.last_cycle_duration_ns || 0
        );
        const avgCycle = Utils.formatDuration(
          metrics.avg_cycle_duration_ns || 0
        );
        const avgPoll = Utils.formatDuration(
          metrics.mean_poll_duration_ns || 0
        );
        const cycleRate = Number.isFinite(metrics.cycles_per_second)
          ? metrics.cycles_per_second.toFixed(2)
          : "0.00";

        const taskInfo =
          metrics.task_count > 0
            ? `${
                metrics.task_count
              } tasks\nLast cycle: ${lastCycle}\nAvg cycle: ${avgCycle}\nPoll: ${Utils.formatDuration(
                metrics.mean_poll_duration_ns
              )}\nIdle: ${Utils.formatDuration(
                metrics.mean_idle_duration_ns
              )}\nTotal Polls: ${metrics.total_polls || 0}`
            : "No instrumented tasks";

        return `
          <tr>
            <td style="font-weight:600;">${service.name || "-"}</td>
            <td>
              <span class="badge ${this.getHealthBadgeClass(service.health)}">
                ${this.getHealthStatus(service.health)}
              </span>
            </td>
            <td>${service.priority ?? "-"}</td>
            <td>${service.enabled ? "‚úÖ" : "‚ùå"}</td>
            <td>${Utils.formatUptime(service.uptime_seconds, {
              style: "compact",
            })}</td>
            <td class="activity-cell" title="${activity.toFixed(1)}% busy">
              <div class="activity-track">
                <div class="activity-fill" style="width:${activity.toFixed(
                  1
                )}%; background:${activityColor};"></div>
              </div>
              <div class="activity-meta">
                <span>${activity.toFixed(1)}%</span>
                <span>${metrics.total_polls || 0} polls</span>
              </div>
            </td>
            <td title="Last full loop duration">${lastCycle}</td>
            <td title="Average full loop duration">${avgCycle}</td>
            <td title="Average duration per poll">${avgPoll}</td>
            <td title="Cycles per second">${cycleRate}</td>
            <td title="${taskInfo}">${metrics.task_count || 0}</td>
            <td title="Operations per second">${(
              metrics.operations_per_second || 0
            ).toFixed(2)}</td>
            <td title="Total errors">${metrics.errors_total || 0}</td>
            <td>${
              dependencies.length > 0
                ? dependencies.join(" ")
                : '<span class="detail-value">None</span>'
            }</td>
          </tr>
        `;
      },

      bindToolbarEventsOnce() {
        if (this.toolbarBound) return;
        const self = this;
        const search = document.getElementById("serviceSearch");
        if (search) {
          search.addEventListener("input", () => self.renderServicesTable());
        }
        const status = document.getElementById("statusFilter");
        if (status) {
          status.addEventListener("change", () => self.renderServicesTable());
        }
        const enabledOnly = document.getElementById("enabledOnly");
        if (enabledOnly) {
          enabledOnly.addEventListener("change", () =>
            self.renderServicesTable()
          );
        }
        this.toolbarBound = true;
      },

      bindSortHandlersOnce() {
        if (this.sortBound) return;
        const self = this;
        document
          .querySelectorAll("#servicesTable thead th[data-sort]")
          .forEach((th) => {
            th.addEventListener("click", () => {
              const key = th.getAttribute("data-sort");
              if (!key) return;
              if (self.sortKey === key) {
                self.sortDir = self.sortDir === "asc" ? "desc" : "asc";
              } else {
                self.sortKey = key;
                self.sortDir = "asc";
              }
              document
                .querySelectorAll("#servicesTable thead th[data-sort]")
                .forEach((header) => {
                  header.classList.remove("asc", "desc");
                });
              th.classList.add(self.sortDir);
              self.renderServicesTable();
            });
          });
        this.sortBound = true;
      },

      healthRank(status) {
        switch (status) {
          case "healthy":
            return 3;
          case "degraded":
            return 2;
          case "starting":
            return 1;
          case "unhealthy":
            return 0;
          default:
            return -1;
        }
      },

      getHealthStatus(health) {
        if (health?.status === "healthy") return "‚úÖ Healthy";
        if (health?.status === "starting") return "‚è≥ Starting";
        if (health?.status === "degraded") return "‚ö†Ô∏è Degraded";
        if (health?.status === "unhealthy") return "‚ùå Unhealthy";
        return `‚è∏Ô∏è ${health?.status || "unknown"}`;
      },

      getHealthBadgeClass(health) {
        if (health?.status === "healthy") return "success";
        if (health?.status === "starting") return "warning";
        if (health?.status === "degraded") return "warning";
        if (health?.status === "unhealthy") return "error";
        return "secondary";
      },

      handleServicesSnapshot(snapshot) {
        if (!snapshot || !Array.isArray(snapshot.services)) {
          console.warn("[Services] Invalid snapshot received", {
            hasServices: Array.isArray(snapshot?.services),
            keys: snapshot ? Object.keys(snapshot) : [],
          });
          this.showError("No services available");
          return;
        }

        this.hasInitialSnapshot = true;
        this.servicesData = snapshot;
        this.snapshotState.totalAvailable = snapshot.services.length;
        console.log("[Services] Snapshot applied", {
          serviceCount: snapshot.services.length,
          unhealthy: snapshot?.summary?.unhealthy_services,
        });
        this.renderServicesTable();
        this.handleSnapshotCompletion({
          topic: "services.metrics",
          context:
            (snapshot?.summary
              ? Object.assign(
                  {
                    request_id: this.snapshotState.requestId,
                    total_services: snapshot.services.length,
                    unhealthy_services: snapshot?.summary?.unhealthy_services,
                    degraded_services: snapshot?.summary?.degraded_services,
                  },
                  this.snapshotState.context || {}
                )
              : this.snapshotState.context || null) || null,
        });
      },

      handleSnapshotBegin(payload) {
        const context = (payload && payload.context) || {};
        const requestId =
          context.request_id ||
          context.requestId ||
          payload?.request_id ||
          payload?.requestId ||
          null;

        const realtime = window.Realtime;
        const latestRequestId =
          realtime && realtime.lastSnapshotRequestIds
            ? realtime.lastSnapshotRequestIds["services.metrics"] ||
              realtime.lastSnapshotRequestIds.services ||
              null
            : null;

        if (
          requestId &&
          latestRequestId &&
          requestId !== latestRequestId &&
          this.snapshotState.requestId !== requestId
        ) {
          if (window.__DEBUG_REALTIME) {
            console.warn("[Services] Ignoring stale snapshot_begin", {
              requestId,
              latestRequestId,
              stateRequestId: this.snapshotState.requestId,
            });
          }
          return;
        }

        this.snapshotState.inProgress = true;
        this.snapshotState.started = true;
        this.snapshotState.requestId =
          requestId || this.snapshotState.requestId;
        this.snapshotState.context = context || null;
        this.snapshotState.totalAvailable = Number(
          context.total_services ?? context.total ?? payload?.total
        );
        if (!Number.isFinite(this.snapshotState.totalAvailable)) {
          this.snapshotState.totalAvailable = 0;
        }

        this.hasInitialSnapshot = false;
        this.servicesData = null;
        this.setLoading("Receiving services snapshot...");
        this.scheduleSnapshotTimer("begin");
      },

      handleSnapshotCompletion(payload) {
        this.clearSnapshotTimer();

        const context = (payload && payload.context) || {};
        const requestId =
          context.request_id ||
          context.requestId ||
          payload?.request_id ||
          payload?.requestId ||
          null;

        const realtime = window.Realtime;
        const latestRequestId =
          realtime && realtime.lastSnapshotRequestIds
            ? realtime.lastSnapshotRequestIds["services.metrics"] ||
              realtime.lastSnapshotRequestIds.services ||
              null
            : null;

        if (
          requestId &&
          latestRequestId &&
          requestId !== latestRequestId &&
          this.snapshotState.requestId !== requestId
        ) {
          if (window.__DEBUG_REALTIME) {
            console.warn("[Services] Ignoring stale snapshot_end", {
              requestId,
              latestRequestId,
              stateRequestId: this.snapshotState.requestId,
            });
          }
          return;
        }

        if (
          requestId &&
          this.snapshotState.requestId &&
          requestId !== this.snapshotState.requestId
        ) {
          if (window.__DEBUG_REALTIME) {
            console.warn("[Services] snapshot_end request mismatch", {
              requestId,
              stateRequestId: this.snapshotState.requestId,
            });
          }
          return;
        }

        if (requestId) {
          this.snapshotState.requestId = requestId;
        }

        if (context && Object.keys(context).length > 0) {
          this.snapshotState.context = context;
        }

        const totalServices = Number(
          context.total_services ?? context.total ?? payload?.sent
        );
        if (Number.isFinite(totalServices)) {
          this.snapshotState.totalAvailable = Math.max(
            this.snapshotState.totalAvailable,
            totalServices,
            this.servicesData?.services?.length || 0
          );
        }

        this.snapshotState.inProgress = false;
        this.snapshotState.started = false;

        if (!this.hasInitialSnapshot && this.servicesData) {
          this.renderServicesTable();
        }
      },

      handleRealtimeWarning(message) {
        this.clearSnapshotTimer();
        this.snapshotState.inProgress = false;
        this.snapshotState.started = false;
        console.warn("[Services] Realtime warning", {
          alias: message?.alias || message?.channel,
          code: message?.code,
          text: message?.message,
        });
        if (!this.hasInitialSnapshot) {
          this.setLoading("Realtime warning ‚Äì waiting for data...");
        }
      },

      handleRealtimeDisconnect() {
        this.clearSnapshotTimer();
        this.snapshotState.inProgress = false;
        this.snapshotState.started = false;
        console.warn("[Services] Realtime disconnected");
        if (!this.hasInitialSnapshot) {
          this.showError("Realtime connection lost");
        }
      },

      handleRealtimeReconnect() {
        console.info("[Services] Realtime reconnected ‚Äì requesting snapshot");
        this.requestSnapshot("ws-reconnected");
      },

      handleRealtimeUnavailable() {
        this.clearSnapshotTimer();
        this.snapshotState.inProgress = false;
        this.snapshotState.started = false;
        console.warn("[Services] Realtime unavailable");
        this.showError("Realtime unavailable");
      },

      requestSnapshot(reason = "manual") {
        const status = window.Realtime?.isConnected?.()
          ? "connected"
          : window.WsHub?.getStatus?.() || "unknown";
        console.log("[Services] Requesting snapshot", { reason, status });
        this.snapshotState.inProgress = true;
        this.snapshotState.started = false;
        this.snapshotState.requestId = null;
        this.snapshotState.context = null;
        this.snapshotState.totalAvailable = 0;
        this.scheduleSnapshotTimer("request");
        if (
          window.Realtime &&
          typeof window.Realtime.requestSnapshotForAliases === "function"
        ) {
          const result =
            window.Realtime.requestSnapshotForAliases(["services"]) || {};
          const requestId =
            result["services.metrics"] || result.services || null;
          if (requestId) {
            this.snapshotState.requestId = requestId;
          }
        } else if (
          window.Realtime &&
          typeof window.Realtime.updateFilters === "function"
        ) {
          const result =
            window.Realtime.updateFilters({
              snapshotTopics: ["services", "services.metrics"],
            }) || {};
          const requestId =
            result["services.metrics"] || result.services || null;
          if (requestId) {
            this.snapshotState.requestId = requestId;
          }
        } else {
          console.warn(
            "[Services] Realtime helper not available; cannot request snapshot"
          );
        }
      },
    };

    window.PageRealtime = window.PageRealtime || {};
    window.PageRealtime.services = {
      // Subscribe to both alias and concrete topic name for robustness
      topics: ["services", "services.metrics"],
      getFilters() {
        // Provide filters for both alias and concrete topic routing keys
        return { services: {}, "services.metrics": {} };
      },
      channels: {
        services(snapshot) {
          controller.handleServicesSnapshot(snapshot);
        },
        "services.metrics": function (snapshot) {
          controller.handleServicesSnapshot(snapshot);
        },
        "snapshot_begin:services.metrics": function (payload) {
          controller.handleSnapshotBegin(payload);
        },
        "snapshot_end:services.metrics": function (payload) {
          controller.handleSnapshotCompletion(payload);
        },
        "snapshot_begin:services": function (payload) {
          controller.handleSnapshotBegin(payload);
        },
        "snapshot_end:services": function (payload) {
          controller.handleSnapshotCompletion(payload);
        },
        _warning(message) {
          controller.handleRealtimeWarning(message);
        },
        _disconnected() {
          controller.handleRealtimeDisconnect();
        },
        _failed() {
          controller.handleRealtimeDisconnect();
        },
        _connected() {
          controller.handleRealtimeReconnect();
        },
      },
      onInitial(status) {
        if (status !== "connected") {
          controller.setLoading("Waiting for realtime connection...");
        } else if (!controller.hasInitialSnapshot) {
          controller.requestSnapshot("initial-load");
        }
      },
      onEnter() {
        if (!controller.hasInitialSnapshot) {
          controller.setLoading("Requesting snapshot...");
          controller.requestSnapshot("page-enter");
        }
      },
      onUnavailable() {
        controller.handleRealtimeUnavailable();
      },
      onExit() {
        controller.reset();
      },
    };

    window.refreshServices = function () {
      console.log("[Services] Manual refresh requested");
      controller.setLoading("Refreshing services...");
      controller.requestSnapshot("manual-refresh");
    };

    window.initServicesPage = function () {
      controller.initialize();
    };

    if (!window.Router) {
      controller.initialize();
    }
  })();
</script>
