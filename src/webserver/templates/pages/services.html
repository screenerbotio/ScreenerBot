<style>
  .services-toolbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-secondary);
  }

  .services-toolbar .toolbar-left,
  .services-toolbar .toolbar-right {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.75rem;
  }

  .services-toolbar .toolbar-left .input {
    min-width: 180px;
  }

  .services-toolbar .chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.35rem 0.65rem;
    border-radius: 999px;
    font-size: 0.85rem;
    font-weight: 600;
  }

  .services-toolbar .chip span {
    font-weight: 700;
  }

  .services-toolbar .chip-success {
    background: rgba(16, 185, 129, 0.15);
    color: #10b981;
  }

  .services-toolbar .chip-warn {
    background: rgba(245, 158, 11, 0.15);
    color: #f59e0b;
  }

  .services-toolbar .chip-error {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
  }

  .services-page .table-wrap {
    border-radius: 12px;
  }

  .services-table {
    width: 100%;
    border-collapse: collapse;
  }

  .services-table th,
  .services-table td {
    padding: 0.65rem 0.75rem;
    text-align: left;
    vertical-align: middle;
  }

  .services-table tbody tr:nth-child(even) {
    background: var(--bg-secondary);
  }

  .services-table th[data-sort] {
    cursor: pointer;
    user-select: none;
    position: relative;
    white-space: nowrap;
  }

  .services-table th[data-sort].asc::after {
    content: " ‚ñ≤";
    color: var(--text-muted);
  }

  .services-table th[data-sort].desc::after {
    content: " ‚ñº";
    color: var(--text-muted);
  }

  .activity-cell {
    min-width: 170px;
  }

  .activity-track {
    width: 100%;
    height: 6px;
    border-radius: 999px;
    overflow: hidden;
    background: var(--bg-secondary);
    margin-bottom: 4px;
  }

  .activity-fill {
    height: 100%;
    border-radius: 999px;
  }

  .activity-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-secondary);
  }

  .dependency-badge {
    font-size: 0.75rem;
    background: var(--bg-secondary);
    padding: 0.25rem 0.6rem;
    border-radius: 12px;
    display: inline-block;
    margin: 2px;
  }

  @media (max-width: 900px) {
    .services-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }

    .services-toolbar .toolbar-right {
      width: 100%;
      justify-content: flex-start;
    }
  }
</style>
<div class="page-table services-page">
  <div class="services-toolbar">
    <div class="toolbar-left">
      <input
        id="serviceSearch"
        class="input"
        type="text"
        placeholder="Search services..."
      />
      <select id="statusFilter" class="input">
        <option value="all">All statuses</option>
        <option value="healthy">Healthy</option>
        <option value="degraded">Degraded</option>
        <option value="starting">Starting</option>
        <option value="unhealthy">Unhealthy</option>
      </select>
      <label class="toggle">
        <input type="checkbox" id="enabledOnly" />
        Enabled only
      </label>
    </div>
    <div class="toolbar-right">
      <div class="chip">Total <span id="totalServices">-</span></div>
      <div class="chip chip-success">
        Healthy <span id="healthyServices">-</span>
      </div>
      <div class="chip chip-warn">
        Starting <span id="startingServices">-</span>
      </div>
      <div class="chip chip-error">
        Unhealthy <span id="unhealthyServices">-</span>
      </div>
      <div class="chip" title="Process-wide CPU">
        CPU <span id="processCpu">-</span>
      </div>
      <div class="chip" title="Process-wide Memory">
        Mem <span id="processMemory">-</span>
      </div>
      <button id="servicesExportBtn" class="btn btn-secondary" type="button">
        üì• Export Debug
      </button>
      <button class="btn btn-primary" onclick="refreshServices()">
        üîÑ Refresh
      </button>
    </div>
  </div>

  <div class="table-wrap">
    <table class="table services-table" id="servicesTable">
      <thead>
        <tr>
          <th data-sort="name">Name</th>
          <th data-sort="health">Health</th>
          <th data-sort="priority">Priority</th>
          <th data-sort="enabled">Enabled</th>
          <th data-sort="uptime">Uptime</th>
          <th data-sort="activity" title="Poll time ratio (busyness)">
            Activity
          </th>
          <th data-sort="lastCycle">Last Cycle</th>
          <th data-sort="avgCycle">Avg Cycle</th>
          <th data-sort="avgPoll">Avg Poll</th>
          <th data-sort="cycleRate">Cycles/s</th>
          <th data-sort="tasks">Tasks</th>
          <th data-sort="ops">Ops/s</th>
          <th data-sort="errors">Errors</th>
          <th>Dependencies</th>
        </tr>
      </thead>
      <tbody id="servicesTableBody">
        <tr>
          <td
            colspan="14"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading services...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
  (function () {
    const controller = {
      servicesData: null,
      sortKey: "priority",
      sortDir: "asc",
      hasInitialSnapshot: false,
      toolbarBound: false,
      sortBound: false,
      isFetching: false,
      abortController: null,
      lastErrorMessage: null,
      isActive: false,
      cleanupRegistered: false,
      poller: null,

      initialize() {
        console.log("[Services] Initializing controller");
        if (this.isActive) {
          console.log(
            "[Services] Controller already active; rendering snapshot"
          );
          this.renderServicesTable();
          return;
        }

        this.isActive = true;
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.lastErrorMessage = null;
        this.isFetching = false;
        this.abortInFlight();
        this.setLoading("Loading services...");
        this.bindToolbarEventsOnce();
        this.bindSortHandlersOnce();

        if (
          window.Router &&
          typeof Router.registerCleanup === "function" &&
          !this.cleanupRegistered
        ) {
          Router.registerCleanup(() => this.reset());
          this.cleanupRegistered = true;
        }

        this.fetchServices({ reason: "initial" });
        this.ensurePoller();
      },

      reset() {
        console.log("[Services] Resetting controller");
        this.isActive = false;
        if (this.poller && typeof this.poller.cleanup === "function") {
          this.poller.cleanup();
        }
        this.poller = null;
        this.abortInFlight();
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.lastErrorMessage = null;
        this.cleanupRegistered = false;
      },

      ensurePoller() {
        if (this.poller) {
          if (typeof this.poller.start === "function") {
            this.poller.start({ silent: true });
          }
          return;
        }

        if (
          window.PagePoller &&
          typeof window.PagePoller.create === "function"
        ) {
          this.poller = window.PagePoller.create({
            label: "Services",
            onPoll: () => this.fetchServices({ reason: "poll" }),
          });
          this.poller.start();
          return;
        }

        console.warn(
          "[Services] PagePoller unavailable; using fallback polling logic"
        );

        const startFallback = () => {
          const intervalProvider =
            window.PollingManager &&
            typeof window.PollingManager.getInterval === "function"
              ? window.PollingManager.getInterval.bind(window.PollingManager)
              : () => 1000;

          const interval = Number(intervalProvider()) || 1000;
          const id = setInterval(() => {
            this.fetchServices({ reason: "poll" });
          }, interval);

          if (window.Router && typeof Router.trackInterval === "function") {
            Router.trackInterval(id);
          }

          console.log("[Services] (fallback) Started polling", interval, "ms");
          return { id, intervalProvider };
        };

        let fallback = startFallback();

        this.poller = {
          start: () => {
            if (fallback?.id) {
              clearInterval(fallback.id);
            }
            fallback = startFallback();
          },
          stop: () => {
            if (fallback?.id) {
              clearInterval(fallback.id);
              fallback.id = null;
              console.log("[Services] (fallback) Stopped polling");
            }
          },
          cleanup: () => {
            if (fallback?.id) {
              clearInterval(fallback.id);
              fallback.id = null;
            }
          },
        };
      },

      abortInFlight() {
        if (this.abortController) {
          this.abortController.abort();
          this.abortController = null;
          this.isFetching = false;
          console.log("[Services] Aborted in-flight request");
        }
      },

      async fetchServices({ reason = "poll", showSpinner = false } = {}) {
        if (!this.isActive && reason !== "initial") {
          return;
        }

        if (this.isFetching) {
          if (reason === "poll") {
            console.log("[Services] Skipping poll; request already in flight");
            return;
          }
          this.abortInFlight();
        }

        if (showSpinner) {
          this.setLoading("Loading services...");
        }

        try {
          this.isFetching = true;
          this.abortController = new AbortController();
          console.log(`[Services] Fetching overview (${reason})`);
          const response = await fetch("/api/services/overview", {
            signal: this.abortController.signal,
            headers: { "X-Requested-With": "fetch" },
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const data = await response.json();
          this.servicesData = data;
          this.hasInitialSnapshot = true;
          this.lastErrorMessage = null;
          this.renderServicesTable();
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("[Services] Fetch aborted");
            return;
          }
          console.error("[Services] Failed to fetch services:", error);
          if (!this.hasInitialSnapshot) {
            this.lastErrorMessage = `Failed to load services: ${error.message}`;
            this.showError(this.lastErrorMessage);
          } else {
            this.lastErrorMessage = error.message;
          }
        } finally {
          this.isFetching = false;
          this.abortController = null;
        }
      },

      handleManualRefresh() {
        if (!this.isActive) {
          console.log("[Services] Manual refresh ignored; controller inactive");
          return;
        }
        console.log("[Services] Manual refresh requested");
        if (this.poller && typeof this.poller.stop === "function") {
          this.poller.stop();
        }
        this.abortInFlight();
        this.hasInitialSnapshot = false;
        this.servicesData = null;
        this.setLoading("Refreshing services...");
        this.fetchServices({ reason: "manual" }).finally(() => {
          if (this.isActive) {
            if (this.poller && typeof this.poller.start === "function") {
              this.poller.start({ silent: true });
            } else {
              this.ensurePoller();
            }
          }
        });
      },

      setLoading(message = "Loading services...") {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
              ${message}
            </td>
          </tr>
        `;
      },

      showError(message) {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: #ef4444;">
              ${message}
            </td>
          </tr>
        `;
      },

      updateSummary(summary) {
        const total = document.getElementById("totalServices");
        const healthy = document.getElementById("healthyServices");
        const starting = document.getElementById("startingServices");
        const unhealthy = document.getElementById("unhealthyServices");
        if (total) {
          total.textContent =
            summary?.total_services != null ? summary.total_services : "-";
        }
        if (healthy) {
          healthy.textContent =
            summary?.healthy_services != null ? summary.healthy_services : "-";
        }
        if (starting) {
          starting.textContent =
            summary?.starting_services != null
              ? summary.starting_services
              : "-";
        }
        if (unhealthy) {
          const degraded = summary?.degraded_services || 0;
          const unhealthyCount = summary?.unhealthy_services || 0;
          unhealthy.textContent =
            summary && summary.unhealthy_services != null
              ? unhealthyCount + degraded
              : "-";
        }
      },

      updateProcessMetrics(firstService) {
        const cpuEl = document.getElementById("processCpu");
        const memEl = document.getElementById("processMemory");
        const metrics = firstService?.metrics || {};
        if (cpuEl) {
          const cpu = Number.isFinite(metrics.process_cpu_percent)
            ? metrics.process_cpu_percent.toFixed(1) + "%"
            : "-";
          cpuEl.textContent = cpu;
        }
        if (memEl) {
          const mem = metrics.process_memory_bytes
            ? Utils.formatBytes(metrics.process_memory_bytes)
            : "-";
          memEl.textContent = mem;
        }
      },

      currentFilters() {
        const q = (
          document.getElementById("serviceSearch")?.value || ""
        ).toLowerCase();
        const status = document.getElementById("statusFilter")?.value || "all";
        const enabledOnly =
          document.getElementById("enabledOnly")?.checked || false;
        return { q, status, enabledOnly };
      },

      filteredAndSortedServices() {
        if (!this.servicesData) return [];
        const { q, status, enabledOnly } = this.currentFilters();
        const items = Array.isArray(this.servicesData.services)
          ? this.servicesData.services.slice()
          : [];

        const filtered = items.filter((service) => {
          const name = (service.name || "").toLowerCase();
          const matchesText = !q || name.includes(q);
          const matchesStatus =
            status === "all" || service.health?.status === status;
          const matchesEnabled = !enabledOnly || !!service.enabled;
          return matchesText && matchesStatus && matchesEnabled;
        });

        const sortKey = this.sortKey;
        const sortDir = this.sortDir === "asc" ? 1 : -1;

        const getKey = (service) => {
          const metrics = service.metrics || {};
          switch (sortKey) {
            case "name":
              return service.name || "";
            case "health":
              return this.healthRank(service.health?.status);
            case "priority":
              return service.priority || 0;
            case "enabled":
              return service.enabled ? 1 : 0;
            case "uptime":
              return service.uptime_seconds || 0;
            case "activity": {
              const total =
                (metrics.total_poll_duration_ns || 0) +
                (metrics.total_idle_duration_ns || 0);
              return total > 0
                ? (metrics.total_poll_duration_ns || 0) / total
                : 0;
            }
            case "lastCycle":
              return metrics.last_cycle_duration_ns || 0;
            case "avgCycle":
              return metrics.avg_cycle_duration_ns || 0;
            case "avgPoll":
              return metrics.mean_poll_duration_ns || 0;
            case "cycleRate":
              return metrics.cycles_per_second || 0;
            case "tasks":
              return metrics.task_count || 0;
            case "ops":
              return metrics.operations_per_second || 0;
            case "errors":
              return metrics.errors_total || 0;
            default:
              return service.priority || 0;
          }
        };

        filtered.sort((a, b) => {
          const aKey = getKey(a);
          const bKey = getKey(b);
          if (aKey < bKey) return -1 * sortDir;
          if (aKey > bKey) return 1 * sortDir;
          return 0;
        });

        return filtered;
      },

      renderServicesTable() {
        if (!this.servicesData) return;

        this.updateSummary(this.servicesData.summary);
        if (Array.isArray(this.servicesData.services)) {
          this.updateProcessMetrics(this.servicesData.services[0]);
        }

        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;

        const rows = this.filteredAndSortedServices()
          .map((service) => this.renderRow(service))
          .join("");

        if (!rows) {
          tbody.innerHTML = `
            <tr>
              <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
                No services match your filters
              </td>
            </tr>
          `;
        } else {
          tbody.innerHTML = rows;
        }
      },

      renderRow(service) {
        const metrics = service.metrics || {};
        const dependencies = Array.isArray(service.dependencies)
          ? service.dependencies.map(
              (dep) => `<span class="dependency-badge">${dep}</span>`
            )
          : [];

        const total =
          (metrics.total_poll_duration_ns || 0) +
          (metrics.total_idle_duration_ns || 0);
        const activity =
          total > 0 ? ((metrics.total_poll_duration_ns || 0) / total) * 100 : 0;
        const activityColor =
          activity > 80
            ? "#10b981"
            : activity > 50
            ? "#3b82f6"
            : activity > 20
            ? "#f59e0b"
            : activity > 5
            ? "#6b7280"
            : "#9ca3af";

        const lastCycle = Utils.formatDuration(
          metrics.last_cycle_duration_ns || 0
        );
        const avgCycle = Utils.formatDuration(
          metrics.avg_cycle_duration_ns || 0
        );
        const avgPoll = Utils.formatDuration(
          metrics.mean_poll_duration_ns || 0
        );
        const cycleRate = Number.isFinite(metrics.cycles_per_second)
          ? metrics.cycles_per_second.toFixed(2)
          : "0.00";

        const taskInfo =
          metrics.task_count > 0
            ? `${
                metrics.task_count
              } tasks\nLast cycle: ${lastCycle}\nAvg cycle: ${avgCycle}\nPoll: ${Utils.formatDuration(
                metrics.mean_poll_duration_ns
              )}\nIdle: ${Utils.formatDuration(
                metrics.mean_idle_duration_ns
              )}\nTotal Polls: ${metrics.total_polls || 0}`
            : "No instrumented tasks";

        return `
          <tr>
            <td style="font-weight:600;">${service.name || "-"}</td>
            <td>
              <span class="badge ${this.getHealthBadgeClass(service.health)}">
                ${this.getHealthStatus(service.health)}
              </span>
            </td>
            <td>${service.priority ?? "-"}</td>
            <td>${service.enabled ? "‚úÖ" : "‚ùå"}</td>
            <td>${Utils.formatUptime(service.uptime_seconds, {
              style: "compact",
            })}</td>
            <td class="activity-cell" title="${activity.toFixed(1)}% busy">
              <div class="activity-track">
                <div class="activity-fill" style="width:${activity.toFixed(
                  1
                )}%; background:${activityColor};"></div>
              </div>
              <div class="activity-meta">
                <span>${activity.toFixed(1)}%</span>
                <span>${metrics.total_polls || 0} polls</span>
              </div>
            </td>
            <td title="Last full loop duration">${lastCycle}</td>
            <td title="Average full loop duration">${avgCycle}</td>
            <td title="Average duration per poll">${avgPoll}</td>
            <td title="Cycles per second">${cycleRate}</td>
            <td title="${taskInfo}">${metrics.task_count || 0}</td>
            <td title="Operations per second">${(
              metrics.operations_per_second || 0
            ).toFixed(2)}</td>
            <td title="Total errors">${metrics.errors_total || 0}</td>
            <td>${
              dependencies.length > 0
                ? dependencies.join(" ")
                : '<span class="detail-value">None</span>'
            }</td>
          </tr>
        `;
      },

      bindToolbarEventsOnce() {
        if (this.toolbarBound) return;
        const self = this;
        const search = document.getElementById("serviceSearch");
        if (search) {
          search.addEventListener("input", () => self.renderServicesTable());
        }
        const status = document.getElementById("statusFilter");
        if (status) {
          status.addEventListener("change", () => self.renderServicesTable());
        }
        const enabledOnly = document.getElementById("enabledOnly");
        if (enabledOnly) {
          enabledOnly.addEventListener("change", () =>
            self.renderServicesTable()
          );
        }
        const exportBtn = document.getElementById("servicesExportBtn");
        if (exportBtn && !exportBtn.dataset.bound) {
          exportBtn.dataset.bound = "true";
          exportBtn.addEventListener("click", () => self.exportDebugReport());
        }
        this.toolbarBound = true;
      },

      bindSortHandlersOnce() {
        if (this.sortBound) return;
        const self = this;
        document
          .querySelectorAll("#servicesTable thead th[data-sort]")
          .forEach((th) => {
            th.addEventListener("click", () => {
              const key = th.getAttribute("data-sort");
              if (!key) return;
              if (self.sortKey === key) {
                self.sortDir = self.sortDir === "asc" ? "desc" : "asc";
              } else {
                self.sortKey = key;
                self.sortDir = "asc";
              }
              document
                .querySelectorAll("#servicesTable thead th[data-sort]")
                .forEach((header) => {
                  header.classList.remove("asc", "desc");
                });
              th.classList.add(self.sortDir);
              self.renderServicesTable();
            });
          });
        this.sortBound = true;
      },

      safeFormatDuration(value) {
        if (window.Utils && typeof Utils.formatDuration === "function") {
          return Utils.formatDuration(value || 0);
        }
        const nanos = Number(value) || 0;
        return `${nanos}ns`;
      },

      safeFormatUptime(value) {
        if (window.Utils && typeof Utils.formatUptime === "function") {
          return Utils.formatUptime(value || 0, { style: "detailed" });
        }
        const seconds = Math.max(0, Math.floor(Number(value) || 0));
        return `${seconds}s`;
      },

      safeFormatBytes(value) {
        if (window.Utils && typeof Utils.formatBytes === "function") {
          return Utils.formatBytes(value || 0);
        }
        const bytes = Math.max(0, Number(value) || 0);
        return `${bytes} B`;
      },

      sanitizeNumber(value, precision = null) {
        const num = Number(value);
        if (!Number.isFinite(num)) {
          return null;
        }
        if (precision == null) {
          return num;
        }
        return Number(num.toFixed(precision));
      },

      getActivityInfo(metrics = {}) {
        const poll = Number(metrics.total_poll_duration_ns) || 0;
        const idle = Number(metrics.total_idle_duration_ns) || 0;
        const total = poll + idle;
        const percent = total > 0 ? (poll / total) * 100 : 0;
        let status = "Idle";
        if (percent > 80) {
          status = "Very Active";
        } else if (percent > 50) {
          status = "Active";
        } else if (percent > 20) {
          status = "Moderate";
        } else if (percent > 5) {
          status = "Light";
        }
        return { percent, status };
      },

      extractProcessSnapshot() {
        if (
          !this.servicesData ||
          !Array.isArray(this.servicesData.services) ||
          this.servicesData.services.length === 0
        ) {
          return null;
        }
        const metrics = this.servicesData.services[0]?.metrics || {};
        return {
          cpu_percent: this.sanitizeNumber(metrics.process_cpu_percent, 2),
          memory_bytes:
            metrics.process_memory_bytes != null
              ? Number(metrics.process_memory_bytes)
              : null,
          memory_human: this.safeFormatBytes(metrics.process_memory_bytes),
        };
      },

      async exportDebugReport() {
        const exportBtn = document.getElementById("servicesExportBtn");
        if (exportBtn) {
          exportBtn.disabled = true;
          exportBtn.textContent = "Exporting‚Ä¶";
        }

        try {
          if (!this.servicesData) {
            await this.fetchServices({ reason: "export", showSpinner: true });
          }

          if (
            !this.servicesData ||
            !Array.isArray(this.servicesData.services) ||
            this.servicesData.services.length === 0
          ) {
            throw new Error("Services snapshot unavailable. Refresh first.");
          }

          const filters = this.currentFilters();
          const visibleSet = new Set(
            this.filteredAndSortedServices().map((svc) => svc.name)
          );

          const servicesPayload = this.servicesData.services.map((service) => {
            const baseMetrics = service.metrics || {};
            const metrics = {
              ...baseMetrics,
              custom_metrics: {
                ...(baseMetrics.custom_metrics || {}),
              },
            };
            const activity = this.getActivityInfo(metrics);
            const uptimeSeconds =
              Number(metrics.uptime_seconds) ||
              Number(service.uptime_seconds) ||
              0;
            const pollsPerSecond =
              uptimeSeconds > 0
                ? (Number(metrics.total_polls) || 0) / uptimeSeconds
                : 0;

            const detailedMetrics = {
              process_cpu_percent: this.sanitizeNumber(
                metrics.process_cpu_percent,
                2
              ),
              process_memory_bytes:
                metrics.process_memory_bytes != null
                  ? Number(metrics.process_memory_bytes)
                  : null,
              process_memory_human: this.safeFormatBytes(
                metrics.process_memory_bytes
              ),
              task_count: metrics.task_count ?? 0,
              total_polls: metrics.total_polls ?? 0,
              total_poll_duration_ns: metrics.total_poll_duration_ns ?? 0,
              mean_poll_duration_ns: metrics.mean_poll_duration_ns ?? 0,
              mean_poll_duration_human: this.safeFormatDuration(
                metrics.mean_poll_duration_ns
              ),
              total_idle_duration_ns: metrics.total_idle_duration_ns ?? 0,
              mean_idle_duration_ns: metrics.mean_idle_duration_ns ?? 0,
              mean_idle_duration_human: this.safeFormatDuration(
                metrics.mean_idle_duration_ns
              ),
              last_cycle_duration_ns: metrics.last_cycle_duration_ns ?? 0,
              last_cycle_duration_human: this.safeFormatDuration(
                metrics.last_cycle_duration_ns
              ),
              avg_cycle_duration_ns: metrics.avg_cycle_duration_ns ?? 0,
              avg_cycle_duration_human: this.safeFormatDuration(
                metrics.avg_cycle_duration_ns
              ),
              cycles_per_second: this.sanitizeNumber(
                metrics.cycles_per_second,
                4
              ),
              activity_percent: this.sanitizeNumber(activity.percent, 2),
              activity_status: activity.status,
              uptime_seconds: uptimeSeconds || null,
              uptime_human: this.safeFormatUptime(uptimeSeconds),
              operations_total: metrics.operations_total ?? 0,
              operations_per_second: this.sanitizeNumber(
                metrics.operations_per_second,
                4
              ),
              errors_total: metrics.errors_total ?? 0,
              polls_per_second: this.sanitizeNumber(pollsPerSecond, 4),
              custom_metrics: metrics.custom_metrics,
            };

            return {
              name: service.name,
              priority: service.priority,
              enabled: !!service.enabled,
              health: service.health || null,
              health_message:
                service.health && typeof service.health === "object"
                  ? service.health.message || null
                  : null,
              uptime_seconds:
                service.uptime_seconds != null
                  ? Number(service.uptime_seconds)
                  : null,
              uptime_human: this.safeFormatUptime(service.uptime_seconds),
              dependencies: Array.isArray(service.dependencies)
                ? service.dependencies.slice()
                : [],
              visible_in_current_view: visibleSet.has(service.name),
              metrics: detailedMetrics,
            };
          });

          const nowIso = new Date().toISOString();
          const payload = {
            generated_at: nowIso,
            overview_timestamp: this.servicesData.timestamp,
            source: "services_tab_export",
            filters_applied: filters,
            summary: this.servicesData.summary || null,
            process_snapshot: this.extractProcessSnapshot(),
            totals: {
              services_total: servicesPayload.length,
              visible_services: servicesPayload.filter(
                (svc) => svc.visible_in_current_view
              ).length,
            },
            services: servicesPayload,
            dependency_graph: this.servicesData.dependency_graph || [],
            last_error: this.lastErrorMessage || null,
          };

          const blob = new Blob([JSON.stringify(payload, null, 2)], {
            type: "application/json;charset=utf-8",
          });
          const url = URL.createObjectURL(blob);
          const filename = `services_debug_${nowIso.replace(
            /[:.]/g,
            "-"
          )}.json`;
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);

          if (window.Utils && typeof Utils.showToast === "function") {
            Utils.showToast("Services debug export ready", "success");
          }
        } catch (error) {
          console.error("[Services] Debug export failed", error);
          if (window.Utils && typeof Utils.showToast === "function") {
            Utils.showToast(
              error?.message || "Failed to export services debug snapshot",
              "error"
            );
          }
        } finally {
          if (exportBtn) {
            exportBtn.disabled = false;
            exportBtn.textContent = "üì• Export Debug";
          }
        }
      },

      healthRank(status) {
        switch (status) {
          case "healthy":
            return 3;
          case "degraded":
            return 2;
          case "starting":
            return 1;
          case "unhealthy":
            return 0;
          default:
            return -1;
        }
      },

      getHealthStatus(health) {
        if (health?.status === "healthy") return "‚úÖ Healthy";
        if (health?.status === "starting") return "‚è≥ Starting";
        if (health?.status === "degraded") return "‚ö†Ô∏è Degraded";
        if (health?.status === "unhealthy") return "‚ùå Unhealthy";
        return `‚è∏Ô∏è ${health?.status || "unknown"}`;
      },

      getHealthBadgeClass(health) {
        if (health?.status === "healthy") return "success";
        if (health?.status === "starting") return "warning";
        if (health?.status === "degraded") return "warning";
        if (health?.status === "unhealthy") return "error";
        return "secondary";
      },
    };

    // Manual refresh function
    window.refreshServices = function () {
      if (controller) {
        controller.handleManualRefresh();
      }
    };

    window.ensureServicesPageReady = function () {
      if (controller) {
        controller.initialize();
      }
    };

    // Page initialization function called by Router
    window.initServicesPage = function () {
      console.log("[Services] Page initialized");
      controller.initialize();
    };

    // Fallback for non-router usage
    if (!window.Router) {
      controller.initialize();
    }
  })();
</script>
