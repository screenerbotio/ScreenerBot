<style>
  .services-toolbar {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--bg-secondary);
  }

  .services-toolbar .toolbar-left,
  .services-toolbar .toolbar-right {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.75rem;
  }

  .services-toolbar .toolbar-left .input {
    min-width: 180px;
  }

  .services-toolbar .chip {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.35rem 0.65rem;
    border-radius: 999px;
    font-size: 0.85rem;
    font-weight: 600;
  }

  .services-toolbar .chip span {
    font-weight: 700;
  }

  .services-toolbar .chip-success {
    background: rgba(16, 185, 129, 0.15);
    color: #10b981;
  }

  .services-toolbar .chip-warn {
    background: rgba(245, 158, 11, 0.15);
    color: #f59e0b;
  }

  .services-toolbar .chip-error {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
  }

  .services-page .table-wrap {
    border-radius: 12px;
  }

  .services-table {
    width: 100%;
    border-collapse: collapse;
  }

  .services-table th,
  .services-table td {
    padding: 0.65rem 0.75rem;
    text-align: left;
    vertical-align: middle;
  }

  .services-table tbody tr:nth-child(even) {
    background: var(--bg-secondary);
  }

  .services-table th[data-sort] {
    cursor: pointer;
    user-select: none;
    position: relative;
    white-space: nowrap;
  }

  .services-table th[data-sort].asc::after {
    content: " ‚ñ≤";
    color: var(--text-muted);
  }

  .services-table th[data-sort].desc::after {
    content: " ‚ñº";
    color: var(--text-muted);
  }

  .activity-cell {
    min-width: 170px;
  }

  .activity-track {
    width: 100%;
    height: 6px;
    border-radius: 999px;
    overflow: hidden;
    background: var(--bg-secondary);
    margin-bottom: 4px;
  }

  .activity-fill {
    height: 100%;
    border-radius: 999px;
  }

  .activity-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-secondary);
  }

  .dependency-badge {
    font-size: 0.75rem;
    background: var(--bg-secondary);
    padding: 0.25rem 0.6rem;
    border-radius: 12px;
    display: inline-block;
    margin: 2px;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    padding: 0.15rem 0.5rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.8rem;
  }

  .badge.success {
    background: var(--badge-online);
    color: #fff;
  }

  .badge.warning {
    background: var(--badge-loading);
    color: #fff;
  }

  .badge.error {
    background: var(--badge-error);
    color: #fff;
  }

  .badge.secondary {
    background: var(--bg-secondary);
    color: var(--text-primary);
  }

  @media (max-width: 900px) {
    .services-toolbar {
      flex-direction: column;
      align-items: flex-start;
    }

    .services-toolbar .toolbar-right {
      width: 100%;
      justify-content: flex-start;
    }
  }
</style>
<div class="page-table services-page">
  <div class="services-toolbar">
    <div class="toolbar-left">
      <input
        id="serviceSearch"
        class="input"
        type="text"
        placeholder="Search services..."
      />
      <select id="statusFilter" class="input">
        <option value="all">All statuses</option>
        <option value="healthy">Healthy</option>
        <option value="degraded">Degraded</option>
        <option value="starting">Starting</option>
        <option value="unhealthy">Unhealthy</option>
      </select>
      <label class="toggle">
        <input type="checkbox" id="enabledOnly" />
        Enabled only
      </label>
    </div>
    <div class="toolbar-right">
      <div class="chip">Total <span id="totalServices">-</span></div>
      <div class="chip chip-success">
        Healthy <span id="healthyServices">-</span>
      </div>
      <div class="chip chip-warn">
        Starting <span id="startingServices">-</span>
      </div>
      <div class="chip chip-error">
        Unhealthy <span id="unhealthyServices">-</span>
      </div>
      <div class="chip" title="Process-wide CPU">
        CPU <span id="processCpu">-</span>
      </div>
      <div class="chip" title="Process-wide Memory">
        Mem <span id="processMemory">-</span>
      </div>
      <button class="btn btn-primary" onclick="refreshServices()">
        üîÑ Refresh
      </button>
    </div>
  </div>

  <div class="table-wrap">
    <table class="table services-table" id="servicesTable">
      <thead>
        <tr>
          <th data-sort="name">Name</th>
          <th data-sort="health">Health</th>
          <th data-sort="priority">Priority</th>
          <th data-sort="enabled">Enabled</th>
          <th data-sort="uptime">Uptime</th>
          <th data-sort="activity" title="Poll time ratio (busyness)">
            Activity
          </th>
          <th data-sort="lastCycle">Last Cycle</th>
          <th data-sort="avgCycle">Avg Cycle</th>
          <th data-sort="avgPoll">Avg Poll</th>
          <th data-sort="cycleRate">Cycles/s</th>
          <th data-sort="tasks">Tasks</th>
          <th data-sort="ops">Ops/s</th>
          <th data-sort="errors">Errors</th>
          <th>Dependencies</th>
        </tr>
      </thead>
      <tbody id="servicesTableBody">
        <tr>
          <td
            colspan="14"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading services...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
  (function () {
    const controller = {
      servicesData: null,
      sortKey: "priority",
      sortDir: "asc",
      hasInitialSnapshot: false,
      toolbarBound: false,
      sortBound: false,
      isFetching: false,
      abortController: null,
      lastErrorMessage: null,
      isActive: false,
      cleanupRegistered: false,
      intervalChangeListener: null,

      pollTimer: null,

      initialize() {
        console.log("[Services] Initializing controller");
        if (this.isActive) {
          console.log(
            "[Services] Controller already active; rendering snapshot"
          );
          this.renderServicesTable();
          return;
        }
        this.isActive = true;
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.lastErrorMessage = null;
        this.isFetching = false;
        this.abortInFlight();
        this.setLoading("Loading services...");
        this.bindToolbarEventsOnce();
        this.bindSortHandlersOnce();
        if (
          window.Router &&
          typeof Router.registerCleanup === "function" &&
          !this.cleanupRegistered
        ) {
          Router.registerCleanup(() => this.reset());
          this.cleanupRegistered = true;
        }

        // Register interval change listener
        this.intervalChangeListener = window.PollingManager.onChange(() => {
          if (this.isActive) {
            console.log(
              "[Services] Polling interval changed, restarting polling"
            );
            this.startPolling();
          }
        });

        this.fetchServices({ reason: "initial" });
        this.startPolling();
      },

      reset() {
        console.log("[Services] Resetting controller");
        this.isActive = false;
        this.stopPolling();
        this.abortInFlight();
        this.servicesData = null;
        this.hasInitialSnapshot = false;
        this.lastErrorMessage = null;
        this.cleanupRegistered = false;

        // Remove interval change listener
        if (this.intervalChangeListener && window.PollingManager) {
          window.PollingManager.removeListener(this.intervalChangeListener);
          this.intervalChangeListener = null;
        }
      },

      startPolling() {
        if (!this.isActive) {
          return;
        }
        this.stopPolling();
        const interval = window.PollingManager.getInterval();
        const intervalId = setInterval(() => {
          this.fetchServices({ reason: "poll" });
        }, interval);
        this.pollTimer = intervalId;
        if (window.Router && typeof Router.trackInterval === "function") {
          Router.trackInterval(intervalId);
        }
        console.log("[Services] Started polling every", interval, "ms");
      },

      stopPolling() {
        if (this.pollTimer) {
          clearInterval(this.pollTimer);
          this.pollTimer = null;
          console.log("[Services] Stopped polling");
        }
      },

      abortInFlight() {
        if (this.abortController) {
          this.abortController.abort();
          this.abortController = null;
          this.isFetching = false;
          console.log("[Services] Aborted in-flight request");
        }
      },

      async fetchServices({ reason = "poll", showSpinner = false } = {}) {
        if (!this.isActive && reason !== "initial") {
          return;
        }

        if (this.isFetching) {
          if (reason === "poll") {
            console.log("[Services] Skipping poll; request already in flight");
            return;
          }
          this.abortInFlight();
        }

        if (showSpinner) {
          this.setLoading("Loading services...");
        }

        try {
          this.isFetching = true;
          this.abortController = new AbortController();
          console.log(`[Services] Fetching overview (${reason})`);
          const response = await fetch("/api/services/overview", {
            signal: this.abortController.signal,
            headers: { "X-Requested-With": "fetch" },
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          const data = await response.json();
          this.servicesData = data;
          this.hasInitialSnapshot = true;
          this.lastErrorMessage = null;
          this.renderServicesTable();
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("[Services] Fetch aborted");
            return;
          }
          console.error("[Services] Failed to fetch services:", error);
          if (!this.hasInitialSnapshot) {
            this.lastErrorMessage = `Failed to load services: ${error.message}`;
            this.showError(this.lastErrorMessage);
          } else {
            this.lastErrorMessage = error.message;
          }
        } finally {
          this.isFetching = false;
          this.abortController = null;
        }
      },

      handleManualRefresh() {
        if (!this.isActive) {
          console.log("[Services] Manual refresh ignored; controller inactive");
          return;
        }
        console.log("[Services] Manual refresh requested");
        this.stopPolling();
        this.abortInFlight();
        this.hasInitialSnapshot = false;
        this.servicesData = null;
        this.setLoading("Refreshing services...");
        this.fetchServices({ reason: "manual" }).finally(() => {
          if (this.isActive) {
            this.startPolling();
          }
        });
      },

      setLoading(message = "Loading services...") {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
              ${message}
            </td>
          </tr>
        `;
      },

      showError(message) {
        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;
        tbody.innerHTML = `
          <tr>
            <td colspan="14" style="text-align:center; padding: 20px; color: #ef4444;">
              ${message}
            </td>
          </tr>
        `;
      },

      updateSummary(summary) {
        const total = document.getElementById("totalServices");
        const healthy = document.getElementById("healthyServices");
        const starting = document.getElementById("startingServices");
        const unhealthy = document.getElementById("unhealthyServices");
        if (total) {
          total.textContent =
            summary?.total_services != null ? summary.total_services : "-";
        }
        if (healthy) {
          healthy.textContent =
            summary?.healthy_services != null ? summary.healthy_services : "-";
        }
        if (starting) {
          starting.textContent =
            summary?.starting_services != null
              ? summary.starting_services
              : "-";
        }
        if (unhealthy) {
          const degraded = summary?.degraded_services || 0;
          const unhealthyCount = summary?.unhealthy_services || 0;
          unhealthy.textContent =
            summary && summary.unhealthy_services != null
              ? unhealthyCount + degraded
              : "-";
        }
      },

      updateProcessMetrics(firstService) {
        const cpuEl = document.getElementById("processCpu");
        const memEl = document.getElementById("processMemory");
        const metrics = firstService?.metrics || {};
        if (cpuEl) {
          const cpu = Number.isFinite(metrics.process_cpu_percent)
            ? metrics.process_cpu_percent.toFixed(1) + "%"
            : "-";
          cpuEl.textContent = cpu;
        }
        if (memEl) {
          const mem = metrics.process_memory_bytes
            ? Utils.formatBytes(metrics.process_memory_bytes)
            : "-";
          memEl.textContent = mem;
        }
      },

      currentFilters() {
        const q = (
          document.getElementById("serviceSearch")?.value || ""
        ).toLowerCase();
        const status = document.getElementById("statusFilter")?.value || "all";
        const enabledOnly =
          document.getElementById("enabledOnly")?.checked || false;
        return { q, status, enabledOnly };
      },

      filteredAndSortedServices() {
        if (!this.servicesData) return [];
        const { q, status, enabledOnly } = this.currentFilters();
        const items = Array.isArray(this.servicesData.services)
          ? this.servicesData.services.slice()
          : [];

        const filtered = items.filter((service) => {
          const name = (service.name || "").toLowerCase();
          const matchesText = !q || name.includes(q);
          const matchesStatus =
            status === "all" || service.health?.status === status;
          const matchesEnabled = !enabledOnly || !!service.enabled;
          return matchesText && matchesStatus && matchesEnabled;
        });

        const sortKey = this.sortKey;
        const sortDir = this.sortDir === "asc" ? 1 : -1;

        const getKey = (service) => {
          const metrics = service.metrics || {};
          switch (sortKey) {
            case "name":
              return service.name || "";
            case "health":
              return this.healthRank(service.health?.status);
            case "priority":
              return service.priority || 0;
            case "enabled":
              return service.enabled ? 1 : 0;
            case "uptime":
              return service.uptime_seconds || 0;
            case "activity": {
              const total =
                (metrics.total_poll_duration_ns || 0) +
                (metrics.total_idle_duration_ns || 0);
              return total > 0
                ? (metrics.total_poll_duration_ns || 0) / total
                : 0;
            }
            case "lastCycle":
              return metrics.last_cycle_duration_ns || 0;
            case "avgCycle":
              return metrics.avg_cycle_duration_ns || 0;
            case "avgPoll":
              return metrics.mean_poll_duration_ns || 0;
            case "cycleRate":
              return metrics.cycles_per_second || 0;
            case "tasks":
              return metrics.task_count || 0;
            case "ops":
              return metrics.operations_per_second || 0;
            case "errors":
              return metrics.errors_total || 0;
            default:
              return service.priority || 0;
          }
        };

        filtered.sort((a, b) => {
          const aKey = getKey(a);
          const bKey = getKey(b);
          if (aKey < bKey) return -1 * sortDir;
          if (aKey > bKey) return 1 * sortDir;
          return 0;
        });

        return filtered;
      },

      renderServicesTable() {
        if (!this.servicesData) return;

        this.updateSummary(this.servicesData.summary);
        if (Array.isArray(this.servicesData.services)) {
          this.updateProcessMetrics(this.servicesData.services[0]);
        }

        const tbody = document.getElementById("servicesTableBody");
        if (!tbody) return;

        const rows = this.filteredAndSortedServices()
          .map((service) => this.renderRow(service))
          .join("");

        if (!rows) {
          tbody.innerHTML = `
            <tr>
              <td colspan="14" style="text-align:center; padding: 20px; color: var(--text-muted);">
                No services match your filters
              </td>
            </tr>
          `;
        } else {
          tbody.innerHTML = rows;
        }
      },

      renderRow(service) {
        const metrics = service.metrics || {};
        const dependencies = Array.isArray(service.dependencies)
          ? service.dependencies.map(
              (dep) => `<span class="dependency-badge">${dep}</span>`
            )
          : [];

        const total =
          (metrics.total_poll_duration_ns || 0) +
          (metrics.total_idle_duration_ns || 0);
        const activity =
          total > 0 ? ((metrics.total_poll_duration_ns || 0) / total) * 100 : 0;
        const activityColor =
          activity > 80
            ? "#10b981"
            : activity > 50
            ? "#3b82f6"
            : activity > 20
            ? "#f59e0b"
            : activity > 5
            ? "#6b7280"
            : "#9ca3af";

        const lastCycle = Utils.formatDuration(
          metrics.last_cycle_duration_ns || 0
        );
        const avgCycle = Utils.formatDuration(
          metrics.avg_cycle_duration_ns || 0
        );
        const avgPoll = Utils.formatDuration(
          metrics.mean_poll_duration_ns || 0
        );
        const cycleRate = Number.isFinite(metrics.cycles_per_second)
          ? metrics.cycles_per_second.toFixed(2)
          : "0.00";

        const taskInfo =
          metrics.task_count > 0
            ? `${
                metrics.task_count
              } tasks\nLast cycle: ${lastCycle}\nAvg cycle: ${avgCycle}\nPoll: ${Utils.formatDuration(
                metrics.mean_poll_duration_ns
              )}\nIdle: ${Utils.formatDuration(
                metrics.mean_idle_duration_ns
              )}\nTotal Polls: ${metrics.total_polls || 0}`
            : "No instrumented tasks";

        return `
          <tr>
            <td style="font-weight:600;">${service.name || "-"}</td>
            <td>
              <span class="badge ${this.getHealthBadgeClass(service.health)}">
                ${this.getHealthStatus(service.health)}
              </span>
            </td>
            <td>${service.priority ?? "-"}</td>
            <td>${service.enabled ? "‚úÖ" : "‚ùå"}</td>
            <td>${Utils.formatUptime(service.uptime_seconds, {
              style: "compact",
            })}</td>
            <td class="activity-cell" title="${activity.toFixed(1)}% busy">
              <div class="activity-track">
                <div class="activity-fill" style="width:${activity.toFixed(
                  1
                )}%; background:${activityColor};"></div>
              </div>
              <div class="activity-meta">
                <span>${activity.toFixed(1)}%</span>
                <span>${metrics.total_polls || 0} polls</span>
              </div>
            </td>
            <td title="Last full loop duration">${lastCycle}</td>
            <td title="Average full loop duration">${avgCycle}</td>
            <td title="Average duration per poll">${avgPoll}</td>
            <td title="Cycles per second">${cycleRate}</td>
            <td title="${taskInfo}">${metrics.task_count || 0}</td>
            <td title="Operations per second">${(
              metrics.operations_per_second || 0
            ).toFixed(2)}</td>
            <td title="Total errors">${metrics.errors_total || 0}</td>
            <td>${
              dependencies.length > 0
                ? dependencies.join(" ")
                : '<span class="detail-value">None</span>'
            }</td>
          </tr>
        `;
      },

      bindToolbarEventsOnce() {
        if (this.toolbarBound) return;
        const self = this;
        const search = document.getElementById("serviceSearch");
        if (search) {
          search.addEventListener("input", () => self.renderServicesTable());
        }
        const status = document.getElementById("statusFilter");
        if (status) {
          status.addEventListener("change", () => self.renderServicesTable());
        }
        const enabledOnly = document.getElementById("enabledOnly");
        if (enabledOnly) {
          enabledOnly.addEventListener("change", () =>
            self.renderServicesTable()
          );
        }
        this.toolbarBound = true;
      },

      bindSortHandlersOnce() {
        if (this.sortBound) return;
        const self = this;
        document
          .querySelectorAll("#servicesTable thead th[data-sort]")
          .forEach((th) => {
            th.addEventListener("click", () => {
              const key = th.getAttribute("data-sort");
              if (!key) return;
              if (self.sortKey === key) {
                self.sortDir = self.sortDir === "asc" ? "desc" : "asc";
              } else {
                self.sortKey = key;
                self.sortDir = "asc";
              }
              document
                .querySelectorAll("#servicesTable thead th[data-sort]")
                .forEach((header) => {
                  header.classList.remove("asc", "desc");
                });
              th.classList.add(self.sortDir);
              self.renderServicesTable();
            });
          });
        this.sortBound = true;
      },

      healthRank(status) {
        switch (status) {
          case "healthy":
            return 3;
          case "degraded":
            return 2;
          case "starting":
            return 1;
          case "unhealthy":
            return 0;
          default:
            return -1;
        }
      },

      getHealthStatus(health) {
        if (health?.status === "healthy") return "‚úÖ Healthy";
        if (health?.status === "starting") return "‚è≥ Starting";
        if (health?.status === "degraded") return "‚ö†Ô∏è Degraded";
        if (health?.status === "unhealthy") return "‚ùå Unhealthy";
        return `‚è∏Ô∏è ${health?.status || "unknown"}`;
      },

      getHealthBadgeClass(health) {
        if (health?.status === "healthy") return "success";
        if (health?.status === "starting") return "warning";
        if (health?.status === "degraded") return "warning";
        if (health?.status === "unhealthy") return "error";
        return "secondary";
      },
    };

    // Manual refresh function
    window.refreshServices = function () {
      if (controller) {
        controller.handleManualRefresh();
      }
    };

    window.ensureServicesPageReady = function () {
      if (controller) {
        controller.initialize();
      }
    };

    // Page initialization function called by Router
    window.initServicesPage = function () {
      console.log("[Services] Page initialized");
      controller.initialize();
    };

    // Fallback for non-router usage
    if (!window.Router) {
      controller.initialize();
    }
  })();
</script>
