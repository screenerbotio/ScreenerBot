<script>
  var DEFAULT_TOKENS_VIEW = "pool";
  var TOKENS_VIEW_DEFS = [
    { id: "pool", label: "üíß Pool Service" },
    { id: "all", label: "üìã All Tokens" },
    { id: "passed", label: "‚úÖ Passed" },
    { id: "rejected", label: "‚õî Rejected" },
    { id: "blacklisted", label: "üö´ Blacklisted" },
    { id: "positions", label: "üìä Positions" },
    { id: "secure", label: "üõ°Ô∏è Secure" },
    { id: "recent", label: "üÜï Recent" },
  ];
  var TOKENS_VIEWS = TOKENS_VIEW_DEFS.map(function (view) {
    return view.id;
  });
  var VIEW_LABELS = {
    pool: "with available prices",
    all: "in database",
    passed: "that passed filtering",
    rejected: "rejected by filtering",
    blacklisted: "blacklisted",
    positions: "with open positions",
    secure: "secure",
    recent: "recently updated",
  };

  var tokensState = window.tokensState || {
    view: DEFAULT_TOKENS_VIEW,
    sortBy: "symbol",
    sortDir: "asc",
    searchTerm: "",
  };

  var allTokensData = [];
  // Per-view cache to preserve last loaded snapshot per tab
  // Entry shape: { items: TokenSummary[], total: number, sortBy, sortDir, searchTerm, ts }
  var tokensViewCache = window.tokensViewCache || {};
  var currentModalMint = null;
  var tokenModalData = null;
  var searchDebounceHandle = null;
  var tokensSnapshotState = {
    inProgress: false,
    pending: [],
    expected: 0,
    totalAvailable: 0,
    message: "",
    timeoutHandle: null,
    retryCount: 0,
    began: false,
    currentView: null,
    searchAutoCleared: false,
    requestId: null,
    context: null,
  };
  var TOKENS_SNAPSHOT_LIMIT = 200;
  var TOKENS_SNAPSHOT_TIMEOUT_MS = 12000;

  // Global init function for Router to call during SPA navigation
  window.initTokensPage = function () {
    console.log("[Tokens] Initializing page");
    hydrateTokensState();
    ensureTokensPageReady({ updateStatus: false });
    setupSortableHeaders();
    attachGlobalListeners();
    setTokenCountStatus("‚è≥ Waiting for realtime snapshot...");
  };

  function hydrateTokensState() {
    const savedView = window.sessionStorage.getItem("tokens.view");
    if (savedView && TOKENS_VIEWS.includes(savedView)) {
      tokensState.view = savedView;
    } else if (savedView) {
      console.warn("[Tokens] Ignoring unsupported stored view", savedView);
      window.sessionStorage.removeItem("tokens.view");
    }

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }
    window.PageRealtime = window.PageRealtime || {};
    // Tokens list is served exclusively over realtime snapshots (no HTTP fallback)
    window.PageRealtime.tokens = {
      topics: ["tokens", "tokens.update"],
      channels: {
        tokens: handleTokensRealtime,
        "tokens.update": handleTokensRealtime,
        "snapshot_begin:tokens.update": handleTokensSnapshotBegin,
        "snapshot_end:tokens.update": handleTokensSnapshotEnd,
        // Support alias-based snapshot lifecycle events as well
        "snapshot_begin:tokens": handleTokensSnapshotBegin,
        "snapshot_end:tokens": handleTokensSnapshotEnd,
        _warning: handleTokensWarning,
        _disconnected: handleTokensDisconnect,
        _failed: handleTokensDisconnect,
        _connected: handleTokensReconnect,
      },
      getFilters() {
        const topic = "tokens.update";
        const limit = TOKENS_SNAPSHOT_LIMIT;
        if (!TOKENS_VIEWS.includes(tokensState.view)) {
          tokensState.view = DEFAULT_TOKENS_VIEW;
          window.sessionStorage.setItem("tokens.view", tokensState.view);
        }
        const filter = {
          view: tokensState.view,
          sort_by: tokensState.sortBy,
          sort_dir: tokensState.sortDir,
          page: 1,
          page_size: limit,
          limit,
        };
        if (tokensState.searchTerm) {
          filter.search = tokensState.searchTerm;
        }
        const out = { [topic]: filter };
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] getFilters", out);
        }
        return out;
      },
      onInitial(status) {
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] onInitial", status);
        }
        if (status === "connected") {
          setTokenCountStatus("üîå Realtime connected ‚Ä¢ Loading tokens...");
        } else if (status === "connecting") {
          setTokenCountStatus("üîÑ Connecting to realtime...");
        } else {
          setTokenCountStatus(
            "‚ö†Ô∏è Realtime unavailable ‚Äì waiting for connection"
          );
        }
      },
      onUnavailable() {
        console.warn("[Tokens] Realtime unavailable ‚Äì retrying snapshot");
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] onUnavailable");
        }
        setTokenCountStatus("‚ö†Ô∏è Realtime unavailable ‚Äì retrying...");
        requestTokensSnapshot("Retrying after realtime unavailable...");
      },
      onEnter(status) {
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] onEnter", status, {
            view: tokensState.view,
          });
        }
        if (status === "connected") {
          requestTokensSnapshot("Loading tokens...");
        } else if (status === "connecting") {
          setTokenCountStatus("üîÑ Connecting to realtime...");
          requestTokensSnapshot("Connecting to realtime...");
        } else {
          setTokenCountStatus("‚ö†Ô∏è Waiting for realtime connection...");
          requestTokensSnapshot("Waiting for realtime connection...");
        }
      },
      onExit() {
        clearTokensSnapshotTimer();
        tokensSnapshotState.inProgress = false;
        tokensSnapshotState.pending = [];
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] onExit");
        }
        if (window.__tokensVisibilityHandler) {
          document.removeEventListener(
            "visibilitychange",
            window.__tokensVisibilityHandler
          );
          window.__tokensVisibilityHandler = null;
        }
      },
    };

    const savedSearch = window.sessionStorage.getItem("tokens.search");
    if (typeof savedSearch === "string") {
      tokensState.searchTerm = savedSearch;
    }
  }

  function getTokenByMint(mint) {
    if (!mint) return null;
    return allTokensData.find((token) => token?.mint === mint) || null;
  }

  async function fetchTokenDetail(mint) {
    try {
      const res = await fetch(`/api/tokens/${mint}`);
      if (!res.ok) throw new Error(`Token request failed (${res.status})`);
      const data = await res.json();
      return data;
    } catch (error) {
      console.error("Failed to fetch token detail:", error);
      Utils.showToast("‚ùå Failed to load token details", "error");
      return null;
    }
  }

  function renderSidebarBadges(token) {
    const badges = [];
    if (token?.has_pool_price)
      badges.push(
        '<span class="badge" style="background:#dbeafe;color:#1e40af;border:1px solid #bfdbfe;">POOL</span>'
      );
    if (token?.has_ohlcv)
      badges.push(
        '<span class="badge" style="background:#dcfce7;color:#166534;border:1px solid #bbf7d0;">OHLCV</span>'
      );
    if (token?.has_open_position)
      badges.push(
        '<span class="badge" style="background:#fde68a;color:#92400e;border:1px solid #fcd34d;">POS</span>'
      );
    if (token?.blacklisted)
      badges.push(
        '<span class="badge" style="background:#fee2e2;color:#991b1b;border:1px solid #fecaca;">BL</span>'
      );
    return badges.join(" ");
  }

  function renderRiskFactors(risks) {
    if (!Array.isArray(risks) || risks.length === 0) {
      return '<div style="color:#94a3b8;">No risk factors reported.</div>';
    }

    return risks
      .map((risk) => {
        const level = (risk.level || "").toUpperCase();
        const prefix = level ? `[${level}] ` : "";
        const title = risk.name || risk.title || "Risk factor";
        const description = risk.description || "‚Äî";
        return `
                        <div class="risk-item">
                            <div class="risk-item-title">${prefix}${title}</div>
                            <div class="risk-item-desc">${description}</div>
                        </div>
                    `;
      })
      .join("");
  }

  function populateTokenModal(token, detail) {
    if (!token) return;

    const detailData = detail || {};
    const price = Number.isFinite(detailData.price_sol)
      ? Number(detailData.price_sol)
      : Number(token.price_sol);
    const change24h = Number.isFinite(detailData.price_change_h24)
      ? Number(detailData.price_change_h24)
      : Number(token.price_change_h24);
    const changeCls =
      change24h > 0 ? "positive" : change24h < 0 ? "negative" : "";

    const logoEl = document.getElementById("modalTokenLogo");
    if (logoEl) {
      if (token.logo_url) {
        logoEl.src = token.logo_url;
        logoEl.style.display = "block";
      } else {
        logoEl.src = "";
        logoEl.style.display = "none";
      }
    }

    Utils.setText("modalTokenSymbol", token.symbol || detailData.symbol || "‚Äî");
    Utils.setText("modalTokenName", token.name || detailData.name || "‚Äî");
    Utils.setText(
      "modalTokenPrice",
      Number.isFinite(price)
        ? Utils.formatPriceSol(price, { fallback: "N/A" })
        : "‚Äî"
    );

    const changeEl = document.getElementById("modalTokenChange");
    if (changeEl) {
      changeEl.textContent = Number.isFinite(change24h)
        ? Utils.formatPercentValue(change24h, { fallback: "‚Äî" })
        : "‚Äî";
      changeEl.classList.remove("positive", "negative");
      if (changeCls) changeEl.classList.add(changeCls);
    }

    Utils.setText("detail-mint", detailData.mint || token.mint || "‚Äî");
    Utils.setText("detail-decimals", detailData.decimals ?? "‚Äî");
    Utils.setText(
      "detail-verified",
      Utils.formatBooleanFlag(detailData.verified, "‚Äî")
    );
    Utils.setText(
      "detail-blacklisted",
      Utils.formatBooleanFlag(detailData.blacklisted ?? token.blacklisted, "‚Äî")
    );
    Utils.setText("detail-launch-date", detailData.launch_date || "‚Äî");

    const liquidityValue = detailData.liquidity_usd ?? token.liquidity_usd;
    const volume24hValue = detailData.volume_24h ?? token.volume_24h;
    const volume6hValue = detailData.volume_6h ?? detailData.volume_h6;
    const volume1hValue = detailData.volume_1h ?? detailData.volume_h1;
    const fdvValue = detailData.fdv ?? token.fdv;
    const marketCapValue = detailData.market_cap ?? token.market_cap;

    Utils.setText(
      "detail-liquidity",
      Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume24h",
      Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume6h",
      Utils.formatCurrencyUSD(volume6hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume1h",
      Utils.formatCurrencyUSD(volume1hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-fdv",
      Utils.formatCurrencyUSD(fdvValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-marketcap",
      Utils.formatCurrencyUSD(marketCapValue, { fallback: "‚Äî" })
    );

    const dexLabel = detailData.pool_dex || detailData.pool?.dex;
    const poolAddress = detailData.pool_address || detailData.pool?.address;
    const solReserves =
      detailData.pool_reserves_sol ?? detailData.pool?.sol_reserves;
    const tokenReserves =
      detailData.pool_reserves_token ?? detailData.pool?.token_reserves;
    const confidence =
      detailData.price_confidence ?? detailData.pool?.confidence;
    const poolAge = detailData.pool_age || detailData.pool?.age;

    Utils.setText("detail-dex", dexLabel || "‚Äî");
    Utils.setText("detail-pool", poolAddress || "‚Äî");
    Utils.setText(
      "detail-sol-reserves",
      Utils.formatCompactNumber(solReserves, 2, "‚Äî")
    );
    Utils.setText(
      "detail-token-reserves",
      Utils.formatCompactNumber(tokenReserves, 2, "‚Äî")
    );
    Utils.setText(
      "detail-confidence",
      Number.isFinite(confidence) ? Number(confidence).toFixed(2) : "‚Äî"
    );
    Utils.setText("detail-pool-age", poolAge || "‚Äî");

    const change5m =
      detailData.price_change_m5 ?? detailData.price_changes?.change_5m;
    const change1h =
      detailData.price_change_h1 ??
      token.price_change_h1 ??
      detailData.price_changes?.change_1h;
    const change6h =
      detailData.price_change_h6 ?? detailData.price_changes?.change_6h;
    const change24hValue =
      detailData.price_change_h24 ??
      token.price_change_h24 ??
      detailData.price_changes?.change_24h;

    Utils.setText(
      "detail-change5m",
      change5m !== undefined
        ? Utils.formatPercentValue(change5m, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change1h",
      change1h !== undefined
        ? Utils.formatPercentValue(change1h, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change6h",
      change6h !== undefined
        ? Utils.formatPercentValue(change6h, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change24h",
      change24hValue !== undefined
        ? Utils.formatPercentValue(change24hValue, { fallback: "‚Äî" })
        : "‚Äî"
    );

    const buys24hRaw = detailData.txns?.h24?.buys ?? detailData.buys_24h;
    const sells24hRaw = detailData.txns?.h24?.sells ?? detailData.sells_24h;
    const buys24h = Number(buys24hRaw);
    const sells24h = Number(sells24hRaw);
    const hasBuys = Number.isFinite(buys24h);
    const hasSells = Number.isFinite(sells24h);
    const netFlow =
      hasBuys && hasSells ? buys24h - sells24h : Number(detailData.net_flow);
    const ratio =
      hasBuys && hasSells && sells24h !== 0
        ? buys24h / sells24h
        : Number(detailData.buy_sell_ratio);

    Utils.setText("detail-buys24h", hasBuys ? Math.round(buys24h) : "‚Äî");
    Utils.setText("detail-sells24h", hasSells ? Math.round(sells24h) : "‚Äî");
    Utils.setText(
      "detail-ratio",
      Number.isFinite(ratio) ? ratio.toFixed(2) : "‚Äî"
    );
    if (Number.isFinite(netFlow)) {
      const sign = netFlow > 0 ? "+" : netFlow < 0 ? "-" : "";
      Utils.setText(
        "detail-netflow",
        `${sign}${Math.abs(Math.round(netFlow))}`
      );
    } else {
      Utils.setText("detail-netflow", "‚Äî");
    }

    const securityScore = Number(detailData.security_score);
    const rugged = detailData.rugged;
    const badge = document.getElementById("security-badge");
    if (badge) {
      const statusClass =
        rugged === true
          ? "critical"
          : securityScore >= 700
          ? "excellent"
          : securityScore >= 500
          ? "good"
          : securityScore >= 300
          ? "warning"
          : "critical";
      badge.className = `security-badge ${statusClass}`.trim();
    }

    const progress = document.getElementById("security-progress");
    if (progress) {
      let pct = Number(detailData.security_score_normalized);
      if (!Number.isFinite(pct)) {
        pct = Number(detailData.security_score);
        if (Number.isFinite(pct)) {
          pct = Math.max(0, Math.min(100, pct / 10.0));
        }
      }
      if (!Number.isFinite(pct)) pct = 0;
      pct = Math.max(0, Math.min(100, pct));
      progress.style.width = `${pct}%`;
    }

    Utils.setHtml(
      "security-score-value",
      Number.isFinite(securityScore) ? `${securityScore}` : "‚Äî"
    );
    const securitySummary =
      detailData.security_summary ||
      (rugged
        ? "‚ö†Ô∏è Token flagged as rugged."
        : "No security summary available.");
    Utils.setHtml("security-status", securitySummary);
    Utils.setText("detail-mint-auth", detailData.mint_authority ?? "Unknown");
    Utils.setText(
      "detail-freeze-auth",
      detailData.freeze_authority ?? "Unknown"
    );
    Utils.setText("detail-holders", detailData.total_holders ?? "‚Äî");
    const top10Raw = detailData.top_10_concentration;
    if (top10Raw === null || top10Raw === undefined) {
      Utils.setText("detail-top10", "‚Äî");
    } else {
      const top10Num = Number(top10Raw);
      if (Number.isFinite(top10Num)) {
        const display = top10Num <= 1 ? top10Num * 100 : top10Num;
        Utils.setText("detail-top10", `${display.toFixed(2)}%`);
      } else {
        Utils.setText("detail-top10", `${top10Raw}`);
      }
    }
    Utils.setHtml(
      "risk-factors-list",
      renderRiskFactors(detailData.security_risks)
    );

    Utils.setText(
      "sidebar-price",
      Number.isFinite(price)
        ? Utils.formatPriceSol(price, { fallback: "N/A" })
        : "‚Äî"
    );
    Utils.setText(
      "sidebar-volume",
      Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "sidebar-liq",
      Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "sidebar-mcap",
      Utils.formatCurrencyUSD(marketCapValue, { fallback: "‚Äî" })
    );

    const statusFlags = {
      has_pool_price: detailData.has_pool_price ?? token.has_pool_price,
      has_ohlcv: detailData.has_ohlcv ?? token.has_ohlcv,
      has_open_position:
        detailData.has_open_position ?? token.has_open_position,
      blacklisted: detailData.blacklisted ?? token.blacklisted,
    };
    Utils.setHtml("sidebar-badges", renderSidebarBadges(statusFlags));

    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.add("active");
    } else {
      console.error("Modal element not found!");
    }
  }

  function resetTokenModal() {
    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.remove("active");
    }
    currentModalMint = null;
    tokenModalData = null;
  }

  async function openTokenModal(mint) {
    if (!mint) {
      console.warn("openTokenModal: no mint provided");
      return;
    }

    const cached = getTokenByMint(mint);
    if (!cached) {
      console.warn("openTokenModal: token not found in cache");
      Utils.showToast("‚ùå Token not found in cache", "error");
      return;
    }

    const detail = await fetchTokenDetail(mint);
    if (!detail) {
      console.warn("openTokenModal: failed to fetch token detail");
      return; // fetchTokenDetail already shows error toast
    }
    currentModalMint = mint;
    tokenModalData = { token: cached, detail };
    populateTokenModal(cached, detail);
  }

  function closeTokenModal(event) {
    if (event && event.target && event.target !== event.currentTarget) {
      return;
    }
    resetTokenModal();
  }

  function switchModalTab(tabId) {
    const content = document.querySelectorAll(".tab-pane");
    const tabs = document.querySelectorAll(".modal-tab");
    content.forEach((pane) => {
      pane.classList.toggle("active", pane.id === `tab-${tabId}`);
    });
    tabs.forEach((tab) => {
      tab.classList.toggle(
        "active",
        tab.textContent.includes(tabId.charAt(0).toUpperCase())
      );
    });
  }

  function copyMintFromModal() {
    if (!currentModalMint) return;
    Utils.copyMint(currentModalMint);
  }

  function openDexScreenerFromModal() {
    if (!currentModalMint) return;
    Utils.openDexScreener(currentModalMint);
  }

  function openGMGNFromModal() {
    if (!currentModalMint) return;
    Utils.openGMGN(currentModalMint);
  }

  function openSolscanFromModal() {
    if (!currentModalMint) return;
    Utils.openSolscan(currentModalMint);
  }

  function attachGlobalListeners() {
    if (!window.__tokensVisibilityHandler) {
      window.__tokensVisibilityHandler = handleVisibilityChange;
      document.addEventListener(
        "visibilitychange",
        window.__tokensVisibilityHandler
      );
    }
  }

  function handleVisibilityChange() {
    if (document.visibilityState === "visible") {
      requestTokensSnapshot("Refreshing after returning...");
    }
  }

  function initTokensSubTabs() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    subTabsContainer.innerHTML = TOKENS_VIEW_DEFS.map(function (view) {
      var isActive = view.id === tokensState.view;
      return (
        '<button class="sub-tab ' +
        (isActive ? "active" : "") +
        '" data-view="' +
        view.id +
        '">' +
        view.label +
        "</button>"
      );
    }).join("");

    subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
      button.addEventListener("click", () =>
        switchTokensSubTab(button.dataset.view)
      );
    });

    subTabsContainer.style.display = "flex";
  }

  function ensureTokensSubTabsVisible() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }

    const needsInit = subTabsContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(subTabsContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      subTabsContainer.style.display === "none";

    if (needsInit) {
      initTokensSubTabs();
    } else {
      subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
        button.classList.toggle(
          "active",
          button.dataset.view === tokensState.view
        );
      });
    }

    if (hidden) {
      subTabsContainer.style.display = "flex";
    }
  }

  function switchTokensSubTab(view) {
    var nextView = view;
    if (!nextView || !TOKENS_VIEWS.includes(nextView)) {
      console.warn("[Tokens] Unsupported sub-tab selection", nextView);
      nextView = DEFAULT_TOKENS_VIEW;
    }

    if (tokensState.view === nextView) {
      ensureTokensSubTabsVisible();
      return;
    }

    tokensState.view = nextView;
    window.sessionStorage.setItem("tokens.view", tokensState.view);

    document.querySelectorAll("#subTabsContainer .sub-tab").forEach((tab) => {
      tab.classList.toggle("active", tab.dataset.view === tokensState.view);
    });

    // If we have a cache for this view that matches current sort/search, render it immediately
    const cacheEntry = tokensViewCache[tokensState.view];
    if (
      cacheEntry &&
      cacheEntry.sortBy === tokensState.sortBy &&
      cacheEntry.sortDir === tokensState.sortDir &&
      (cacheEntry.searchTerm || "") === (tokensState.searchTerm || "") &&
      Array.isArray(cacheEntry.items) &&
      cacheEntry.items.length > 0
    ) {
      allTokensData = cacheEntry.items.slice();
      tokensSnapshotState.totalAvailable =
        Number(cacheEntry.total) || allTokensData.length;
      tokensSnapshotState.inProgress = false;
      tokensSnapshotState.pending = [];
      tokensSnapshotState.expected = 0;
      tokensSnapshotState.message = "";
      updateTokenCount(tokensSnapshotState.totalAvailable);
      const viewLabel = VIEW_LABELS[tokensState.view] || "";
      const status = viewLabel
        ? `Cached ‚Ä¢ ${tokensSnapshotState.totalAvailable} tokens ${viewLabel}`
        : `Cached ‚Ä¢ ${tokensSnapshotState.totalAvailable} tokens`;
      setTokenCountStatus(status);
      applySearchFilter();
    }

    if (
      cacheEntry &&
      (!Array.isArray(cacheEntry.items) || cacheEntry.items.length === 0) &&
      tokensState.searchTerm
    ) {
      const cleared = clearTokensSearch(
        "Search filter cleared for new tab ‚Äì showing all tokens."
      );
      if (cleared) {
        setTokenCountStatus(
          "üîç Search cleared for new view ‚Äì loading tokens..."
        );
      }
    }

    // Always request a fresh snapshot to keep cache up to date
    requestTokensSnapshot(`Switching to ${tokensState.view} view...`);
  }

  function ensureTokensToolbarVisible(options = {}) {
    const { updateStatus = true } = options;
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    const needsInit = toolbarContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(toolbarContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      toolbarContainer.style.display === "none";

    if (needsInit) {
      initTokensToolbar();
    } else {
      const searchInput = toolbarContainer.querySelector("#searchInput");
      if (searchInput) {
        searchInput.value = tokensState.searchTerm;
      }
    }

    if (hidden) {
      toolbarContainer.style.display = "flex";
    }

    if (!updateStatus) {
      return;
    }

    let statusMessage = null;
    if (tokensSnapshotState.inProgress && tokensSnapshotState.message) {
      statusMessage = tokensSnapshotState.message;
    } else {
      const totalAvailable = Number(tokensSnapshotState.totalAvailable) || 0;
      const total = totalAvailable || allTokensData.length;
      if (total > 0) {
        const viewLabel = VIEW_LABELS[tokensState.view] || "";
        statusMessage = viewLabel
          ? `${total} tokens ${viewLabel}`
          : `${total} tokens`;
      }
    }

    if (statusMessage) {
      setTokenCountStatus(statusMessage);
    }
  }

  function ensureTokensPageReady(options = {}) {
    ensureTokensSubTabsVisible();
    ensureTokensToolbarVisible(options);
  }

  window.ensureTokensPageReady = ensureTokensPageReady;

  function initTokensToolbar() {
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    toolbarContainer.innerHTML = `
                <input
                    type="text"
                    id="searchInput"
                    placeholder="Search by symbol or mint..."
                    style="flex: 1; max-width: 300px; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9em; background: var(--bg-primary); color: var(--text-primary);"
                >
                <div class="spacer"></div>
                <span id="tokenCount" style="color: var(--text-secondary); font-size: 0.9em; font-weight: 500;">Loading...</span>
                <button id="tokensRefreshBtn" class="btn btn-primary" style="padding: 6px 12px;">
                    üîÑ Refresh
                </button>
                <button id="tokensExportBtn" class="btn btn-secondary" style="padding: 6px 12px;">
                    üì• Export
                </button>
            `;
    toolbarContainer.style.display = "flex";

    const searchInput = toolbarContainer.querySelector("#searchInput");
    if (searchInput) {
      searchInput.value = tokensState.searchTerm;
      searchInput.addEventListener("input", handleSearchInput);
    }

    const refreshBtn = toolbarContainer.querySelector("#tokensRefreshBtn");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () =>
        requestTokensSnapshot("Refreshing tokens...")
      );
    }

    const exportBtn = toolbarContainer.querySelector("#tokensExportBtn");
    if (exportBtn) {
      exportBtn.addEventListener("click", exportTokens);
    }
  }

  function handleSearchInput(event) {
    tokensState.searchTerm = event.target.value.trim();
    window.sessionStorage.setItem("tokens.search", tokensState.searchTerm);

    applySearchFilter();

    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }
    searchDebounceHandle = setTimeout(() => {
      requestTokensSnapshot("Applying search filter...");
    }, 350);
  }

  function exportTokens() {
    alert("Export functionality - to be implemented");
  }

  function normalizeTokenFromApi(rawToken) {
    if (!rawToken || typeof rawToken !== "object") return rawToken;
    const token = { ...rawToken };

    if (token.price_updated_at) {
      const numericTimestamp = Number(token.price_updated_at);
      if (Number.isFinite(numericTimestamp)) {
        token.price_updated_at = numericTimestamp;
      } else {
        const parsed = Date.parse(token.price_updated_at);
        token.price_updated_at = Number.isFinite(parsed)
          ? Math.floor(parsed / 1000)
          : null;
      }
    } else {
      token.price_updated_at = null;
    }

    return token;
  }

  function dedupeTokensByMint(tokens) {
    if (!Array.isArray(tokens) || tokens.length === 0) {
      return [];
    }

    const seen = new Set();
    const deduped = [];

    for (const token of tokens) {
      if (!token || typeof token !== "object") continue;
      const mint = token.mint;
      if (!mint || seen.has(mint)) continue;
      seen.add(mint);
      deduped.push(token);
    }

    return deduped;
  }

  function showTokensError(message) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;
    tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #ef4444;">${message}</td></tr>`;
    setTokenCountStatus(message);
  }

  function updateTokenCount(total) {
    const label = document.getElementById("tokenCount");
    if (!label) return;

    const parsedTotal = Number(total);
    const totalValue = Number.isFinite(parsedTotal)
      ? parsedTotal
      : allTokensData.length;
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    label.textContent = viewLabel
      ? `${totalValue} tokens ${viewLabel}`
      : `${totalValue} tokens`;
  }

  function applySearchFilter() {
    const search = tokensState.searchTerm.toLowerCase();
    if (!search) {
      renderTokens(allTokensData);
      return;
    }

    const filtered = allTokensData.filter((token) => {
      const symbol = (token.symbol || "").toString().toLowerCase();
      const mint = (token.mint || "").toString().toLowerCase();
      const name = (token.name || "").toString().toLowerCase();
      return (
        symbol.includes(search) ||
        mint.includes(search) ||
        name.includes(search)
      );
    });

    renderTokens(filtered);
  }

  function clearTokensSearch(reason) {
    if (!tokensState.searchTerm) {
      return false;
    }

    if (window.__DEBUG_REALTIME) {
      console.log("[TokensDBG] clearing search filter", {
        reason,
        previous: tokensState.searchTerm,
      });
    }

    tokensState.searchTerm = "";
    try {
      window.sessionStorage.removeItem("tokens.search");
    } catch (_) {}

    const searchInput = document.querySelector("#searchInput");
    if (searchInput) {
      searchInput.value = "";
    }

    if (
      reason &&
      typeof Utils !== "undefined" &&
      typeof Utils.showToast === "function"
    ) {
      Utils.showToast(reason, "info");
    }

    return true;
  }

  function renderTokens(tokens) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;

    const openState = captureOpenDropdownState();

    if (!tokens || tokens.length === 0) {
      if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
        console.warn("[TokensDBG] renderTokens: empty data", {
          view: tokensState.view,
          search: tokensState.searchTerm,
          sortBy: tokensState.sortBy,
          sortDir: tokensState.sortDir,
          allTokensDataLen: Array.isArray(allTokensData)
            ? allTokensData.length
            : 0,
          totalAvailable: tokensSnapshotState.totalAvailable,
          expected: tokensSnapshotState.expected,
          inProgress: tokensSnapshotState.inProgress,
          began: tokensSnapshotState.began,
        });
      }

      let statusMessage = "No tokens available.";
      if (
        tokensState &&
        typeof tokensState.searchTerm === "string" &&
        tokensState.searchTerm.trim() !== ""
      ) {
        statusMessage = `No tokens match ‚Äú${tokensState.searchTerm.trim()}‚Äù in this view.`;
      } else if (tokensState.view === "pool") {
        statusMessage =
          "Pool service is warming up ‚Äî waiting for price-enabled tokens.";
      } else {
        const viewLabel = VIEW_LABELS[tokensState.view];
        if (viewLabel) {
          statusMessage = `No tokens ${viewLabel}.`;
        } else if (tokensState.view) {
          statusMessage = `No tokens available for view: ${tokensState.view}.`;
        }
      }

      setTokenCountStatus(statusMessage);
      const safeMessage = Utils.escapeHtml(statusMessage);
      tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #94a3b8;">${safeMessage}</td></tr>`;
      return;
    }

    if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] renderTokens: rendering rows", {
        count: tokens.length,
        view: tokensState.view,
      });
    }

    tbody.innerHTML = tokens.map(createTokenRowHtml).join("");
    restoreDropdownState(openState);
  }

  function captureOpenDropdownState() {
    const menu = document.querySelector(".dropdown-menu.show");
    if (!menu) return null;
    const row = menu.closest("tr[data-mint]");
    if (!row) return null;
    return { mint: row.dataset.mint };
  }

  function restoreDropdownState(state) {
    if (!state || !state.mint) return;
    const container = document.querySelector(
      `.dropdown-container[data-mint="${state.mint}"]`
    );
    if (!container) return;

    const btn = container.querySelector(".dropdown-btn");
    const menu = container.querySelector(".dropdown-menu");
    if (!btn || !menu) return;

    openDropdownMenu(btn, menu);
  }

  function setTokenCountStatus(text) {
    const label = document.getElementById("tokenCount");
    if (!label) return;
    label.textContent = text;
  }

  function showTokensLoading(message) {
    const tbody = document.getElementById("tokensTableBody");
    if (tbody) {
      tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #94a3b8;">${message}</td></tr>`;
    }
    setTokenCountStatus(message);
  }

  function clearTokensSnapshotTimer() {
    if (tokensSnapshotState.timeoutHandle) {
      if (window.__DEBUG_REALTIME) {
        console.log("[TokensDBG] clearSnapshotTimer");
      }
      clearTimeout(tokensSnapshotState.timeoutHandle);
      tokensSnapshotState.timeoutHandle = null;
    }
  }

  function scheduleTokensSnapshotTimer(reason) {
    clearTokensSnapshotTimer();

    if (
      !Number.isFinite(TOKENS_SNAPSHOT_TIMEOUT_MS) ||
      TOKENS_SNAPSHOT_TIMEOUT_MS <= 0
    ) {
      return;
    }

    if (window.__DEBUG_REALTIME) {
      console.log("[TokensDBG] scheduleSnapshotTimer", {
        reason,
        timeoutMs: TOKENS_SNAPSHOT_TIMEOUT_MS,
      });
    }

    tokensSnapshotState.timeoutHandle = setTimeout(() => {
      tokensSnapshotState.timeoutHandle = null;
      if (!tokensSnapshotState.inProgress) {
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] snapshot timer fired but not inProgress");
        }
        return;
      }

      console.warn(
        `[Tokens] Snapshot timeout (${reason || "unknown"}) ‚Äî checking state`
      );
      if (window.__DEBUG_REALTIME) {
        console.log("[TokensDBG] snapshot timeout", {
          pending: tokensSnapshotState.pending.length,
          expected: tokensSnapshotState.expected,
          totalAvailable: tokensSnapshotState.totalAvailable,
          wsConnected: window.Realtime?.isConnected?.() || false,
        });
      }

      if (tokensSnapshotState.pending.length > 0) {
        finalizeTokensSnapshot();
        return;
      }

      tokensSnapshotState.inProgress = false;
      tokensSnapshotState.message = "";
      tokensSnapshotState.retryCount =
        (tokensSnapshotState.retryCount || 0) + 1;

      // Check if WebSocket is connected before retrying
      const isConnected = window.Realtime?.isConnected?.() || false;
      if (!isConnected) {
        if (window.__DEBUG_REALTIME) {
          console.log(
            "[TokensDBG] WS disconnected, skipping retry ‚Üí will retry on reconnect"
          );
        }
        setTokenCountStatus("‚ö†Ô∏è Disconnected ‚Äì waiting for connection...");
        // Don't retry - let reconnect handler trigger refresh
        return;
      }

      setTokenCountStatus("‚ö†Ô∏è Snapshot delayed ‚Äì retrying...");

      // After 2 consecutive timeouts, fall back to HTTP list to avoid blank UI
      if (tokensSnapshotState.retryCount >= 2) {
        if (window.__DEBUG_REALTIME) {
          console.log("[TokensDBG] timeout fallback ‚Üí HTTP list");
        }
        fetchTokensListForCurrentFilters();
        return;
      }

      requestTokensSnapshot("Retrying snapshot after timeout...");
    }, TOKENS_SNAPSHOT_TIMEOUT_MS);
  }

  function requestTokensSnapshot(message) {
    if (window.__DEBUG_REALTIME) {
      console.log("[TokensDBG] requestSnapshot", {
        message,
        view: tokensState.view,
        sortBy: tokensState.sortBy,
        sortDir: tokensState.sortDir,
        search: tokensState.searchTerm,
      });
    }
    tokensSnapshotState.inProgress = true;
    tokensSnapshotState.pending = [];
    tokensSnapshotState.expected = 0;
    tokensSnapshotState.totalAvailable = 0;
    tokensSnapshotState.message = message || "Loading tokens...";
    tokensSnapshotState.retryCount = 0;
    tokensSnapshotState.began = false;
    tokensSnapshotState.currentView = null;
    tokensSnapshotState.searchAutoCleared = false;
    tokensSnapshotState.requestId = null;
    tokensSnapshotState.context = null;
    // If we already have something rendered, keep it visible and just update the status
    if (Array.isArray(allTokensData) && allTokensData.length > 0) {
      setTokenCountStatus(tokensSnapshotState.message);
    } else {
      showTokensLoading(tokensSnapshotState.message);
    }
    if (window.Realtime && typeof Realtime.updateFilters === "function") {
      scheduleTokensSnapshotTimer("request");
      const result =
        Realtime.updateFilters({
          snapshotTopics: ["tokens.update", "tokens"],
        }) || {};
      const requestId = result["tokens.update"] || result["tokens"] || null;
      if (requestId) {
        tokensSnapshotState.requestId = requestId;
      }
      return;
    }

    // Realtime unavailable - cancel timer and fallback to HTTP immediately
    if (tokensSnapshotState.timeoutHandle) {
      clearTimeout(tokensSnapshotState.timeoutHandle);
      tokensSnapshotState.timeoutHandle = null;
    }
    tokensSnapshotState.inProgress = false;

    console.warn(
      "[Tokens] Realtime controller unavailable; falling back to HTTP"
    );
    setTokenCountStatus("‚ö†Ô∏è Loading via HTTP...");
    fetchTokensListForCurrentFilters();
  }

  async function fetchTokensListForCurrentFilters() {
    try {
      const params = new URLSearchParams();
      params.set("view", tokensState.view);
      if (tokensState.searchTerm) params.set("search", tokensState.searchTerm);
      params.set("sort_by", tokensState.sortBy);
      params.set("sort_dir", tokensState.sortDir);
      params.set("page", "1");
      params.set("page_size", String(TOKENS_SNAPSHOT_LIMIT));

      const url = `/api/tokens/list?${params.toString()}`;
      if (window.__DEBUG_REALTIME) {
        console.log("[TokensDBG] HTTP fallback ‚Üí", url);
      }
      const res = await fetch(url, {
        headers: { "X-Requested-With": "fetch" },
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const body = await res.json();
      const items = Array.isArray(body.items)
        ? body.items.map(normalizeTokenFromApi)
        : [];
      allTokensData = dedupeTokensByMint(items);
      tokensSnapshotState.inProgress = false;
      tokensSnapshotState.pending = [];
      tokensSnapshotState.expected = 0;
      tokensSnapshotState.totalAvailable =
        Number(body.total) || allTokensData.length;
      tokensSnapshotState.message = "";

      updateTokenCount(tokensSnapshotState.totalAvailable);
      const viewLabel = VIEW_LABELS[tokensState.view] || "";
      const status = viewLabel
        ? `HTTP ‚Ä¢ ${tokensSnapshotState.totalAvailable} tokens ${viewLabel}`
        : `HTTP ‚Ä¢ ${tokensSnapshotState.totalAvailable} tokens`;
      setTokenCountStatus(status);
      // Save to cache
      tokensViewCache[tokensState.view] = {
        items: allTokensData.slice(),
        total: tokensSnapshotState.totalAvailable,
        sortBy: tokensState.sortBy,
        sortDir: tokensState.sortDir,
        searchTerm: tokensState.searchTerm || "",
        ts: Date.now(),
      };

      applySearchFilter();
    } catch (err) {
      console.warn("[Tokens] HTTP fallback failed", err);
      showTokensError("‚ùå Snapshot failed and fallback unavailable");
    }
  }

  function handleTokensSnapshotBegin(payload) {
    if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] snapshot_begin", {
        payload,
        view: tokensState.view,
        search: tokensState.searchTerm,
        sortBy: tokensState.sortBy,
        sortDir: tokensState.sortDir,
      });
    }
    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;
    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds["tokens.update"] ||
          realtime.lastSnapshotRequestIds["tokens"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      tokensSnapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
        console.warn("[TokensDBG] Ignoring stale snapshot_begin", {
          requestId,
          latestRequestId,
          stateRequestId: tokensSnapshotState.requestId,
        });
      }
      return;
    }

    if (requestId) {
      tokensSnapshotState.requestId = requestId;
    }
    tokensSnapshotState.context = context || null;
    tokensSnapshotState.inProgress = true;
    tokensSnapshotState.began = true;
    tokensSnapshotState.pending = [];
    const totalSelected =
      Number(context.total_selected ?? context.total ?? payload?.total) || 0;
    const totalAvailable =
      Number(context.total_available ?? totalSelected) || 0;
    tokensSnapshotState.expected = totalSelected;
    tokensSnapshotState.totalAvailable = totalAvailable;
    const reportedView =
      typeof context.view === "string" && context.view.length > 0
        ? context.view
        : null;
    tokensSnapshotState.currentView = reportedView;
    const message =
      tokensSnapshotState.message ||
      `Receiving snapshot (${tokensSnapshotState.expected} tokens)...`;
    showTokensLoading(message);
    scheduleTokensSnapshotTimer("begin");
  }

  function finalizeTokensSnapshot() {
    clearTokensSnapshotTimer();
    tokensSnapshotState.inProgress = false;
    tokensSnapshotState.began = false;
    const deduped = dedupeTokensByMint(tokensSnapshotState.pending);
    if (
      !tokensSnapshotState.searchAutoCleared &&
      tokensState.searchTerm &&
      tokensState.searchTerm.trim() !== "" &&
      deduped.length === 0
    ) {
      const cleared = clearTokensSearch(
        "Search filter cleared automatically ‚Äî no tokens matched this view."
      );
      if (cleared) {
        tokensSnapshotState.searchAutoCleared = true;
        tokensSnapshotState.pending = [];
        tokensSnapshotState.expected = 0;
        tokensSnapshotState.totalAvailable = 0;
        requestTokensSnapshot("Reloading after clearing search filter...");
        return;
      }
    }
    if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] finalizeSnapshot", {
        pendingBefore: tokensSnapshotState.pending.length,
        dedupedCount: deduped.length,
        expected: tokensSnapshotState.expected,
      });
    }
    tokensSnapshotState.pending = [];
    tokensSnapshotState.expected = 0;
    tokensSnapshotState.currentView = null;
    allTokensData = deduped;

    const total =
      tokensSnapshotState.totalAvailable ||
      allTokensData.length ||
      deduped.length;
    tokensSnapshotState.totalAvailable = total;
    tokensSnapshotState.message = "";
    updateTokenCount(total);

    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const status = viewLabel
      ? `Realtime ‚Ä¢ ${total} tokens ${viewLabel}`
      : `Realtime ‚Ä¢ ${total} tokens`;
    setTokenCountStatus(status);

    if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] snapshot_applied", {
        totalApplied: total,
        tableRendered: allTokensData.length,
        view: tokensState.view,
      });
    }

    // Save to per-view cache with current filters
    tokensViewCache[tokensState.view] = {
      items: allTokensData.slice(),
      total: total,
      sortBy: tokensState.sortBy,
      sortDir: tokensState.sortDir,
      searchTerm: tokensState.searchTerm || "",
      ts: Date.now(),
    };

    applySearchFilter();
  }

  function handleTokensSnapshotEnd(payload) {
    if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] snapshot_end", {
        payload,
        expected: tokensSnapshotState.expected,
        pending: tokensSnapshotState.pending.length,
      });
    }
    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;
    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds["tokens.update"] ||
          realtime.lastSnapshotRequestIds["tokens"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      tokensSnapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
        console.warn("[TokensDBG] Ignoring stale snapshot_end", {
          requestId,
          latestRequestId,
          stateRequestId: tokensSnapshotState.requestId,
        });
      }
      return;
    }

    if (
      requestId &&
      tokensSnapshotState.requestId &&
      requestId !== tokensSnapshotState.requestId
    ) {
      if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
        console.warn("[TokensDBG] snapshot_end request mismatch", {
          requestId,
          stateRequestId: tokensSnapshotState.requestId,
        });
      }
      return;
    }

    if (requestId) {
      tokensSnapshotState.requestId = requestId;
    }
    if (context && Object.keys(context).length > 0) {
      tokensSnapshotState.context = context;
    }
    tokensSnapshotState.inProgress = false;
    tokensSnapshotState.began = false;
    tokensSnapshotState.currentView = null;
    const sent = Number(
      context.total_selected ?? context.total ?? payload?.sent
    );
    if (Number.isFinite(sent)) {
      const availableFromContext = Number(
        typeof context.total_available === "number"
          ? context.total_available
          : tokensSnapshotState.totalAvailable
      );
      const normalizedAvailable = Number.isFinite(availableFromContext)
        ? availableFromContext
        : tokensSnapshotState.totalAvailable;
      tokensSnapshotState.totalAvailable = Math.max(
        tokensSnapshotState.totalAvailable,
        normalizedAvailable,
        sent
      );
    }
    const contextAvailable = Number(context.total_available);
    if (Number.isFinite(contextAvailable)) {
      tokensSnapshotState.totalAvailable = Math.max(
        tokensSnapshotState.totalAvailable,
        contextAvailable
      );
    }
    clearTokensSnapshotTimer();
    finalizeTokensSnapshot();
  }

  function handleTokensRealtime(data, envelope) {
    if (!data || typeof data !== "object") return;
    const meta = envelope?.meta || {};
    const isSnapshot = meta.snapshot === true;
    const updateType = meta?.update;

    if (typeof meta.total === "number") {
      tokensSnapshotState.totalAvailable = Math.max(
        tokensSnapshotState.totalAvailable,
        Number(meta.total)
      );
    }

    if (isSnapshot) {
      const chunkRequestId =
        meta?.extra?.request_id ||
        meta?.extra?.requestId ||
        meta?.request_id ||
        meta?.requestId ||
        null;
      if (
        tokensSnapshotState.requestId &&
        chunkRequestId &&
        chunkRequestId !== tokensSnapshotState.requestId
      ) {
        if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
          console.warn(
            "[TokensDBG] Ignoring snapshot chunk for stale request",
            {
              chunkRequestId,
              stateRequestId: tokensSnapshotState.requestId,
            }
          );
        }
        return;
      }
      if (!tokensSnapshotState.began) {
        if (window.__DEBUG_REALTIME) {
          console.warn("[TokensDBG] Ignoring snapshot chunk before begin", {
            meta,
          });
        }
        return;
      }
      // Optional: if server includes the view in meta, ensure it matches current UI view
      const snapshotView =
        envelope?.meta?.view || envelope?.meta?.extra?.view || envelope?.view;
      if (snapshotView && !tokensSnapshotState.currentView) {
        tokensSnapshotState.currentView = snapshotView;
      }
      const effectiveView = tokensSnapshotState.currentView || snapshotView;
      if (effectiveView && effectiveView !== tokensState.view) {
        console.warn(
          "[Tokens] Dropping snapshot chunk for different view",
          effectiveView,
          "!=",
          tokensState.view
        );
        return;
      }
      const normalized = normalizeTokenFromApi({ ...data });
      tokensSnapshotState.pending.push(normalized);
      scheduleTokensSnapshotTimer("chunk");
      return;
    }

    if (
      tokensSnapshotState.inProgress &&
      tokensSnapshotState.pending.length > 0
    ) {
      console.debug(
        "[Tokens] Completing snapshot from realtime delta (missing snapshot_end)"
      );
      if (window.__DEBUG_REALTIME || window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] complete_from_delta", {
          pending: tokensSnapshotState.pending.length,
          expected: tokensSnapshotState.expected,
        });
      }
      finalizeTokensSnapshot();
    }

    if (updateType === "removed" || data.removed === true) {
      if (typeof data.mint === "string") {
        handleTokenRemoval(data.mint);
      }
      return;
    }

    if (
      updateType === "summary" ||
      (typeof data.mint === "string" &&
        (typeof data.symbol === "string" || typeof data.name === "string"))
    ) {
      const normalized = normalizeTokenFromApi({ ...data });
      handleTokenSummaryDelta(normalized);
      return;
    }

    if (data.price_result) {
      handlePriceUpdate(data);
    }
  }

  function handleTokenSummaryDelta(summary) {
    if (!summary || typeof summary !== "object" || !summary.mint) return;

    const existingIndex = allTokensData.findIndex(
      (token) => token.mint === summary.mint
    );
    const prev =
      existingIndex >= 0 ? { ...allTokensData[existingIndex] } : null;

    if (existingIndex >= 0) {
      allTokensData[existingIndex] = {
        ...allTokensData[existingIndex],
        ...summary,
      };
    } else {
      // Avoid cross-tab pollution: only auto-insert unknown tokens in 'all' view
      // For other views, wait for next snapshot/refresh unless we can strongly infer membership
      const v = tokensState.view;
      let shouldInsert = false;
      if (v === "all") shouldInsert = true;
      else if (v === "pool" && summary.has_pool_price === true)
        shouldInsert = true;
      else if (v === "blacklisted" && summary.blacklisted === true)
        shouldInsert = true;
      else if (v === "positions" && summary.has_open_position === true)
        shouldInsert = true;
      // conservative for other views (passed/rejected/secure/recent): skip insert to prevent wrong-tab entries

      if (shouldInsert) {
        allTokensData.unshift(summary);
      } else {
        // Ignore for now; will appear on next snapshot for this view
        return;
      }
    }

    const total = allTokensData.length;
    tokensSnapshotState.totalAvailable = total;
    updateTokenCount(total);
    const sortKey = tokensState.sortBy;
    const curr = existingIndex >= 0 ? allTokensData[existingIndex] : summary;
    const sortChanged =
      prev && sortKey in curr && prev[sortKey] !== curr[sortKey];
    if (!prev || sortChanged) {
      applySearchFilter();
    } else {
      updateTokenRow(summary.mint, curr);
    }
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const status = viewLabel
      ? `Realtime ‚Ä¢ ${total} tokens ${viewLabel}`
      : `Realtime ‚Ä¢ ${total} tokens`;
    setTokenCountStatus(status);
  }

  function updateTokenRow(mint, token) {
    const row = document.querySelector(`tr[data-mint="${mint}"]`);
    if (!row) return;
    try {
      const priceCell = row.cells?.[1];
      const liqCell = row.cells?.[2];
      const vol24hCell = row.cells?.[3];
      const fdvCell = row.cells?.[4];
      const mcapCell = row.cells?.[5];
      const ch1hCell = row.cells?.[6];
      const ch24hCell = row.cells?.[7];
      const secCell = row.cells?.[8];
      const statusCell = row.cells?.[9];
      const timeCell = row.cells?.[10];

      if (priceCell) {
        const val = Utils.formatPriceSol(token.price_sol, { fallback: "N/A" });
        if (priceCell.innerHTML !== val) {
          priceCell.innerHTML = val;
          priceCell.style.animation = "highlight 0.6s ease-out";
          setTimeout(() => (priceCell.style.animation = ""), 600);
        }
      }
      if (liqCell) {
        const val = Utils.formatCurrencyUSD(token.liquidity_usd, {
          fallback: "‚Äî",
        });
        if (liqCell.innerHTML !== val) liqCell.innerHTML = val;
      }
      if (vol24hCell) {
        const val = Utils.formatCurrencyUSD(token.volume_24h, {
          fallback: "‚Äî",
        });
        if (vol24hCell.innerHTML !== val) vol24hCell.innerHTML = val;
      }
      if (fdvCell) {
        const val = Utils.formatCurrencyUSD(token.fdv, { fallback: "‚Äî" });
        if (fdvCell.innerHTML !== val) fdvCell.innerHTML = val;
      }
      if (mcapCell) {
        const val = Utils.formatCurrencyUSD(token.market_cap, {
          fallback: "‚Äî",
        });
        if (mcapCell.innerHTML !== val) mcapCell.innerHTML = val;
      }
      if (ch1hCell) {
        const val = Utils.formatPercent(token.price_change_h1, {
          style: "token",
          fallback: "‚Äî",
        });
        if (ch1hCell.innerHTML !== val) ch1hCell.innerHTML = val;
      }
      if (ch24hCell) {
        const val = Utils.formatPercent(token.price_change_h24, {
          style: "token",
          fallback: "‚Äî",
        });
        if (ch24hCell.innerHTML !== val) ch24hCell.innerHTML = val;
      }
      if (secCell) {
        const val = renderSecurity(token.security_score, token.rugged);
        if (secCell.innerHTML !== val) secCell.innerHTML = val;
      }
      if (statusCell) {
        const val = renderStatusBadges(token);
        if (statusCell.innerHTML !== val) statusCell.innerHTML = val;
      }
      if (timeCell) {
        const ts = token.price_updated_at;
        const val = ts ? Utils.formatTimeAgo(ts, { fallback: "-" }) : "N/A";
        if (timeCell.textContent !== val) timeCell.textContent = val;
      }
    } catch (e) {
      console.debug("[Tokens] Row patch failed; re-rendering list", e);
      applySearchFilter();
    }
  }

  function handleTokenRemoval(mint) {
    if (!mint) return;
    const index = allTokensData.findIndex((token) => token.mint === mint);
    if (index === -1) return;

    allTokensData.splice(index, 1);
    const total = allTokensData.length;
    tokensSnapshotState.totalAvailable = total;
    updateTokenCount(total);
    applySearchFilter();
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const status = viewLabel
      ? `Realtime ‚Ä¢ ${total} tokens ${viewLabel}`
      : `Realtime ‚Ä¢ ${total} tokens`;
    setTokenCountStatus(status);
  }

  function handleTokensWarning(payload) {
    if (!payload) return;
    clearTokensSnapshotTimer();
    const topic = payload.topic || payload.alias;
    if (topic !== "tokens.update" && topic !== "tokens") return;

    const recommendation = payload.recommendation || payload.action;
    setTokenCountStatus("‚ö†Ô∏è Realtime warning ‚Äì resyncing...");

    requestTokensSnapshot("Resyncing after warning...");
  }

  function handleTokensDisconnect() {
    clearTokensSnapshotTimer();
    setTokenCountStatus("‚ö†Ô∏è Realtime disconnected ‚Äì waiting for reconnection");
  }

  function handleTokensReconnect() {
    clearTokensSnapshotTimer();
    setTokenCountStatus("üîå Reconnected ‚Äì refreshing tokens...");
    requestTokensSnapshot("Resyncing after reconnect...");
  }

  function createTokenRowHtml(token) {
    const mint = token.mint;
    const symbol = Utils.escapeHtml(token.symbol || "");
    const name = token.name ? Utils.escapeHtml(token.name) : "";
    const timeAgo = token.price_updated_at
      ? Utils.formatTimeAgo(token.price_updated_at, { fallback: "-" })
      : "N/A";
    const priceDisplay = Utils.formatPriceSol(token.price_sol, {
      fallback: "N/A",
    });
    const liquidity = Utils.formatCurrencyUSD(token.liquidity_usd, {
      fallback: "‚Äî",
    });
    const vol24h = Utils.formatCurrencyUSD(token.volume_24h, { fallback: "‚Äî" });
    const fdv = Utils.formatCurrencyUSD(token.fdv, { fallback: "‚Äî" });
    const marketCap = Utils.formatCurrencyUSD(token.market_cap, {
      fallback: "‚Äî",
    });
    const ch1h = Utils.formatPercent(token.price_change_h1, {
      style: "token",
      fallback: "‚Äî",
    });
    const ch24h = Utils.formatPercent(token.price_change_h24, {
      style: "token",
      fallback: "‚Äî",
    });
    const security = renderSecurity(token.security_score, token.rugged);
    const status = renderStatusBadges(token);
    const logo = safeLogoHtml(token.logo_url, token.symbol);

    return `
                <tr data-mint="${mint}" onclick="openTokenDetail('${mint}')" style="cursor:pointer;" title="Click to view details">
                    <td>
                        <div style="display:flex; align-items:center; gap:12px; min-width:0;">
                            ${logo}
                            <div style="display:flex; flex-direction:column; gap:1px; min-width:0;">
                                <div style="font-weight:600; color:var(--link-color); font-size:0.95em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${symbol}</div>
                                <div style="font-size:0.8em; color:#94a3b8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${name}</div>
                            </div>
                        </div>
                    </td>
                    <td class="num" style="font-weight:600;" title="${
                      token.price_sol ?? ""
                    }">${priceDisplay}</td>
                    <td class="num" title="${
                      token.liquidity_usd ?? ""
                    }">${liquidity}</td>
                    <td class="num" title="${
                      token.volume_24h ?? ""
                    }">${vol24h}</td>
                    <td class="num" title="${token.fdv ?? ""}">${fdv}</td>
                    <td class="num" title="${
                      token.market_cap ?? ""
                    }">${marketCap}</td>
                    <td class="num" title="${
                      token.price_change_h1 ?? ""
                    }">${ch1h}</td>
                    <td class="num" title="${
                      token.price_change_h24 ?? ""
                    }">${ch24h}</td>
                    <td class="num" title="${
                      token.security_score ?? ""
                    }">${security}</td>
                    <td>${status}</td>
                    <td style="font-size: 0.85em; color: #64748b;">${timeAgo}</td>
                    <td onclick="event.stopPropagation();">
                        <div class="dropdown-container" data-mint="${mint}">
                            <button class="dropdown-btn" type="button" onclick="Utils.toggleDropdown(event)" aria-label="Actions">‚ãÆ</button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyMint('${mint}')" class="dropdown-item">üìã Copy Mint</button>
                                <button onclick="Utils.openGMGN('${mint}')" class="dropdown-item">üîó Open GMGN</button>
                                <button onclick="Utils.openDexScreener('${mint}')" class="dropdown-item">üìä Open DexScreener</button>
                                <button onclick="Utils.openSolscan('${mint}')" class="dropdown-item">üîç Open Solscan</button>
                                <button onclick="openTokenDetail('${mint}')" class="dropdown-item">üîé View Details</button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function openDropdownMenu(btn, menu) {
    const rect = btn.getBoundingClientRect();
    const menuWidth = Math.max(200, menu.offsetWidth || 200);
    const viewportWidth = window.innerWidth;
    const rightSpace = viewportWidth - rect.right;

    menu.classList.add("show");
    menu.style.position = "fixed";
    menu.style.top = `${Math.round(rect.bottom + 4)}px`;
    if (rightSpace < menuWidth) {
      menu.style.left = `${Math.max(8, Math.round(rect.right - menuWidth))}px`;
      menu.style.right = "";
    } else {
      menu.style.left = `${Math.round(rect.left)}px`;
      menu.style.right = "";
    }
    menu.style.width = `${menuWidth}px`;
  }

  function setupSortableHeaders() {
    const thead = document.querySelector("#tokensTable thead");
    if (!thead) return;
    if (window.__tokensSortHeadersSetup) return;
    thead.addEventListener("click", (e) => {
      const th = e.target.closest("th.sortable");
      if (!th) return;
      const key = th.getAttribute("data-sort-key");
      if (!key) return;
      if (tokensState.sortBy === key) {
        tokensState.sortDir = tokensState.sortDir === "asc" ? "desc" : "asc";
      } else {
        tokensState.sortBy = key;
        tokensState.sortDir = key === "symbol" ? "asc" : "desc";
      }
      updateSortIndicators();
      requestTokensSnapshot("Sorting tokens...");
    });
    updateSortIndicators();
    window.__tokensSortHeadersSetup = true;
  }

  function updateSortIndicators() {
    const indicators = document.querySelectorAll(
      "#tokensTable .sort-indicator"
    );
    indicators.forEach((el) => {
      el.textContent = "";
    });
    const id = `sort-indicator-${tokensState.sortBy}`;
    const el = document.getElementById(id);
    if (el) el.textContent = tokensState.sortDir === "asc" ? "‚ñ≤" : "‚ñº";
  }

  function safeLogoHtml(url, symbol) {
    let fallback = "?";
    if (symbol && typeof symbol === "string") {
      for (const ch of symbol) {
        const u = ch.toUpperCase();
        if (/^[A-Z0-9]$/.test(u)) {
          fallback = u;
          break;
        }
      }
    }
    if (!url) {
      return `<div style="width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg, #1565c0 0%, #0f4c81 100%);color:white;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:0.85em;flex-shrink:0;">${fallback}</div>`;
    }
    const esc = (s) =>
      (s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    return `<img src="${esc(url)}" alt="${esc(
      symbol || ""
    )}" width="32" height="32" style="border-radius:8px;object-fit:cover;flex-shrink:0;box-shadow:0 1px 3px rgba(0,0,0,0.1);" onerror="fallbackLogo(this, '${fallback}')">`;
  }

  function fallbackLogo(img, letter) {
    try {
      img.onerror = null;
      const div = document.createElement("div");
      div.style.width = "32px";
      div.style.height = "32px";
      div.style.borderRadius = "8px";
      div.style.background =
        "linear-gradient(135deg, #1565c0 0%, #0f4c81 100%)";
      div.style.color = "white";
      div.style.display = "flex";
      div.style.alignItems = "center";
      div.style.justifyContent = "center";
      div.style.fontWeight = "700";
      div.style.fontSize = "0.85em";
      div.style.flexShrink = "0";
      div.textContent = letter && /^[A-Z0-9]$/.test(letter) ? letter : "?";
      img.replaceWith(div);
    } catch (_) {
      /* no-op */
    }
  }

  function renderSecurity(score, rugged) {
    if (rugged === true) {
      return `<span class="badge" style="background:#fee2e2;color:#b91c1c;border:1px solid #fecaca;">RUG</span>`;
    }
    if (score === null || score === undefined) return "‚Äî";
    let color = "#64748b";
    if (score >= 700) color = "#16a34a";
    else if (score >= 500) color = "#22c55e";
    else if (score >= 300) color = "#f59e0b";
    else color = "#ef4444";
    return `<span style="font-weight:600;color:${color}">${score}</span>`;
  }

  function renderStatusBadges(token) {
    const badges = [];
    if (token.has_pool_price)
      badges.push(
        '<span class="badge" style="background:#dbeafe;color:#1e40af;border:1px solid #bfdbfe;">POOL</span>'
      );
    if (token.has_ohlcv)
      badges.push(
        '<span class="badge" style="background:#dcfce7;color:#166534;border:1px solid #bbf7d0;">OHLCV</span>'
      );
    if (token.has_open_position)
      badges.push(
        '<span class="badge" style="background:#fde68a;color:#92400e;border:1px solid #fcd34d;">POS</span>'
      );
    if (token.blacklisted)
      badges.push(
        '<span class="badge" style="background:#fee2e2;color:#991b1b;border:1px solid #fecaca;">BL</span>'
      );
    return badges.join(" ");
  }

  function openTokenDetail(mint) {
    if (!mint) return;
    openTokenModal(mint).catch((err) => {
      console.error("Failed to open token modal:", err);
      Utils.showToast("‚ùå Failed to open token details", "error");
    });
  }
</script>

<div class="page-section">
  <div class="table-scroll no-x-scroll">
    <table class="table sticky-table" id="tokensTable">
      <thead>
        <tr>
          <th class="sortable" data-sort-key="symbol">
            <span class="sort-label"
              >Token
              <span class="sort-indicator" id="sort-indicator-symbol"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_sol">
            <span class="sort-label"
              >Price (SOL)
              <span class="sort-indicator" id="sort-indicator-price_sol"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="liquidity_usd">
            <span class="sort-label"
              >Liquidity
              <span
                class="sort-indicator"
                id="sort-indicator-liquidity_usd"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="volume_24h">
            <span class="sort-label"
              >24h Vol
              <span class="sort-indicator" id="sort-indicator-volume_24h"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="fdv">
            <span class="sort-label"
              >FDV <span class="sort-indicator" id="sort-indicator-fdv"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="market_cap">
            <span class="sort-label"
              >Mkt Cap
              <span class="sort-indicator" id="sort-indicator-market_cap"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_change_h1">
            <span class="sort-label"
              >1h
              <span
                class="sort-indicator"
                id="sort-indicator-price_change_h1"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_change_h24">
            <span class="sort-label"
              >24h
              <span
                class="sort-indicator"
                id="sort-indicator-price_change_h24"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="security_score">
            <span class="sort-label"
              >Security
              <span
                class="sort-indicator"
                id="sort-indicator-security_score"
              ></span
            ></span>
          </th>
          <th>Status</th>
          <th class="sortable" data-sort-key="updated_at">
            <span class="sort-label"
              >Updated
              <span class="sort-indicator" id="sort-indicator-updated_at"></span
            ></span>
          </th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="tokensTableBody">
        <tr>
          <td
            colspan="4"
            style="text-align: center; padding: 20px; color: #94a3b8"
          >
            <div class="loading-text">Loading tokens...</div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<!-- Token Details Modal -->
<div
  class="token-modal-overlay"
  id="tokenModal"
  onclick="closeTokenModal(event)"
>
  <div class="token-modal" onclick="event.stopPropagation()">
    <!-- Modal Header -->
    <div class="modal-header">
      <div class="modal-header-left">
        <img id="modalTokenLogo" class="modal-token-logo" src="" alt="" />
        <div class="modal-token-info">
          <div class="modal-token-symbol" id="modalTokenSymbol">SONIC</div>
          <div class="modal-token-name" id="modalTokenName">Sonic SVM</div>
        </div>
      </div>
      <div class="modal-price-info">
        <div class="modal-price" id="modalTokenPrice">0.00077622</div>
        <div class="modal-price-change positive" id="modalTokenChange">
          +2.12%
        </div>
      </div>
      <button
        class="modal-close-btn"
        onclick="closeTokenModal()"
        title="Close (ESC)"
      >
        √ó
      </button>
    </div>

    <!-- Modal Body -->
    <div class="modal-body token-detail-body">
      <!-- Main Content Area -->
      <div class="modal-main">
        <!-- Tabs Navigation -->
        <div class="modal-tabs">
          <button class="modal-tab active" onclick="switchModalTab('overview')">
            üìä Overview
          </button>
          <button class="modal-tab" onclick="switchModalTab('security')">
            üõ°Ô∏è Security
          </button>
          <button class="modal-tab" onclick="switchModalTab('chart')">
            üìà Chart
          </button>
          <button class="modal-tab" onclick="switchModalTab('transactions')">
            üí± Transactions
          </button>
        </div>

        <!-- Tab Content -->
        <div class="modal-content">
          <!-- Overview Tab -->
          <div class="tab-pane active" id="tab-overview">
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-card-header">üßæ Token Profile</div>
                <div class="metric-row" title="Full mint address">
                  <span class="metric-label">Mint</span>
                  <span
                    class="metric-value"
                    id="detail-mint"
                    style="
                      font-size: 0.75em;
                      letter-spacing: 0.3px;
                      overflow: hidden;
                      text-overflow: ellipsis;
                      max-width: 160px;
                    "
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Decimals</span>
                  <span class="metric-value" id="detail-decimals">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Verified</span>
                  <span class="metric-value" id="detail-verified">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Blacklisted</span>
                  <span class="metric-value" id="detail-blacklisted">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Launch</span>
                  <span class="metric-value" id="detail-launch-date">‚Äî</span>
                </div>
              </div>
              <div class="metric-card">
                <div class="metric-card-header">üí∞ Market Data</div>
                <div class="metric-row">
                  <span class="metric-label">Liquidity</span>
                  <span class="metric-value" id="detail-liquidity"
                    >$628.66K</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 24h</span>
                  <span class="metric-value" id="detail-volume24h"
                    >$124.32K</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 6h</span>
                  <span class="metric-value" id="detail-volume6h">$45.67K</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 1h</span>
                  <span class="metric-value" id="detail-volume1h">$12.45K</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">FDV</span>
                  <span class="metric-value" id="detail-fdv">$432.41M</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Market Cap</span>
                  <span class="metric-value" id="detail-marketcap"
                    >$64.86M</span
                  >
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üèä Pool Metrics</div>
                <div class="metric-row">
                  <span class="metric-label">DEX</span>
                  <span class="metric-value" id="detail-dex">Raydium CPMM</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Pool Address</span>
                  <span
                    class="metric-value"
                    id="detail-pool"
                    style="font-size: 0.75em"
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">SOL Reserves</span>
                  <span class="metric-value" id="detail-sol-reserves"
                    >3,241.5</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Token Reserves</span>
                  <span class="metric-value" id="detail-token-reserves"
                    >84.2M</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Confidence</span>
                  <span class="metric-value" id="detail-confidence">0.95</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Pool Age</span>
                  <span class="metric-value" id="detail-pool-age">2h 15m</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üìä Price Changes</div>
                <div class="metric-row">
                  <span class="metric-label">5 minutes</span>
                  <span class="metric-value" id="detail-change5m">+2.5%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">1 hour</span>
                  <span class="metric-value" id="detail-change1h">-1.2%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">6 hours</span>
                  <span class="metric-value" id="detail-change6h">+5.8%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">24 hours</span>
                  <span class="metric-value" id="detail-change24h">+15.3%</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üí± Transaction Flow</div>
                <div class="metric-row">
                  <span class="metric-label">Buys 24h</span>
                  <span class="metric-value" id="detail-buys24h">432</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Sells 24h</span>
                  <span class="metric-value" id="detail-sells24h">389</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Buy/Sell Ratio</span>
                  <span class="metric-value" id="detail-ratio">1.11</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Net Flow</span>
                  <span class="metric-value" id="detail-netflow">+43 Buys</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Security Tab -->
          <div class="tab-pane" id="tab-security">
            <div class="security-badge excellent" id="security-badge">
              <span>üõ°Ô∏è</span>
              <span
                >Security Score: <span id="security-score-value">35593</span> /
                40000</span
              >
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">Overall Security Analysis</div>
              <div class="progress-bar">
                <div
                  class="progress-fill"
                  id="security-progress"
                  style="width: 89%"
                ></div>
              </div>
              <div
                style="margin-top: 12px; color: #94a3b8; font-size: 0.9em"
                id="security-status"
              >
                ‚úÖ This token passes major security checks
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üîë Token Authorities</div>
              <div class="metric-row">
                <span class="metric-label">Mint Authority</span>
                <span
                  class="metric-value"
                  id="detail-mint-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
              <div class="metric-row">
                <span class="metric-label">Freeze Authority</span>
                <span
                  class="metric-value"
                  id="detail-freeze-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üë• Holder Distribution</div>
              <div class="metric-row">
                <span class="metric-label">Total Holders</span>
                <span class="metric-value" id="detail-holders">1,234</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Top 10 Concentration</span>
                <span class="metric-value" id="detail-top10">45.2%</span>
              </div>
            </div>

            <div class="metric-card-header" style="margin-bottom: 12px">
              ‚ö†Ô∏è Risk Factors
            </div>
            <div class="risk-list" id="risk-factors-list">
              <!-- Risk items will be populated here -->
            </div>
          </div>

          <!-- Chart Tab -->
          <div class="tab-pane" id="tab-chart">
            <div
              id="token-chart-container"
              style="
                height: 500px;
                width: 100%;
                position: relative;
                background: #1a1a1a;
                border-radius: 8px;
                overflow: hidden;
              "
            >
              <div id="token-chart" style="width: 100%; height: 100%"></div>
              <div id="chart-loading" class="chart-loading">
                <div class="spinner"></div>
                <p>Loading chart data...</p>
              </div>
              <div id="chart-error" class="chart-error" style="display: none">
                <p>Failed to load chart data</p>
                <button onclick="retryChartLoad()">Retry</button>
              </div>
            </div>

            <!-- Chart Controls -->
            <div class="chart-controls">
              <div class="timeframe-selector">
                <button class="tf-btn active" data-tf="1m">1m</button>
                <button class="tf-btn" data-tf="5m">5m</button>
                <button class="tf-btn" data-tf="15m">15m</button>
                <button class="tf-btn" data-tf="1h">1h</button>
                <button class="tf-btn" data-tf="4h">4h</button>
                <button class="tf-btn" data-tf="1d">1D</button>
              </div>

              <div class="indicator-toggles">
                <label
                  ><input type="checkbox" id="show-volume" checked />
                  Volume</label
                >
                <label><input type="checkbox" id="show-ma20" /> MA(20)</label>
                <label><input type="checkbox" id="show-ma50" /> MA(50)</label>
              </div>
            </div>
          </div>

          <!-- Transactions Tab -->
          <div class="tab-pane" id="tab-transactions">
            <div class="metric-card">
              <div class="metric-card-header">üìú Recent Transactions</div>
              <div
                id="transactions-list"
                style="color: #94a3b8; text-align: center; padding: 40px"
              >
                Loading recent transactions...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="modal-sidebar">
        <div class="sidebar-section">
          <div class="sidebar-section-title">‚ö° Live Metrics</div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Price (SOL)</span>
            <span class="sidebar-metric-value" id="sidebar-price"
              >0.00077622</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">24h Volume</span>
            <span class="sidebar-metric-value" id="sidebar-volume"
              >$124.3K</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Liquidity</span>
            <span class="sidebar-metric-value" id="sidebar-liq">$628.7K</span>
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Market Cap</span>
            <span class="sidebar-metric-value" id="sidebar-mcap">$64.86M</span>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üîó Quick Actions</div>
          <div class="quick-actions">
            <button
              class="quick-action-btn"
              id="action-copy-mint"
              onclick="copyMintFromModal()"
            >
              üìã Copy Mint Address
            </button>
            <button
              class="quick-action-btn"
              id="action-dexscreener"
              onclick="openDexScreenerFromModal()"
            >
              üìä Open DexScreener ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-gmgn"
              onclick="openGMGNFromModal()"
            >
              üîó Open GMGN ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-solscan"
              onclick="openSolscanFromModal()"
            >
              üîç Open Solscan ‚Üí
            </button>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üè∑Ô∏è Status Flags</div>
          <div
            id="sidebar-badges"
            style="display: flex; flex-wrap: wrap; gap: 6px"
          >
            <!-- Badges will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // ====================================================================
  // WebSocket real-time price updates
  // ====================================================================

  function handlePriceUpdate(message) {
    if (!message || typeof message !== "object") return;
    const { mint, price_result: priceResult, timestamp } = message;
    if (!mint || !priceResult || typeof priceResult !== "object") return;

    const tokenInList = allTokensData.find((t) => t.mint === mint);
    const updatedPriceSol = Number(priceResult.price_sol);
    const updatedPriceUsd = Number(priceResult.price_usd);
    const updatedTimestamp = (() => {
      if (Number.isFinite(priceResult.timestamp))
        return Number(priceResult.timestamp);
      if (typeof timestamp === "string") {
        const parsed = Date.parse(timestamp);
        if (Number.isFinite(parsed)) return Math.floor(parsed / 1000);
      }
      return null;
    })();

    if (tokenInList) {
      if (Number.isFinite(updatedPriceSol)) {
        tokenInList.price_sol = updatedPriceSol;
      }
      if (Number.isFinite(updatedPriceUsd)) {
        tokenInList.price_usd = updatedPriceUsd;
      }
      if (updatedTimestamp !== null) {
        tokenInList.price_updated_at = updatedTimestamp;
      }

      const row = document.querySelector(`tr[data-mint="${mint}"]`);
      if (row) {
        const priceCell = row.cells?.[1];
        const liquidityCell = row.cells?.[2];
        const timeCell = row.cells?.[10];

        if (priceCell && Number.isFinite(updatedPriceSol)) {
          priceCell.innerHTML = Utils.formatPriceSol(updatedPriceSol, {
            fallback: "N/A",
          });
          priceCell.style.animation = "highlight 0.6s ease-out";
          setTimeout(() => {
            priceCell.style.animation = "";
          }, 600);
        }

        if (liquidityCell && Number.isFinite(tokenInList.liquidity_usd)) {
          liquidityCell.innerHTML = Utils.formatCurrencyUSD(
            tokenInList.liquidity_usd,
            { fallback: "‚Äî" }
          );
        }

        if (timeCell && updatedTimestamp !== null) {
          timeCell.textContent = Utils.formatTimeAgo(updatedTimestamp, {
            fallback: "-",
          });
        }
      }
    }

    if (currentModalMint === mint) {
      const modalPriceEl = document.getElementById("modalTokenPrice");
      const sidebarPriceEl = document.getElementById("sidebar-price");
      const liquidityEl = document.getElementById("detail-liquidity");
      const sidebarLiqEl = document.getElementById("sidebar-liq");
      const confidenceEl = document.getElementById("detail-confidence");
      const solReservesEl = document.getElementById("detail-sol-reserves");
      const tokenReservesEl = document.getElementById("detail-token-reserves");
      const poolAddressEl = document.getElementById("detail-pool");

      if (
        tokenModalData &&
        tokenModalData.token &&
        Number.isFinite(updatedPriceSol)
      ) {
        tokenModalData.token.price_sol = updatedPriceSol;
      }
      if (tokenModalData && tokenModalData.detail) {
        if (Number.isFinite(updatedPriceSol)) {
          tokenModalData.detail.price_sol = updatedPriceSol;
        }
        if (Number.isFinite(priceResult.confidence)) {
          tokenModalData.detail.price_confidence = priceResult.confidence;
        }
        if (Number.isFinite(priceResult.sol_reserves)) {
          tokenModalData.detail.pool_reserves_sol = priceResult.sol_reserves;
        }
        if (Number.isFinite(priceResult.token_reserves)) {
          tokenModalData.detail.pool_reserves_token =
            priceResult.token_reserves;
        }
        if (priceResult.pool_address) {
          tokenModalData.detail.pool_address = priceResult.pool_address;
        }
        if (updatedTimestamp !== null) {
          tokenModalData.detail.price_updated_at = updatedTimestamp;
        }
      }

      if (modalPriceEl && Number.isFinite(updatedPriceSol)) {
        modalPriceEl.textContent = Utils.formatPriceSol(updatedPriceSol, {
          fallback: "N/A",
        });
      }
      if (sidebarPriceEl && Number.isFinite(updatedPriceSol)) {
        sidebarPriceEl.textContent = Utils.formatPriceSol(updatedPriceSol, {
          fallback: "N/A",
        });
      }

      if (confidenceEl && Number.isFinite(priceResult.confidence)) {
        confidenceEl.textContent = priceResult.confidence.toFixed(2);
      }
      if (solReservesEl && Number.isFinite(priceResult.sol_reserves)) {
        solReservesEl.textContent = Utils.formatCompactNumber(
          priceResult.sol_reserves,
          2,
          "‚Äî"
        );
      }
      if (tokenReservesEl && Number.isFinite(priceResult.token_reserves)) {
        tokenReservesEl.textContent = Utils.formatCompactNumber(
          priceResult.token_reserves,
          2,
          "‚Äî"
        );
      }
      if (poolAddressEl && priceResult.pool_address) {
        poolAddressEl.textContent = priceResult.pool_address;
      }

      if (Number.isFinite(tokenInList?.liquidity_usd)) {
        const formatted = Utils.formatCurrencyUSD(tokenInList.liquidity_usd, {
          fallback: "‚Äî",
        });
        if (liquidityEl) liquidityEl.textContent = formatted;
        if (sidebarLiqEl) sidebarLiqEl.textContent = formatted;
      }
    }
  }
  // Execute initialization immediately (works for both initial load and SPA navigation)
  initTokensPage();
</script>
