<style>
  .token-row {
    transition: background-color 0.45s ease;
  }

  .token-row--changed {
    animation: token-row-flash 1.25s ease-out;
  }

  .token-row--up {
    --token-glow-color: rgba(34, 197, 94, 0.2);
  }

  .token-row--down {
    --token-glow-color: rgba(239, 68, 68, 0.2);
  }

  @keyframes token-row-flash {
    0% {
      background-color: var(--token-glow-color, rgba(59, 130, 246, 0.14));
    }
    75% {
      background-color: rgba(15, 23, 42, 0.08);
    }
    100% {
      background-color: transparent;
    }
  }

  .price-cell {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 6px;
    font-variant-numeric: tabular-nums;
  }

  .price-value {
    transition: color 0.25s ease;
  }

  .price-cell--up .price-value {
    color: #22c55e;
  }

  .price-cell--down .price-value {
    color: #ef4444;
  }

  .price-arrow {
    display: inline-block;
    min-width: 0.9em;
    font-size: 0.85em;
    opacity: 0;
    transform: translateY(-1px);
    transition: opacity 0.25s ease, transform 0.25s ease;
  }

  .price-cell--up .price-arrow--up,
  .price-cell--down .price-arrow--down {
    opacity: 1;
  }

  .price-cell--up .price-arrow--up {
    color: #22c55e;
  }

  .price-cell--down .price-arrow--down {
    color: #ef4444;
  }

  .price-arrow--flat {
    opacity: 0;
  }
</style>
<script>
  var TOKENS_DEFAULT_PAGE_SIZE = Number("__TOKENS_DEFAULT_PAGE_SIZE__") || 50;
  var TOKENS_MAX_PAGE_SIZE =
    Number("__TOKENS_MAX_PAGE_SIZE__") || TOKENS_DEFAULT_PAGE_SIZE;
  var DEFAULT_TOKENS_VIEW = "pool";
  var TOKENS_VIEW_DEFS = [
    { id: "pool", label: "üíß Pool Service" },
    { id: "all", label: "üìã All Tokens" },
    { id: "passed", label: "‚úÖ Passed" },
    { id: "rejected", label: "‚õî Rejected" },
    { id: "blacklisted", label: "üö´ Blacklisted" },
    { id: "positions", label: "üìä Positions" },
    { id: "secure", label: "üõ°Ô∏è Secure" },
    { id: "recent", label: "üÜï Recent" },
  ];
  var TOKENS_VIEWS = TOKENS_VIEW_DEFS.map(function (view) {
    return view.id;
  });
  var TOKENS_SORT_KEYS = [
    "symbol",
    "price_sol",
    "liquidity_usd",
    "volume_24h",
    "fdv",
    "market_cap",
    "price_change_h1",
    "price_change_h24",
    "security_score",
    "updated_at",
  ];
  var DEFAULT_SORT_KEY = "symbol";
  var DEFAULT_SORT_DIR = "asc";
  var VIEW_LABELS = {
    pool: "with available prices",
    all: "in database",
    passed: "that passed filtering",
    rejected: "rejected by filtering",
    blacklisted: "blacklisted",
    positions: "with open positions",
    secure: "secure",
    recent: "recently updated",
  };

  var tokensState = window.tokensState || {
    view: DEFAULT_TOKENS_VIEW,
    sortBy: DEFAULT_SORT_KEY,
    sortDir: DEFAULT_SORT_DIR,
    searchTerm: "",
  };
  window.tokensState = tokensState;
  var TOKENS_SCROLL_GUARD_HTML =
    '<tr id="tokens-scroll-guard" class="scroll-guard-row"><td colspan="12" class="scroll-guard-cell"></td></tr>';

  var tokensTableState = window.tokensTableState || {
    items: [],
    pageSize: 0,
    currentPage: 0,
    totalPages: 0,
    totalCount: 0,
    loading: false,
    pendingReload: false,
    scrollObserver: null,
    scrollContainer: null,
  };

  window.tokensTableState = tokensTableState;

  var allTokensData = tokensTableState.items;
  var currentModalMint = null;
  var tokenModalData = null;
  var searchDebounceHandle = null;
  var tokensFetchState = window.tokensFetchState || {
    inProgress: false,
    message: "",
    abortController: null,
  };
  window.tokensFetchState = tokensFetchState;
  var tokensAutoRefreshState = window.tokensAutoRefreshState || {
    poller: null,
  };
  window.tokensAutoRefreshState = tokensAutoRefreshState;
  var tokensPriceState = window.tokensPriceState || {
    lastPrices: new Map(),
    lastDirections: new Map(),
    lastChangeAt: new Map(),
  };
  if (!(tokensPriceState.lastPrices instanceof Map)) {
    tokensPriceState.lastPrices = new Map();
  }
  if (!(tokensPriceState.lastDirections instanceof Map)) {
    tokensPriceState.lastDirections = new Map();
  }
  if (!(tokensPriceState.lastChangeAt instanceof Map)) {
    tokensPriceState.lastChangeAt = new Map();
  }
  window.tokensPriceState = tokensPriceState;
  var TOKENS_PRICE_HIGHLIGHT_TTL_MS = 4500;
  var TOKENS_PAGE_LIMIT = TOKENS_DEFAULT_PAGE_SIZE;

  function replaceAllTokensData(next) {
    tokensTableState.items = Array.isArray(next) ? next : [];
    allTokensData = tokensTableState.items;
  }

  function appendTokensToState(items) {
    if (!Array.isArray(items) || items.length === 0) return;
    if (!Array.isArray(tokensTableState.items)) {
      tokensTableState.items = [];
    }
    Array.prototype.push.apply(tokensTableState.items, items);
    allTokensData = tokensTableState.items;
  }

  function clampTokensPageSize(size) {
    const numeric = Number(size);
    if (!Number.isFinite(numeric) || numeric <= 0) {
      return TOKENS_PAGE_LIMIT;
    }
    return Math.min(Math.max(1, Math.floor(numeric)), TOKENS_MAX_PAGE_SIZE);
  }

  function resetTokensPagination(options) {
    const { preserveItems = false } = options || {};
    if (!preserveItems) {
      replaceAllTokensData([]);
    }
    tokensTableState.pageSize = TOKENS_PAGE_LIMIT;
    tokensTableState.currentPage = 0;
    tokensTableState.totalPages = 0;
    tokensTableState.totalCount = preserveItems
      ? tokensTableState.totalCount
      : 0;
    tokensTableState.loading = false;
    tokensTableState.pendingReload = false;
    teardownTokensScrollObserver();
  }

  // Global init function for Router to call during SPA navigation
  window.initTokensPage = function () {
    console.log("[Tokens] Initializing page");
    hydrateTokensState();
    ensureTokensPageReady({ updateStatus: false });
    setupSortableHeaders();
    attachGlobalListeners();
    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => cleanupTokensPage());
    }
    reloadTokensList("Loading tokens...");
  };

  function hydrateTokensState() {
    const savedView = window.sessionStorage.getItem("tokens.view");
    if (savedView && TOKENS_VIEWS.includes(savedView)) {
      tokensState.view = savedView;
    } else if (savedView) {
      console.warn("[Tokens] Ignoring unsupported stored view", savedView);
      window.sessionStorage.removeItem("tokens.view");
    }

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }

    const savedSearch = window.sessionStorage.getItem("tokens.search");
    if (typeof savedSearch === "string") {
      tokensState.searchTerm = savedSearch;
    }

    const savedSortBy = window.sessionStorage.getItem("tokens.sortBy");
    if (savedSortBy) {
      if (TOKENS_SORT_KEYS.includes(savedSortBy)) {
        tokensState.sortBy = savedSortBy;
      } else {
        console.warn(
          "[Tokens] Ignoring unsupported stored sortBy",
          savedSortBy
        );
        window.sessionStorage.removeItem("tokens.sortBy");
      }
    }

    const savedSortDir = window.sessionStorage.getItem("tokens.sortDir");
    if (savedSortDir) {
      if (savedSortDir === "asc" || savedSortDir === "desc") {
        tokensState.sortDir = savedSortDir;
      } else {
        console.warn(
          "[Tokens] Ignoring unsupported stored sortDir",
          savedSortDir
        );
        window.sessionStorage.removeItem("tokens.sortDir");
      }
    }

    if (!TOKENS_SORT_KEYS.includes(tokensState.sortBy)) {
      tokensState.sortBy = DEFAULT_SORT_KEY;
    }

    if (tokensState.sortDir !== "asc" && tokensState.sortDir !== "desc") {
      tokensState.sortDir = tokensState.sortBy === "symbol" ? "asc" : "desc";
    }

    persistTokensSortState();
  }

  function getTokenByMint(mint) {
    if (!mint) return null;
    return allTokensData.find((token) => token?.mint === mint) || null;
  }

  async function fetchTokenDetail(mint) {
    const fetchStart = performance.now();
    console.log(`[TokenDetail] fetchTokenDetail START mint=${mint}`);
    try {
      const res = await fetch(`/api/tokens/${mint}`);
      const fetchEnd = performance.now();
      console.log(
        `[TokenDetail] fetch completed elapsed=${(
          fetchEnd - fetchStart
        ).toFixed(2)}ms`
      );
      if (!res.ok) throw new Error(`Token request failed (${res.status})`);
      const parseStart = performance.now();
      const data = await res.json();
      const parseEnd = performance.now();
      console.log(
        `[TokenDetail] JSON parse elapsed=${(parseEnd - parseStart).toFixed(
          2
        )}ms`
      );
      console.log(
        `[TokenDetail] fetchTokenDetail COMPLETE total_elapsed=${(
          parseEnd - fetchStart
        ).toFixed(2)}ms`
      );
      return data;
    } catch (error) {
      console.error("Failed to fetch token detail:", error);
      Utils.showToast("‚ùå Failed to load token details", "error");
      return null;
    }
  }

  function renderSidebarBadges(token) {
    const badges = [];
    if (token?.has_pool_price)
      badges.push(
        '<span class="badge" style="background:#dbeafe;color:#1e40af;border:1px solid #bfdbfe;">POOL</span>'
      );
    if (token?.has_ohlcv)
      badges.push(
        '<span class="badge" style="background:#dcfce7;color:#166534;border:1px solid #bbf7d0;">OHLCV</span>'
      );
    if (token?.has_open_position)
      badges.push(
        '<span class="badge" style="background:#fde68a;color:#92400e;border:1px solid #fcd34d;">POS</span>'
      );
    if (token?.blacklisted)
      badges.push(
        '<span class="badge" style="background:#fee2e2;color:#991b1b;border:1px solid #fecaca;">BL</span>'
      );
    return badges.join(" ");
  }

  function renderRiskFactors(risks) {
    if (!Array.isArray(risks) || risks.length === 0) {
      return '<div style="color:#94a3b8;">No risk factors reported.</div>';
    }

    return risks
      .map((risk) => {
        const level = (risk.level || "").toUpperCase();
        const prefix = level ? `[${level}] ` : "";
        const title = risk.name || risk.title || "Risk factor";
        const description = risk.description || "‚Äî";
        return `
                        <div class="risk-item">
                            <div class="risk-item-title">${prefix}${title}</div>
                            <div class="risk-item-desc">${description}</div>
                        </div>
                    `;
      })
      .join("");
  }

  function populateTokenModal(token, detail) {
    if (!token) return;

    const detailData = detail || {};
    const price = Number.isFinite(detailData.price_sol)
      ? Number(detailData.price_sol)
      : Number(token.price_sol);
    const change24h = Number.isFinite(detailData.price_change_h24)
      ? Number(detailData.price_change_h24)
      : Number(token.price_change_h24);
    const changeCls =
      change24h > 0 ? "positive" : change24h < 0 ? "negative" : "";

    const logoEl = document.getElementById("modalTokenLogo");
    if (logoEl) {
      if (token.logo_url) {
        logoEl.src = token.logo_url;
        logoEl.style.display = "block";
      } else {
        logoEl.src = "";
        logoEl.style.display = "none";
      }
    }

    Utils.setText("modalTokenSymbol", token.symbol || detailData.symbol || "‚Äî");
    Utils.setText("modalTokenName", token.name || detailData.name || "‚Äî");
    Utils.setText(
      "modalTokenPrice",
      Number.isFinite(price)
        ? Utils.formatPriceSol(price, { fallback: "N/A" })
        : "‚Äî"
    );

    const changeEl = document.getElementById("modalTokenChange");
    if (changeEl) {
      changeEl.textContent = Number.isFinite(change24h)
        ? Utils.formatPercentValue(change24h, { fallback: "‚Äî" })
        : "‚Äî";
      changeEl.classList.remove("positive", "negative");
      if (changeCls) changeEl.classList.add(changeCls);
    }

    Utils.setText("detail-mint", detailData.mint || token.mint || "‚Äî");
    Utils.setText("detail-decimals", detailData.decimals ?? "‚Äî");
    Utils.setText(
      "detail-verified",
      Utils.formatBooleanFlag(detailData.verified, "‚Äî")
    );
    Utils.setText(
      "detail-blacklisted",
      Utils.formatBooleanFlag(detailData.blacklisted ?? token.blacklisted, "‚Äî")
    );
    Utils.setText("detail-launch-date", detailData.launch_date || "‚Äî");

    const liquidityValue = detailData.liquidity_usd ?? token.liquidity_usd;
    const volume24hValue = detailData.volume_24h ?? token.volume_24h;
    const volume6hValue = detailData.volume_6h ?? detailData.volume_h6;
    const volume1hValue = detailData.volume_1h ?? detailData.volume_h1;
    const fdvValue = detailData.fdv ?? token.fdv;
    const marketCapValue = detailData.market_cap ?? token.market_cap;

    Utils.setText(
      "detail-liquidity",
      Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume24h",
      Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume6h",
      Utils.formatCurrencyUSD(volume6hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-volume1h",
      Utils.formatCurrencyUSD(volume1hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-fdv",
      Utils.formatCurrencyUSD(fdvValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-marketcap",
      Utils.formatCurrencyUSD(marketCapValue, { fallback: "‚Äî" })
    );

    const dexLabel = detailData.pool_dex || detailData.pool?.dex;
    const poolAddress = detailData.pool_address || detailData.pool?.address;
    const solReserves =
      detailData.pool_reserves_sol ?? detailData.pool?.sol_reserves;
    const tokenReserves =
      detailData.pool_reserves_token ?? detailData.pool?.token_reserves;
    const confidence =
      detailData.price_confidence ?? detailData.pool?.confidence;
    const poolAge = detailData.pool_age || detailData.pool?.age;

    Utils.setText("detail-dex", dexLabel || "‚Äî");
    Utils.setText("detail-pool", poolAddress || "‚Äî");
    Utils.setText(
      "detail-sol-reserves",
      Utils.formatCompactNumber(solReserves, 2, "‚Äî")
    );
    Utils.setText(
      "detail-token-reserves",
      Utils.formatCompactNumber(tokenReserves, 2, "‚Äî")
    );
    Utils.setText(
      "detail-confidence",
      Number.isFinite(confidence) ? Number(confidence).toFixed(2) : "‚Äî"
    );
    Utils.setText("detail-pool-age", poolAge || "‚Äî");

    const change5m =
      detailData.price_change_m5 ?? detailData.price_changes?.change_5m;
    const change1h =
      detailData.price_change_h1 ??
      token.price_change_h1 ??
      detailData.price_changes?.change_1h;
    const change6h =
      detailData.price_change_h6 ?? detailData.price_changes?.change_6h;
    const change24hValue =
      detailData.price_change_h24 ??
      token.price_change_h24 ??
      detailData.price_changes?.change_24h;

    Utils.setText(
      "detail-change5m",
      change5m !== undefined
        ? Utils.formatPercentValue(change5m, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change1h",
      change1h !== undefined
        ? Utils.formatPercentValue(change1h, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change6h",
      change6h !== undefined
        ? Utils.formatPercentValue(change6h, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-change24h",
      change24hValue !== undefined
        ? Utils.formatPercentValue(change24hValue, { fallback: "‚Äî" })
        : "‚Äî"
    );

    const buys24hRaw = detailData.txns?.h24?.buys ?? detailData.buys_24h;
    const sells24hRaw = detailData.txns?.h24?.sells ?? detailData.sells_24h;
    const buys24h = Number(buys24hRaw);
    const sells24h = Number(sells24hRaw);
    const hasBuys = Number.isFinite(buys24h);
    const hasSells = Number.isFinite(sells24h);
    const netFlow =
      hasBuys && hasSells ? buys24h - sells24h : Number(detailData.net_flow);
    const ratio =
      hasBuys && hasSells && sells24h !== 0
        ? buys24h / sells24h
        : Number(detailData.buy_sell_ratio);

    Utils.setText("detail-buys24h", hasBuys ? Math.round(buys24h) : "‚Äî");
    Utils.setText("detail-sells24h", hasSells ? Math.round(sells24h) : "‚Äî");
    Utils.setText(
      "detail-ratio",
      Number.isFinite(ratio) ? ratio.toFixed(2) : "‚Äî"
    );
    if (Number.isFinite(netFlow)) {
      const sign = netFlow > 0 ? "+" : netFlow < 0 ? "-" : "";
      Utils.setText(
        "detail-netflow",
        `${sign}${Math.abs(Math.round(netFlow))}`
      );
    } else {
      Utils.setText("detail-netflow", "‚Äî");
    }

    const securityScore = Number(detailData.security_score);
    const rugged = detailData.rugged;
    const badge = document.getElementById("security-badge");
    if (badge) {
      const statusClass =
        rugged === true
          ? "critical"
          : securityScore >= 700
          ? "excellent"
          : securityScore >= 500
          ? "good"
          : securityScore >= 300
          ? "warning"
          : "critical";
      badge.className = `security-badge ${statusClass}`.trim();
    }

    const progress = document.getElementById("security-progress");
    if (progress) {
      let pct = Number(detailData.security_score_normalized);
      if (!Number.isFinite(pct)) {
        pct = Number(detailData.security_score);
        if (Number.isFinite(pct)) {
          pct = Math.max(0, Math.min(100, pct / 10.0));
        }
      }
      if (!Number.isFinite(pct)) pct = 0;
      pct = Math.max(0, Math.min(100, pct));
      progress.style.width = `${pct}%`;
    }

    Utils.setHtml(
      "security-score-value",
      Number.isFinite(securityScore) ? `${securityScore}` : "‚Äî"
    );
    const securitySummary =
      detailData.security_summary ||
      (rugged
        ? "‚ö†Ô∏è Token flagged as rugged."
        : "No security summary available.");
    Utils.setHtml("security-status", securitySummary);
    Utils.setText("detail-mint-auth", detailData.mint_authority ?? "Unknown");
    Utils.setText(
      "detail-freeze-auth",
      detailData.freeze_authority ?? "Unknown"
    );
    Utils.setText("detail-holders", detailData.total_holders ?? "‚Äî");
    const top10Raw = detailData.top_10_concentration;
    if (top10Raw === null || top10Raw === undefined) {
      Utils.setText("detail-top10", "‚Äî");
    } else {
      const top10Num = Number(top10Raw);
      if (Number.isFinite(top10Num)) {
        const display = top10Num <= 1 ? top10Num * 100 : top10Num;
        Utils.setText("detail-top10", `${display.toFixed(2)}%`);
      } else {
        Utils.setText("detail-top10", `${top10Raw}`);
      }
    }
    Utils.setHtml(
      "risk-factors-list",
      renderRiskFactors(detailData.security_risks)
    );

    Utils.setText(
      "sidebar-price",
      Number.isFinite(price)
        ? Utils.formatPriceSol(price, { fallback: "N/A" })
        : "‚Äî"
    );
    Utils.setText(
      "sidebar-volume",
      Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "sidebar-liq",
      Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
    );
    Utils.setText(
      "sidebar-mcap",
      Utils.formatCurrencyUSD(marketCapValue, { fallback: "‚Äî" })
    );

    const statusFlags = {
      has_pool_price: detailData.has_pool_price ?? token.has_pool_price,
      has_ohlcv: detailData.has_ohlcv ?? token.has_ohlcv,
      has_open_position:
        detailData.has_open_position ?? token.has_open_position,
      blacklisted: detailData.blacklisted ?? token.blacklisted,
    };
    Utils.setHtml("sidebar-badges", renderSidebarBadges(statusFlags));

    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.add("active");
    } else {
      console.error("Modal element not found!");
    }
  }

  function resetTokenModal() {
    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.remove("active");
    }

    // CRITICAL FIX: Destroy chart instance on modal close to prevent stale data
    if (tokenChartManager) {
      console.log("[TokenDetail] Destroying chart on modal close");
      tokenChartManager.destroy();
      tokenChartManager = null;
    }

    currentModalMint = null;
    tokenModalData = null;
  }

  async function openTokenModal(mint) {
    const modalStart = performance.now();
    console.log(`[TokenDetail] openTokenModal START mint=${mint}`);

    if (!mint) {
      console.warn("openTokenModal: no mint provided");
      return;
    }

    const cacheStart = performance.now();
    const cached = getTokenByMint(mint);
    const cacheEnd = performance.now();
    console.log(
      `[TokenDetail] cache lookup elapsed=${(cacheEnd - cacheStart).toFixed(
        2
      )}ms found=${!!cached}`
    );

    if (!cached) {
      console.warn("openTokenModal: token not found in cache");
      Utils.showToast("‚ùå Token not found in cache", "error");
      return;
    }

    const detail = await fetchTokenDetail(mint);
    if (!detail) {
      console.warn("openTokenModal: failed to fetch token detail");
      return; // fetchTokenDetail already shows error toast
    }

    const populateStart = performance.now();
    currentModalMint = mint;
    tokenModalData = { token: cached, detail };
    populateTokenModal(cached, detail);
    const populateEnd = performance.now();

    console.log(
      `[TokenDetail] populateTokenModal elapsed=${(
        populateEnd - populateStart
      ).toFixed(2)}ms`
    );
    console.log(
      `[TokenDetail] openTokenModal COMPLETE total_elapsed=${(
        populateEnd - modalStart
      ).toFixed(2)}ms`
    );

    // CRITICAL FIX: Check if chart tab is already active from previous modal session
    // If so, initialize chart immediately with new token
    const chartTab = document.querySelector('.modal-tab[onclick*="chart"]');
    const chartTabPane = document.getElementById("tab-chart");
    if (
      chartTab?.classList.contains("active") ||
      chartTabPane?.classList.contains("active")
    ) {
      console.log(
        "[TokenDetail] Chart tab already active, initializing chart for:",
        mint
      );
      initTokenChart(mint);
    }
  }

  function closeTokenModal(event) {
    if (event && event.target && event.target !== event.currentTarget) {
      return;
    }
    resetTokenModal();
  }

  function switchModalTab(tabId) {
    const content = document.querySelectorAll(".tab-pane");
    const tabs = document.querySelectorAll(".modal-tab");
    content.forEach((pane) => {
      pane.classList.toggle("active", pane.id === `tab-${tabId}`);
    });
    tabs.forEach((tab) => {
      tab.classList.toggle(
        "active",
        tab.textContent.includes(tabId.charAt(0).toUpperCase())
      );
    });

    // CRITICAL FIX: Always re-initialize chart when switching to chart tab
    // This ensures correct token data is loaded, even if chart was previously initialized
    if (tabId === "chart" && currentModalMint) {
      console.log(
        "[TokenDetail] Switching to chart tab, initializing chart for:",
        currentModalMint
      );
      initTokenChart(currentModalMint);
    }
  }

  function copyMintFromModal() {
    if (!currentModalMint) return;
    Utils.copyMint(currentModalMint);
  }

  function openDexScreenerFromModal() {
    if (!currentModalMint) return;
    Utils.openDexScreener(currentModalMint);
  }

  function openGMGNFromModal() {
    if (!currentModalMint) return;
    Utils.openGMGN(currentModalMint);
  }

  function openSolscanFromModal() {
    if (!currentModalMint) return;
    Utils.openSolscan(currentModalMint);
  }

  function attachGlobalListeners() {
    if (!window.__tokensVisibilityHandler) {
      window.__tokensVisibilityHandler = handleVisibilityChange;
      document.addEventListener(
        "visibilitychange",
        window.__tokensVisibilityHandler
      );
    }
  }

  function handleVisibilityChange() {
    if (document.visibilityState !== "visible") {
      return;
    }
    if (window.Router && Router.currentPage !== "tokens") {
      return;
    }
    reloadTokensList("Refreshing after returning...", {
      preserveItems: true,
    });
  }

  function isTokensPageActive() {
    if (typeof document !== "undefined") {
      const state = document.visibilityState;
      if (state && state !== "visible") {
        return false;
      }
    }
    if (
      window.Router &&
      Router.currentPage &&
      Router.currentPage !== "tokens"
    ) {
      return false;
    }
    return true;
  }

  function tokensAutoRefreshPoll() {
    if (!isTokensPageActive()) {
      return;
    }
    if (tokensFetchState.inProgress) {
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] Skipping auto refresh; request in flight");
      }
      return;
    }
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const message = viewLabel
      ? `Refreshing tokens ${viewLabel}...`
      : "Refreshing tokens...";
    reloadTokensList(message, { preserveItems: true });
  }

  function ensureTokensAutoRefresh() {
    const state = window.tokensAutoRefreshState;
    if (!state) {
      return;
    }

    if (state.poller) {
      if (typeof state.poller.start === "function") {
        state.poller.start({ silent: true });
      }
      return;
    }

    if (window.PagePoller && typeof window.PagePoller.create === "function") {
      state.poller = window.PagePoller.create({
        label: "Tokens",
        onPoll: tokensAutoRefreshPoll,
      });
      state.poller.start({ silent: true });
      return;
    }

    console.warn(
      "[Tokens] PagePoller unavailable; using fallback polling logic"
    );
    state.poller = createTokensFallbackPoller(tokensAutoRefreshPoll);
    if (state.poller && typeof state.poller.start === "function") {
      state.poller.start({ silent: true });
    }
  }

  function createTokensFallbackPoller(onPoll) {
    const logPrefix = "[Tokens] (fallback)";
    let intervalId = null;
    let listener = null;

    const computeInterval = () => {
      if (
        window.PollingManager &&
        typeof window.PollingManager.getInterval === "function"
      ) {
        const value = Number(window.PollingManager.getInterval());
        if (Number.isFinite(value) && value > 0) {
          return value;
        }
      }
      return 1000;
    };

    const ensureListener = () => {
      if (
        !window.PollingManager ||
        typeof window.PollingManager.onChange !== "function" ||
        listener
      ) {
        return;
      }

      listener = window.PollingManager.onChange(() => {
        if (!intervalId) {
          return;
        }
        start({ silent: true });
        console.log(`${logPrefix} Polling interval changed`);
      });
    };

    const start = ({ silent } = {}) => {
      stop({ silent: true });
      const interval = computeInterval();
      intervalId = setInterval(() => {
        try {
          onPoll();
        } catch (error) {
          console.error(`${logPrefix} Poll failed`, error);
        }
      }, interval);

      if (window.Router && typeof Router.trackInterval === "function") {
        Router.trackInterval(intervalId);
      }

      ensureListener();

      if (!silent) {
        console.log(`${logPrefix} Started polling every ${interval} ms`);
      }

      return interval;
    };

    const stop = ({ silent } = {}) => {
      if (!intervalId) {
        return;
      }
      clearInterval(intervalId);
      intervalId = null;
      if (!silent) {
        console.log(`${logPrefix} Stopped polling`);
      }
    };

    const cleanup = () => {
      stop({ silent: true });
      if (
        listener &&
        window.PollingManager &&
        typeof window.PollingManager.removeListener === "function"
      ) {
        window.PollingManager.removeListener(listener);
      }
      listener = null;
    };

    return {
      start,
      stop,
      restart: () => start({ silent: true }),
      cleanup,
    };
  }

  function stopTokensAutoRefresh() {
    const state = window.tokensAutoRefreshState;
    if (!state || !state.poller) {
      return;
    }

    if (typeof state.poller.cleanup === "function") {
      state.poller.cleanup();
    } else if (typeof state.poller.stop === "function") {
      state.poller.stop();
    }

    state.poller = null;
  }

  function initTokensSubTabs() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    subTabsContainer.innerHTML = TOKENS_VIEW_DEFS.map(function (view) {
      var isActive = view.id === tokensState.view;
      return (
        '<button class="sub-tab ' +
        (isActive ? "active" : "") +
        '" data-view="' +
        view.id +
        '">' +
        view.label +
        "</button>"
      );
    }).join("");

    subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
      button.addEventListener("click", () =>
        switchTokensSubTab(button.dataset.view)
      );
    });

    subTabsContainer.style.display = "flex";
  }

  function ensureTokensSubTabsVisible() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }

    const needsInit = subTabsContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(subTabsContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      subTabsContainer.style.display === "none";

    if (needsInit) {
      initTokensSubTabs();
    } else {
      subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
        button.classList.toggle(
          "active",
          button.dataset.view === tokensState.view
        );
      });
    }

    if (hidden) {
      subTabsContainer.style.display = "flex";
    }
  }

  function switchTokensSubTab(view) {
    var nextView = view;
    if (!nextView || !TOKENS_VIEWS.includes(nextView)) {
      console.warn("[Tokens] Unsupported sub-tab selection", nextView);
      nextView = DEFAULT_TOKENS_VIEW;
    }

    if (tokensState.view === nextView) {
      ensureTokensSubTabsVisible();
      return;
    }

    tokensState.view = nextView;
    window.sessionStorage.setItem("tokens.view", tokensState.view);

    document.querySelectorAll("#subTabsContainer .sub-tab").forEach((tab) => {
      tab.classList.toggle("active", tab.dataset.view === tokensState.view);
    });

    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const loadMessage = viewLabel
      ? `Loading tokens ${viewLabel}...`
      : "Loading tokens...";

    reloadTokensList(loadMessage);
  }

  function ensureTokensToolbarVisible(options = {}) {
    const { updateStatus = true } = options;
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    const needsInit = toolbarContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(toolbarContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      toolbarContainer.style.display === "none";

    if (needsInit) {
      initTokensToolbar();
    } else {
      const searchInput = toolbarContainer.querySelector("#searchInput");
      if (searchInput) {
        searchInput.value = tokensState.searchTerm;
      }
    }

    if (hidden) {
      toolbarContainer.style.display = "flex";
    }

    if (!updateStatus) {
      return;
    }

    let statusMessage = null;
    if (tokensFetchState.inProgress && tokensFetchState.message) {
      statusMessage = tokensFetchState.message;
    } else {
      const totalAvailable = Number(tokensTableState.totalCount) || 0;
      const loaded = Array.isArray(tokensTableState.items)
        ? tokensTableState.items.length
        : allTokensData.length;
      if (totalAvailable > 0 || loaded > 0) {
        const viewLabel = VIEW_LABELS[tokensState.view] || "";
        if (totalAvailable > 0 && loaded > 0 && loaded < totalAvailable) {
          statusMessage = viewLabel
            ? `${loaded}/${totalAvailable} tokens ${viewLabel}`
            : `${loaded}/${totalAvailable} tokens`;
        } else {
          const value = totalAvailable || loaded;
          statusMessage = viewLabel
            ? `${value} tokens ${viewLabel}`
            : `${value} tokens`;
        }
      }
    }

    if (statusMessage) {
      setTokenCountStatus(statusMessage);
    }
  }

  function ensureTokensPageReady(options = {}) {
    ensureTokensSubTabsVisible();
    ensureTokensToolbarVisible(options);
    attachGlobalListeners();
    ensureTokensAutoRefresh();
  }

  window.ensureTokensPageReady = ensureTokensPageReady;

  function initTokensToolbar() {
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    toolbarContainer.innerHTML = `
                <input
                    type="text"
                    id="searchInput"
                    placeholder="Search by symbol or mint..."
                    style="flex: 1; max-width: 300px; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9em; background: var(--bg-primary); color: var(--text-primary);"
                >
                <div class="spacer"></div>
                <span id="tokenCount" style="color: var(--text-secondary); font-size: 0.9em; font-weight: 500;">Loading...</span>
                <button id="tokensRefreshBtn" class="btn btn-primary" style="padding: 6px 12px;">
                    üîÑ Refresh
                </button>
                <button id="tokensExportBtn" class="btn btn-secondary" style="padding: 6px 12px;">
                    üì• Export
                </button>
            `;
    toolbarContainer.style.display = "flex";

    const searchInput = toolbarContainer.querySelector("#searchInput");
    if (searchInput) {
      searchInput.value = tokensState.searchTerm;
      searchInput.addEventListener("input", handleSearchInput);
    }

    const refreshBtn = toolbarContainer.querySelector("#tokensRefreshBtn");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () =>
        reloadTokensList("Refreshing tokens...")
      );
    }

    const exportBtn = toolbarContainer.querySelector("#tokensExportBtn");
    if (exportBtn) {
      exportBtn.addEventListener("click", exportTokens);
    }
  }

  function handleSearchInput(event) {
    tokensState.searchTerm = event.target.value.trim();
    window.sessionStorage.setItem("tokens.search", tokensState.searchTerm);

    const message = tokensState.searchTerm
      ? "Applying search filter..."
      : "Refreshing tokens...";

    setTokenCountStatus(message);

    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }

    searchDebounceHandle = setTimeout(() => {
      reloadTokensList(message, { preserveItems: true });
    }, 350);
  }

  function persistTokensSortState() {
    try {
      window.sessionStorage.setItem("tokens.sortBy", tokensState.sortBy);
      window.sessionStorage.setItem("tokens.sortDir", tokensState.sortDir);
    } catch (err) {
      console.warn("[Tokens] Failed to persist sort state", err);
    }
  }

  async function exportTokens() {
    const exportButton = document.getElementById("tokensExportBtn");
    if (exportButton) {
      exportButton.disabled = true;
      exportButton.textContent = "Exporting‚Ä¶";
    }

    const statusBefore = document.getElementById("tokenCount")?.textContent;
    setTokenCountStatus("üì¶ Preparing export‚Ä¶");

    try {
      const maxPages = 50; // safeguard to prevent unbounded loops
      let page = 1;
      const pageSize = clampTokensPageSize(
        tokensTableState.pageSize || TOKENS_PAGE_LIMIT
      );
      const rows = [];
      let totalPages = 1;
      let totalCount = 0;

      while (page <= totalPages && page <= maxPages) {
        const result = await fetchTokensListPage(page, {
          pageSize,
        });
        rows.push(...result.items);
        totalPages = result.totalPages || totalPages;
        totalCount = result.total || totalCount;
        page += 1;
        setTokenCountStatus(
          `üì¶ Exporting tokens‚Ä¶ (${Math.min(rows.length, totalCount)}/${
            totalCount || "?"
          })`
        );
        if (result.items.length === 0) {
          break;
        }
      }

      if (rows.length === 0) {
        Utils.showToast("No tokens available to export", "info");
        return;
      }

      const header = [
        "mint",
        "symbol",
        "name",
        "price_sol",
        "liquidity_usd",
        "volume_24h",
        "fdv",
        "market_cap",
        "price_change_h1",
        "price_change_h24",
        "security_score",
        "total_holders",
        "has_pool_price",
        "has_ohlcv",
        "has_open_position",
        "blacklisted",
        "price_updated_at",
      ];

      const csvLines = [header.join(",")];
      rows.forEach((token) => {
        const line = header
          .map((field) => {
            const raw = token[field];
            if (raw === null || raw === undefined) {
              return "";
            }
            const str = String(raw);
            const needsEscape = /[",\n]/.test(str);
            const escaped = str.replace(/"/g, '""');
            return needsEscape ? `"${escaped}"` : escaped;
          })
          .join(",");
        csvLines.push(line);
      });

      const blob = new Blob([csvLines.join("\n")], {
        type: "text/csv;charset=utf-8;",
      });
      const url = URL.createObjectURL(blob);
      const filename = `tokens_${tokensState.view}_${
        tokensState.searchTerm ? "search" : "all"
      }_${new Date().toISOString().replace(/[:.]/g, "-")}.csv`;
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      Utils.showToast(`Exported ${rows.length} tokens`, "success");
    } catch (err) {
      console.error("[Tokens] Export failed", err);
      Utils.showToast("‚ùå Failed to export tokens", "error");
    } finally {
      if (statusBefore) {
        setTokenCountStatus(statusBefore);
      } else {
        updateTokenCount(tokensTableState.totalCount || allTokensData.length);
      }
      if (exportButton) {
        exportButton.disabled = false;
        exportButton.textContent = "üì• Export";
      }
    }
  }

  function normalizeTokenFromApi(rawToken) {
    if (!rawToken || typeof rawToken !== "object") return rawToken;
    const token = { ...rawToken };

    if (token.price_updated_at) {
      const numericTimestamp = Number(token.price_updated_at);
      if (Number.isFinite(numericTimestamp)) {
        token.price_updated_at = numericTimestamp;
      } else {
        const parsed = Date.parse(token.price_updated_at);
        token.price_updated_at = Number.isFinite(parsed)
          ? Math.floor(parsed / 1000)
          : null;
      }
    } else {
      token.price_updated_at = null;
    }

    return token;
  }

  function dedupeTokensByMint(tokens) {
    if (!Array.isArray(tokens) || tokens.length === 0) {
      return [];
    }

    const seen = new Set();
    const deduped = [];

    for (const token of tokens) {
      if (!token || typeof token !== "object") continue;
      const mint = token.mint;
      if (!mint || seen.has(mint)) continue;
      seen.add(mint);
      deduped.push(token);
    }

    return deduped;
  }

  function pruneStalePriceHighlights(now) {
    if (!tokensPriceState || !tokensPriceState.lastChangeAt) {
      return;
    }
    const ttl = Number(TOKENS_PRICE_HIGHLIGHT_TTL_MS) || 0;
    if (ttl <= 0) {
      if (typeof tokensPriceState.lastChangeAt.clear === "function") {
        tokensPriceState.lastChangeAt.clear();
      } else {
        tokensPriceState.lastChangeAt = new Map();
      }
      if (typeof tokensPriceState.lastDirections.clear === "function") {
        tokensPriceState.lastDirections.clear();
      } else {
        tokensPriceState.lastDirections = new Map();
      }
      return;
    }

    for (const [mint, timestamp] of tokensPriceState.lastChangeAt) {
      if (!Number.isFinite(timestamp) || now - timestamp > ttl) {
        tokensPriceState.lastChangeAt.delete(mint);
        tokensPriceState.lastDirections.delete(mint);
      }
    }
  }

  function annotateTokensWithPriceChange(tokens) {
    if (!Array.isArray(tokens) || tokens.length === 0) {
      return tokens;
    }

    const now = Date.now();
    pruneStalePriceHighlights(now);
    const ttl = Number(TOKENS_PRICE_HIGHLIGHT_TTL_MS) || 0;

    for (const token of tokens) {
      if (!token || typeof token !== "object") {
        continue;
      }

      const mint = token.mint;
      const currentPrice = Number(token.price_sol);
      const prevPrice = mint ? tokensPriceState.lastPrices.get(mint) : null;
      let changed = false;
      let direction = null;

      if (mint && Number.isFinite(currentPrice)) {
        if (Number.isFinite(prevPrice)) {
          if (currentPrice > prevPrice) {
            direction = "up";
            changed = true;
          } else if (currentPrice < prevPrice) {
            direction = "down";
            changed = true;
          }
        }

        tokensPriceState.lastPrices.set(mint, currentPrice);
      } else if (mint) {
        tokensPriceState.lastPrices.delete(mint);
      }

      if (changed && mint) {
        tokensPriceState.lastDirections.set(mint, direction);
        tokensPriceState.lastChangeAt.set(mint, now);
      }

      const lastDirection = mint
        ? tokensPriceState.lastDirections.get(mint)
        : null;
      const changeAt = mint ? tokensPriceState.lastChangeAt.get(mint) : null;
      const highlightActive =
        Boolean(lastDirection) && Number.isFinite(changeAt)
          ? now - changeAt <= ttl
          : false;
      const indicatorDirection = changed
        ? direction
        : highlightActive
        ? lastDirection
        : null;

      token.__previousPrice = Number.isFinite(prevPrice) ? prevPrice : null;
      token.__priceChanged = changed;
      token.__priceHighlight = Boolean(highlightActive);
      token.__priceDirection = indicatorDirection;
      token.__priceChangeAt = Number.isFinite(changeAt) ? changeAt : null;

      if (!highlightActive && !changed && mint) {
        tokensPriceState.lastChangeAt.delete(mint);
        tokensPriceState.lastDirections.delete(mint);
      }
    }

    return tokens;
  }

  function showTokensError(message) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;
    tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #ef4444;">${message}</td></tr>`;
    setTokenCountStatus(message);
  }

  function updateTokenCount(total) {
    const label = document.getElementById("tokenCount");
    if (!label) return;

    const parsedTotal = Number(total);
    let totalValue = Number.isFinite(parsedTotal)
      ? parsedTotal
      : tokensTableState.totalCount;
    if (!Number.isFinite(totalValue) || totalValue < 0) {
      totalValue = allTokensData.length;
    }
    const loaded = Array.isArray(tokensTableState.items)
      ? tokensTableState.items.length
      : allTokensData.length;
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const hasFilter =
      typeof tokensState.searchTerm === "string" &&
      tokensState.searchTerm.trim() !== "";

    if (tokensState.view === "all" && !hasFilter) {
      label.textContent = `${totalValue} tokens in database`;
      return;
    }

    if (totalValue > 0 && loaded > 0 && loaded < totalValue) {
      label.textContent = viewLabel
        ? `${loaded}/${totalValue} tokens ${viewLabel}`
        : `${loaded}/${totalValue} tokens`;
      return;
    }

    if (loaded > 0 && totalValue === 0) {
      label.textContent = viewLabel
        ? `${loaded} tokens ${viewLabel}`
        : `${loaded} tokens`;
      return;
    }

    label.textContent = viewLabel
      ? `${totalValue} tokens ${viewLabel}`
      : `${totalValue} tokens`;
  }

  function renderTokens(tokens, options) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;

    const mode = (options && options.mode) || "replace";
    const openState = captureOpenDropdownState();

    if (!tokens || tokens.length === 0) {
      if (mode === "append") {
        return;
      }

      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.warn("[TokensDBG] renderTokens: empty data", {
          view: tokensState.view,
          search: tokensState.searchTerm,
          sortBy: tokensState.sortBy,
          sortDir: tokensState.sortDir,
          allTokensDataLen: Array.isArray(allTokensData)
            ? allTokensData.length
            : 0,
          totalCount: tokensTableState.totalCount,
          loading: tokensFetchState.inProgress,
        });
      }

      let statusMessage = "No tokens available.";
      if (
        tokensState &&
        typeof tokensState.searchTerm === "string" &&
        tokensState.searchTerm.trim() !== ""
      ) {
        statusMessage = `No tokens match ‚Äú${tokensState.searchTerm.trim()}‚Äù in this view.`;
      } else if (tokensState.view === "pool") {
        statusMessage =
          "Pool service is warming up ‚Äî waiting for price-enabled tokens.";
      } else {
        const viewLabel = VIEW_LABELS[tokensState.view];
        if (viewLabel) {
          statusMessage = `No tokens ${viewLabel}.`;
        } else if (tokensState.view) {
          statusMessage = `No tokens available for view: ${tokensState.view}.`;
        }
      }

      setTokenCountStatus(statusMessage);
      const safeMessage = Utils.escapeHtml(statusMessage);
      tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #94a3b8;">${safeMessage}</td></tr>`;
      teardownTokensScrollObserver();
      return;
    }

    if (window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] renderTokens: rendering rows", {
        count: tokens.length,
        view: tokensState.view,
        mode,
      });
    }

    if (mode === "replace") {
      const rowsHtml = tokens.map(createTokenRowHtml).join("");
      tbody.innerHTML = rowsHtml + TOKENS_SCROLL_GUARD_HTML;
    } else if (mode === "append") {
      const guard = ensureTokensScrollGuard();
      if (!guard) {
        renderTokens(tokens, { mode: "replace" });
      } else {
        const rowsHtml = tokens.map(createTokenRowHtml).join("");
        if (rowsHtml) {
          guard.insertAdjacentHTML("beforebegin", rowsHtml);
        }
      }
    }

    ensureTokensScrollGuard();
    restoreDropdownState(openState);
  }

  function ensureTokensScrollGuard() {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return null;
    let guard = document.getElementById("tokens-scroll-guard");
    if (!guard) {
      tbody.insertAdjacentHTML("beforeend", TOKENS_SCROLL_GUARD_HTML);
      guard = document.getElementById("tokens-scroll-guard");
    } else if (guard.parentElement !== tbody) {
      guard.parentElement.removeChild(guard);
      tbody.appendChild(guard);
    } else if (tbody.lastElementChild !== guard) {
      tbody.appendChild(guard);
    }
    return guard;
  }

  function setTokensScrollGuardState(state) {
    const guard = ensureTokensScrollGuard();
    if (!guard) return;
    const cell = guard.querySelector(".scroll-guard-cell");
    if (!cell) return;
    if (state === "hidden") {
      guard.style.display = "none";
    } else {
      guard.style.display = "";
    }
    cell.classList.toggle("loading", state === "loading");
    if (state === "loading") {
      cell.textContent = "Loading more tokens‚Ä¶";
    } else if (state === "end") {
      cell.textContent =
        tokensTableState.items.length > 0 ? "No more tokens" : "";
    } else {
      cell.textContent = "";
    }
  }

  function teardownTokensScrollObserver() {
    if (tokensTableState.scrollObserver) {
      try {
        tokensTableState.scrollObserver.disconnect();
      } catch (_) {}
    }
    tokensTableState.scrollObserver = null;
    tokensTableState.scrollContainer = null;
  }

  function setupTokensScrollObserver() {
    teardownTokensScrollObserver();
    const guard = ensureTokensScrollGuard();
    const container = document.querySelector(".table-wrap");
    if (!guard || !container) {
      return;
    }

    if (
      tokensTableState.totalPages <= 1 ||
      tokensTableState.currentPage >= tokensTableState.totalPages
    ) {
      setTokensScrollGuardState("end");
      return;
    }

    setTokensScrollGuardState("idle");
    tokensTableState.scrollContainer = container;
    tokensTableState.scrollObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadNextTokensPage({ skipObserverRefresh: true });
          }
        });
      },
      { root: container, rootMargin: "320px 0px 0px 0px", threshold: 0 }
    );

    tokensTableState.scrollObserver.observe(guard);
  }

  function captureOpenDropdownState() {
    const menu = document.querySelector(".dropdown-menu.show");
    if (!menu) return null;
    const row = menu.closest("tr[data-mint]");
    if (!row) return null;
    return { mint: row.dataset.mint };
  }

  function restoreDropdownState(state) {
    if (!state || !state.mint) return;
    const container = document.querySelector(
      `.dropdown-container[data-mint="${state.mint}"]`
    );
    if (!container) return;

    const btn = container.querySelector(".dropdown-btn");
    const menu = container.querySelector(".dropdown-menu");
    if (!btn || !menu) return;

    openDropdownMenu(btn, menu);
  }

  function setTokenCountStatus(text) {
    const label = document.getElementById("tokenCount");
    if (!label) return;
    label.textContent = text;
  }

  function showTokensLoading(message) {
    const tbody = document.getElementById("tokensTableBody");
    if (tbody) {
      tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 20px; color: #94a3b8;">${message}</td></tr>`;
    }
    setTokenCountStatus(message);
  }

  function buildTokensListQuery(page, pageSize) {
    const params = new URLSearchParams();
    params.set("view", tokensState.view);
    if (tokensState.searchTerm) {
      params.set("search", tokensState.searchTerm);
    }
    params.set("sort_by", tokensState.sortBy);
    params.set("sort_dir", tokensState.sortDir);
    params.set("page", String(page));
    const requestedSize =
      pageSize || tokensTableState.pageSize || TOKENS_PAGE_LIMIT;
    const safeSize = clampTokensPageSize(requestedSize);
    params.set("page_size", String(safeSize));
    return params;
  }

  async function fetchTokensListPage(page, options) {
    const opts = options || {};
    const requestedSize =
      opts.pageSize || tokensTableState.pageSize || TOKENS_PAGE_LIMIT;
    const pageSize = clampTokensPageSize(requestedSize);
    const params = buildTokensListQuery(page, pageSize);
    const url = `/api/tokens/list?${params.toString()}`;
    if (window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] HTTP page fetch", { page, pageSize, url });
    }
    const res = await fetch(url, {
      headers: { "X-Requested-With": "fetch" },
      signal: opts.signal,
    });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const body = await res.json();
    const normalized = Array.isArray(body.items)
      ? body.items.map(normalizeTokenFromApi)
      : [];
    const deduped = dedupeTokensByMint(normalized);
    annotateTokensWithPriceChange(deduped);
    const total = Number(body.total) || normalized.length;
    const totalPages =
      Number(body.total_pages) ||
      (pageSize > 0 ? Math.ceil(total / pageSize) : 1);
    const responsePageSize = Number(body.page_size) || pageSize;
    return {
      items: deduped,
      total,
      totalPages,
      pageSize: responsePageSize,
    };
  }

  async function loadNextTokensPage(options) {
    const opts = options || {};
    if (tokensTableState.loading) {
      tokensTableState.pendingReload = true;
      return false;
    }

    if (
      tokensTableState.totalPages <= 1 ||
      tokensTableState.currentPage >= tokensTableState.totalPages
    ) {
      setTokensScrollGuardState("end");
      return false;
    }

    const nextPage = tokensTableState.currentPage + 1;
    tokensTableState.loading = true;
    setTokensScrollGuardState("loading");

    try {
      const result = await fetchTokensListPage(nextPage, {
        pageSize: opts.pageSize,
        signal: opts.signal,
      });
      tokensTableState.pageSize = clampTokensPageSize(
        result.pageSize || tokensTableState.pageSize
      );
      tokensTableState.totalPages =
        result.totalPages || tokensTableState.totalPages;
      tokensTableState.totalCount = result.total || tokensTableState.totalCount;

      const existingMints = new Set(
        (tokensTableState.items || []).map((token) => token && token.mint)
      );
      const fresh = result.items.filter((token) => {
        if (!token || !token.mint) return false;
        if (existingMints.has(token.mint)) {
          return false;
        }
        existingMints.add(token.mint);
        return true;
      });

      if (fresh.length > 0) {
        appendTokensToState(fresh);
        renderTokens(fresh, { mode: "append" });
      }

      tokensTableState.currentPage = Math.min(
        nextPage,
        tokensTableState.totalPages
      );
      updateTokenCount(tokensTableState.totalCount);

      if (tokensTableState.currentPage >= tokensTableState.totalPages) {
        setTokensScrollGuardState("end");
        teardownTokensScrollObserver();
      } else {
        setTokensScrollGuardState("idle");
        if (!opts.skipObserverRefresh) {
          setupTokensScrollObserver();
        }
      }

      return fresh.length > 0;
    } catch (err) {
      console.warn("[Tokens] Failed to load additional tokens", err);
      setTokensScrollGuardState("end");
      return false;
    } finally {
      tokensTableState.loading = false;
      tokensTableState.pendingReload = false;
    }
  }

  async function reloadTokensList(message, options) {
    const opts = options || {};
    const statusMessage = message || "Loading tokens...";
    const preserveItems = opts.preserveItems === true;
    const resetPagination = opts.resetPagination !== false;

    if (tokensFetchState.abortController) {
      try {
        tokensFetchState.abortController.abort();
      } catch (_) {
        /* no-op */
      }
    }

    if (resetPagination) {
      resetTokensPagination({ preserveItems });
    } else {
      tokensTableState.loading = true;
      tokensTableState.pendingReload = true;
    }

    tokensFetchState.inProgress = true;
    tokensFetchState.message = statusMessage;
    tokensTableState.loading = true;
    tokensTableState.pendingReload = true;

    const hasExistingRows =
      Array.isArray(allTokensData) && allTokensData.length > 0;
    if (!preserveItems || !hasExistingRows) {
      showTokensLoading(statusMessage);
    } else {
      setTokenCountStatus(statusMessage);
    }

    setTokensScrollGuardState("loading");

    const controller = new AbortController();
    tokensFetchState.abortController = controller;

    try {
      const result = await fetchTokensListPage(1, {
        pageSize: opts.pageSize,
        signal: controller.signal,
      });
      replaceAllTokensData(result.items);

      tokensTableState.pageSize = clampTokensPageSize(
        result.pageSize || TOKENS_PAGE_LIMIT
      );
      tokensTableState.currentPage = tokensTableState.items.length > 0 ? 1 : 0;
      tokensTableState.totalPages =
        result.totalPages || (tokensTableState.currentPage > 0 ? 1 : 0);
      tokensTableState.totalCount =
        Number(result.total) || tokensTableState.items.length;

      if (tokensTableState.items.length === 0) {
        renderTokens(tokensTableState.items, { mode: "replace" });
        updateTokenCount(tokensTableState.totalCount);
        setTokensScrollGuardState("hidden");
        teardownTokensScrollObserver();
      } else {
        renderTokens(tokensTableState.items, { mode: "replace" });
        updateTokenCount(tokensTableState.totalCount);

        if (tokensTableState.currentPage < tokensTableState.totalPages) {
          setTokensScrollGuardState("idle");
          setupTokensScrollObserver();
        } else {
          setTokensScrollGuardState("end");
          teardownTokensScrollObserver();
        }

        const viewLabel = VIEW_LABELS[tokensState.view] || "";
        const status = viewLabel
          ? `${tokensTableState.totalCount} tokens ${viewLabel}`
          : `${tokensTableState.totalCount} tokens`;
        setTokenCountStatus(status);
      }
    } catch (err) {
      if (err && err.name === "AbortError") {
        return;
      }
      console.error("[Tokens] Failed to load tokens list", err);
      showTokensError("‚ùå Failed to load tokens");
    } finally {
      if (tokensFetchState.abortController === controller) {
        tokensFetchState.abortController = null;
      }
      tokensFetchState.inProgress = false;
      tokensFetchState.message = "";
      tokensTableState.loading = false;
      tokensTableState.pendingReload = false;
    }
  }

  function cleanupTokensPage() {
    teardownTokensScrollObserver();

    if (tokensFetchState.abortController) {
      try {
        tokensFetchState.abortController.abort();
      } catch (_) {
        /* no-op */
      }
      tokensFetchState.abortController = null;
    }

    tokensFetchState.inProgress = false;
    tokensFetchState.message = "";
    tokensTableState.loading = false;
    tokensTableState.pendingReload = false;

    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
      searchDebounceHandle = null;
    }

    if (window.__tokensVisibilityHandler) {
      document.removeEventListener(
        "visibilitychange",
        window.__tokensVisibilityHandler
      );
      window.__tokensVisibilityHandler = null;
    }

    stopTokensAutoRefresh();
  }

  function createTokenRowHtml(token) {
    const mint = token.mint;
    const symbol = Utils.escapeHtml(token.symbol || "");
    const name = token.name ? Utils.escapeHtml(token.name) : "";
    const timeAgo = token.price_updated_at
      ? Utils.formatTimeAgo(token.price_updated_at, { fallback: "-" })
      : "N/A";
    const priceDisplay = Utils.formatPriceSol(token.price_sol, {
      fallback: "N/A",
    });
    const rawPrice = Number(token.price_sol);
    const priceTitle = Number.isFinite(rawPrice)
      ? rawPrice.toFixed(12)
      : token.price_sol ?? "";
    const priceIndicator = token.__priceDirection;
    const highlightActive =
      token.__priceHighlight === true &&
      (priceIndicator === "up" || priceIndicator === "down");
    const rowClassNames = ["token-row"];
    if (highlightActive) {
      rowClassNames.push("token-row--changed");
      rowClassNames.push(
        priceIndicator === "down" ? "token-row--down" : "token-row--up"
      );
    }
    const priceCellClassNames = ["num", "price-cell"];
    if (priceIndicator === "up") {
      priceCellClassNames.push("price-cell--up");
    } else if (priceIndicator === "down") {
      priceCellClassNames.push("price-cell--down");
    }
    const arrowHtml =
      priceIndicator === "up"
        ? '<span class="price-arrow price-arrow--up" aria-hidden="true">‚ñ≤</span>'
        : priceIndicator === "down"
        ? '<span class="price-arrow price-arrow--down" aria-hidden="true">‚ñº</span>'
        : '<span class="price-arrow price-arrow--flat" aria-hidden="true">‚ñ≤</span>';
    const priceCellContent =
      arrowHtml + '<span class="price-value">' + priceDisplay + "</span>";
    const liquidity = Utils.formatCurrencyUSD(token.liquidity_usd, {
      fallback: "‚Äî",
    });
    const vol24h = Utils.formatCurrencyUSD(token.volume_24h, { fallback: "‚Äî" });
    const fdv = Utils.formatCurrencyUSD(token.fdv, { fallback: "‚Äî" });
    const marketCap = Utils.formatCurrencyUSD(token.market_cap, {
      fallback: "‚Äî",
    });
    const ch1h = Utils.formatPercent(token.price_change_h1, {
      style: "token",
      fallback: "‚Äî",
    });
    const ch24h = Utils.formatPercent(token.price_change_h24, {
      style: "token",
      fallback: "‚Äî",
    });
    const security = renderSecurity(token.security_score, token.rugged);
    const status = renderStatusBadges(token);
    const logo = safeLogoHtml(token.logo_url, token.symbol);

    return `
                <tr class="${rowClassNames.join(
                  " "
                )}" data-mint="${mint}" onclick="openTokenDetail('${mint}')" style="cursor:pointer;" title="Click to view details">
                    <td>
                        <div style="display:flex; align-items:center; gap:12px; min-width:0;">
                            ${logo}
                            <div style="display:flex; flex-direction:column; gap:1px; min-width:0;">
                                <div style="font-weight:600; color:var(--link-color); font-size:0.95em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${symbol}</div>
                                <div style="font-size:0.8em; color:#94a3b8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${name}</div>
                            </div>
                        </div>
                    </td>
                    <td class="${priceCellClassNames.join(
                      " "
                    )}" style="font-weight:600;" title="${priceTitle}">${priceCellContent}</td>
                    <td class="num" title="${
                      token.liquidity_usd ?? ""
                    }">${liquidity}</td>
                    <td class="num" title="${
                      token.volume_24h ?? ""
                    }">${vol24h}</td>
                    <td class="num" title="${token.fdv ?? ""}">${fdv}</td>
                    <td class="num" title="${
                      token.market_cap ?? ""
                    }">${marketCap}</td>
                    <td class="num" title="${
                      token.price_change_h1 ?? ""
                    }">${ch1h}</td>
                    <td class="num" title="${
                      token.price_change_h24 ?? ""
                    }">${ch24h}</td>
                    <td class="num" title="${
                      token.security_score ?? ""
                    }">${security}</td>
                    <td>${status}</td>
                    <td style="font-size: 0.85em; color: #64748b;">${timeAgo}</td>
                    <td onclick="event.stopPropagation();">
                        <div class="dropdown-container" data-mint="${mint}">
                            <button class="dropdown-btn" type="button" onclick="Utils.toggleDropdown(event)" aria-label="Actions">‚ãÆ</button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyMint('${mint}')" class="dropdown-item">üìã Copy Mint</button>
                                <button onclick="Utils.openGMGN('${mint}')" class="dropdown-item">üîó Open GMGN</button>
                                <button onclick="Utils.openDexScreener('${mint}')" class="dropdown-item">üìä Open DexScreener</button>
                                <button onclick="Utils.openSolscan('${mint}')" class="dropdown-item">üîç Open Solscan</button>
                                <button onclick="openTokenDetail('${mint}')" class="dropdown-item">üîé View Details</button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function openDropdownMenu(btn, menu) {
    const rect = btn.getBoundingClientRect();
    const menuWidth = Math.max(200, menu.offsetWidth || 200);
    const viewportWidth = window.innerWidth;
    const rightSpace = viewportWidth - rect.right;

    menu.classList.add("show");
    menu.style.position = "fixed";
    menu.style.top = `${Math.round(rect.bottom + 4)}px`;
    if (rightSpace < menuWidth) {
      menu.style.left = `${Math.max(8, Math.round(rect.right - menuWidth))}px`;
      menu.style.right = "";
    } else {
      menu.style.left = `${Math.round(rect.left)}px`;
      menu.style.right = "";
    }
    menu.style.width = `${menuWidth}px`;
  }

  function setupSortableHeaders() {
    const thead = document.querySelector("#tokensTable thead");
    if (!thead) return;
    if (window.__tokensSortHeadersSetup) return;
    thead.addEventListener("click", (e) => {
      const th = e.target.closest("th.sortable");
      if (!th) return;
      const key = th.getAttribute("data-sort-key");
      if (!key) return;
      if (tokensState.sortBy === key) {
        tokensState.sortDir = tokensState.sortDir === "asc" ? "desc" : "asc";
      } else {
        tokensState.sortBy = key;
        tokensState.sortDir = key === "symbol" ? "asc" : "desc";
      }
      persistTokensSortState();
      updateSortIndicators();
      reloadTokensList("Sorting tokens...");
    });
    updateSortIndicators();
    window.__tokensSortHeadersSetup = true;
  }

  function updateSortIndicators() {
    const indicators = document.querySelectorAll(
      "#tokensTable .sort-indicator"
    );
    indicators.forEach((el) => {
      el.textContent = "";
    });
    const id = `sort-indicator-${tokensState.sortBy}`;
    const el = document.getElementById(id);
    if (el) el.textContent = tokensState.sortDir === "asc" ? "‚ñ≤" : "‚ñº";
  }

  function safeLogoHtml(url, symbol) {
    let fallback = "?";
    if (symbol && typeof symbol === "string") {
      for (const ch of symbol) {
        const u = ch.toUpperCase();
        if (/^[A-Z0-9]$/.test(u)) {
          fallback = u;
          break;
        }
      }
    }
    if (!url) {
      return `<div style="width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg, #1565c0 0%, #0f4c81 100%);color:white;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:0.85em;flex-shrink:0;">${fallback}</div>`;
    }
    const esc = (s) =>
      (s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    return `<img src="${esc(url)}" alt="${esc(
      symbol || ""
    )}" width="32" height="32" style="border-radius:8px;object-fit:cover;flex-shrink:0;box-shadow:0 1px 3px rgba(0,0,0,0.1);" onerror="fallbackLogo(this, '${fallback}')">`;
  }

  function fallbackLogo(img, letter) {
    try {
      img.onerror = null;
      const div = document.createElement("div");
      div.style.width = "32px";
      div.style.height = "32px";
      div.style.borderRadius = "8px";
      div.style.background =
        "linear-gradient(135deg, #1565c0 0%, #0f4c81 100%)";
      div.style.color = "white";
      div.style.display = "flex";
      div.style.alignItems = "center";
      div.style.justifyContent = "center";
      div.style.fontWeight = "700";
      div.style.fontSize = "0.85em";
      div.style.flexShrink = "0";
      div.textContent = letter && /^[A-Z0-9]$/.test(letter) ? letter : "?";
      img.replaceWith(div);
    } catch (_) {
      /* no-op */
    }
  }

  function renderSecurity(score, rugged) {
    if (rugged === true) {
      return `<span class="badge" style="background:#fee2e2;color:#b91c1c;border:1px solid #fecaca;">RUG</span>`;
    }
    if (score === null || score === undefined) return "‚Äî";
    let color = "#64748b";
    if (score >= 700) color = "#16a34a";
    else if (score >= 500) color = "#22c55e";
    else if (score >= 300) color = "#f59e0b";
    else color = "#ef4444";
    return `<span style="font-weight:600;color:${color}">${score}</span>`;
  }

  function renderStatusBadges(token) {
    const badges = [];
    if (token.has_pool_price)
      badges.push(
        '<span class="badge" style="background:#dbeafe;color:#1e40af;border:1px solid #bfdbfe;">POOL</span>'
      );
    if (token.has_ohlcv)
      badges.push(
        '<span class="badge" style="background:#dcfce7;color:#166534;border:1px solid #bbf7d0;">OHLCV</span>'
      );
    if (token.has_open_position)
      badges.push(
        '<span class="badge" style="background:#fde68a;color:#92400e;border:1px solid #fcd34d;">POS</span>'
      );
    if (token.blacklisted)
      badges.push(
        '<span class="badge" style="background:#fee2e2;color:#991b1b;border:1px solid #fecaca;">BL</span>'
      );
    return badges.join(" ");
  }

  function openTokenDetail(mint) {
    if (!mint) return;
    openTokenModal(mint).catch((err) => {
      console.error("Failed to open token modal:", err);
      Utils.showToast("‚ùå Failed to open token details", "error");
    });
  }
</script>

<div class="page-table">
  <div class="table-wrap">
    <table class="table" id="tokensTable">
      <thead>
        <tr>
          <th class="sortable" data-sort-key="symbol">
            <span class="sort-label"
              >Token
              <span class="sort-indicator" id="sort-indicator-symbol"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_sol">
            <span class="sort-label"
              >Price (SOL)
              <span class="sort-indicator" id="sort-indicator-price_sol"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="liquidity_usd">
            <span class="sort-label"
              >Liquidity
              <span
                class="sort-indicator"
                id="sort-indicator-liquidity_usd"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="volume_24h">
            <span class="sort-label"
              >24h Vol
              <span class="sort-indicator" id="sort-indicator-volume_24h"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="fdv">
            <span class="sort-label"
              >FDV <span class="sort-indicator" id="sort-indicator-fdv"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="market_cap">
            <span class="sort-label"
              >Mkt Cap
              <span class="sort-indicator" id="sort-indicator-market_cap"></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_change_h1">
            <span class="sort-label"
              >1h
              <span
                class="sort-indicator"
                id="sort-indicator-price_change_h1"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="price_change_h24">
            <span class="sort-label"
              >24h
              <span
                class="sort-indicator"
                id="sort-indicator-price_change_h24"
              ></span
            ></span>
          </th>
          <th class="sortable" data-sort-key="security_score">
            <span class="sort-label"
              >Security
              <span
                class="sort-indicator"
                id="sort-indicator-security_score"
              ></span
            ></span>
          </th>
          <th>Status</th>
          <th class="sortable" data-sort-key="updated_at">
            <span class="sort-label"
              >Updated
              <span class="sort-indicator" id="sort-indicator-updated_at"></span
            ></span>
          </th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="tokensTableBody">
        <tr>
          <td
            colspan="12"
            style="text-align: center; padding: 20px; color: #94a3b8"
          >
            <div class="loading-text">Loading tokens...</div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<!-- Token Details Modal -->
<div
  class="token-modal-overlay"
  id="tokenModal"
  onclick="closeTokenModal(event)"
>
  <div class="token-modal" onclick="event.stopPropagation()">
    <!-- Modal Header -->
    <div class="modal-header">
      <div class="modal-header-left">
        <img id="modalTokenLogo" class="modal-token-logo" src="" alt="" />
        <div class="modal-token-info">
          <div class="modal-token-symbol" id="modalTokenSymbol">SONIC</div>
          <div class="modal-token-name" id="modalTokenName">Sonic SVM</div>
        </div>
      </div>
      <div class="modal-price-info">
        <div class="modal-price" id="modalTokenPrice">0.00077622</div>
        <div class="modal-price-change positive" id="modalTokenChange">
          +2.12%
        </div>
      </div>
      <button
        class="modal-close-btn"
        onclick="closeTokenModal()"
        title="Close (ESC)"
      >
        √ó
      </button>
    </div>

    <!-- Modal Body -->
    <div class="modal-body token-detail-body">
      <!-- Main Content Area -->
      <div class="modal-main">
        <!-- Tabs Navigation -->
        <div class="modal-tabs">
          <button class="modal-tab active" onclick="switchModalTab('overview')">
            üìä Overview
          </button>
          <button class="modal-tab" onclick="switchModalTab('security')">
            üõ°Ô∏è Security
          </button>
          <button class="modal-tab" onclick="switchModalTab('chart')">
            üìà Chart
          </button>
          <button class="modal-tab" onclick="switchModalTab('transactions')">
            üí± Transactions
          </button>
        </div>

        <!-- Tab Content -->
        <div class="modal-content">
          <!-- Overview Tab -->
          <div class="tab-pane active" id="tab-overview">
            <div class="metrics-grid">
              <div class="metric-card">
                <div class="metric-card-header">üßæ Token Profile</div>
                <div class="metric-row" title="Full mint address">
                  <span class="metric-label">Mint</span>
                  <span
                    class="metric-value"
                    id="detail-mint"
                    style="
                      font-size: 0.75em;
                      letter-spacing: 0.3px;
                      overflow: hidden;
                      text-overflow: ellipsis;
                      max-width: 160px;
                    "
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Decimals</span>
                  <span class="metric-value" id="detail-decimals">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Verified</span>
                  <span class="metric-value" id="detail-verified">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Blacklisted</span>
                  <span class="metric-value" id="detail-blacklisted">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Launch</span>
                  <span class="metric-value" id="detail-launch-date">‚Äî</span>
                </div>
              </div>
              <div class="metric-card">
                <div class="metric-card-header">üí∞ Market Data</div>
                <div class="metric-row">
                  <span class="metric-label">Liquidity</span>
                  <span class="metric-value" id="detail-liquidity"
                    >$628.66K</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 24h</span>
                  <span class="metric-value" id="detail-volume24h"
                    >$124.32K</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 6h</span>
                  <span class="metric-value" id="detail-volume6h">$45.67K</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Volume 1h</span>
                  <span class="metric-value" id="detail-volume1h">$12.45K</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">FDV</span>
                  <span class="metric-value" id="detail-fdv">$432.41M</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Market Cap</span>
                  <span class="metric-value" id="detail-marketcap"
                    >$64.86M</span
                  >
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üèä Pool Metrics</div>
                <div class="metric-row">
                  <span class="metric-label">DEX</span>
                  <span class="metric-value" id="detail-dex">Raydium CPMM</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Pool Address</span>
                  <span
                    class="metric-value"
                    id="detail-pool"
                    style="font-size: 0.75em"
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">SOL Reserves</span>
                  <span class="metric-value" id="detail-sol-reserves"
                    >3,241.5</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Token Reserves</span>
                  <span class="metric-value" id="detail-token-reserves"
                    >84.2M</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Confidence</span>
                  <span class="metric-value" id="detail-confidence">0.95</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Pool Age</span>
                  <span class="metric-value" id="detail-pool-age">2h 15m</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üìä Price Changes</div>
                <div class="metric-row">
                  <span class="metric-label">5 minutes</span>
                  <span class="metric-value" id="detail-change5m">+2.5%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">1 hour</span>
                  <span class="metric-value" id="detail-change1h">-1.2%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">6 hours</span>
                  <span class="metric-value" id="detail-change6h">+5.8%</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">24 hours</span>
                  <span class="metric-value" id="detail-change24h">+15.3%</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üí± Transaction Flow</div>
                <div class="metric-row">
                  <span class="metric-label">Buys 24h</span>
                  <span class="metric-value" id="detail-buys24h">432</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Sells 24h</span>
                  <span class="metric-value" id="detail-sells24h">389</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Buy/Sell Ratio</span>
                  <span class="metric-value" id="detail-ratio">1.11</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Net Flow</span>
                  <span class="metric-value" id="detail-netflow">+43 Buys</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Security Tab -->
          <div class="tab-pane" id="tab-security">
            <div class="security-badge excellent" id="security-badge">
              <span>üõ°Ô∏è</span>
              <span
                >Security Score: <span id="security-score-value">35593</span> /
                40000</span
              >
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">Overall Security Analysis</div>
              <div class="progress-bar">
                <div
                  class="progress-fill"
                  id="security-progress"
                  style="width: 89%"
                ></div>
              </div>
              <div
                style="margin-top: 12px; color: #94a3b8; font-size: 0.9em"
                id="security-status"
              >
                ‚úÖ This token passes major security checks
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üîë Token Authorities</div>
              <div class="metric-row">
                <span class="metric-label">Mint Authority</span>
                <span
                  class="metric-value"
                  id="detail-mint-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
              <div class="metric-row">
                <span class="metric-label">Freeze Authority</span>
                <span
                  class="metric-value"
                  id="detail-freeze-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üë• Holder Distribution</div>
              <div class="metric-row">
                <span class="metric-label">Total Holders</span>
                <span class="metric-value" id="detail-holders">1,234</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Top 10 Concentration</span>
                <span class="metric-value" id="detail-top10">45.2%</span>
              </div>
            </div>

            <div class="metric-card-header" style="margin-bottom: 12px">
              ‚ö†Ô∏è Risk Factors
            </div>
            <div class="risk-list" id="risk-factors-list">
              <!-- Risk items will be populated here -->
            </div>
          </div>

          <!-- Chart Tab -->
          <div class="tab-pane" id="tab-chart">
            <div
              id="token-chart-container"
              style="
                height: 500px;
                width: 100%;
                position: relative;
                background: #1a1a1a;
                border-radius: 8px;
                overflow: hidden;
              "
            >
              <div id="token-chart" style="width: 100%; height: 100%"></div>
              <div id="chart-loading" class="chart-loading">
                <div class="spinner"></div>
                <p>Loading chart data...</p>
              </div>
              <div id="chart-error" class="chart-error" style="display: none">
                <p>Failed to load chart data</p>
                <button onclick="retryChartLoad()">Retry</button>
              </div>
            </div>

            <!-- Chart Controls -->
            <div class="chart-controls">
              <div class="timeframe-selector">
                <button class="tf-btn active" data-tf="1m">1m</button>
                <button class="tf-btn" data-tf="5m">5m</button>
                <button class="tf-btn" data-tf="15m">15m</button>
                <button class="tf-btn" data-tf="1h">1h</button>
                <button class="tf-btn" data-tf="4h">4h</button>
                <button class="tf-btn" data-tf="1d">1D</button>
              </div>

              <div class="indicator-toggles">
                <label
                  ><input type="checkbox" id="show-volume" checked />
                  Volume</label
                >
                <label><input type="checkbox" id="show-ma20" /> MA(20)</label>
                <label><input type="checkbox" id="show-ma50" /> MA(50)</label>
              </div>
            </div>
          </div>

          <!-- Transactions Tab -->
          <div class="tab-pane" id="tab-transactions">
            <div class="metric-card">
              <div class="metric-card-header">üìú Recent Transactions</div>
              <div
                id="transactions-list"
                style="color: #94a3b8; text-align: center; padding: 40px"
              >
                Loading recent transactions...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="modal-sidebar">
        <div class="sidebar-section">
          <div class="sidebar-section-title">‚ö° Live Metrics</div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Price (SOL)</span>
            <span class="sidebar-metric-value" id="sidebar-price"
              >0.00077622</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">24h Volume</span>
            <span class="sidebar-metric-value" id="sidebar-volume"
              >$124.3K</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Liquidity</span>
            <span class="sidebar-metric-value" id="sidebar-liq">$628.7K</span>
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Market Cap</span>
            <span class="sidebar-metric-value" id="sidebar-mcap">$64.86M</span>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üîó Quick Actions</div>
          <div class="quick-actions">
            <button
              class="quick-action-btn"
              id="action-copy-mint"
              onclick="copyMintFromModal()"
            >
              üìã Copy Mint Address
            </button>
            <button
              class="quick-action-btn"
              id="action-dexscreener"
              onclick="openDexScreenerFromModal()"
            >
              üìä Open DexScreener ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-gmgn"
              onclick="openGMGNFromModal()"
            >
              üîó Open GMGN ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-solscan"
              onclick="openSolscanFromModal()"
            >
              üîç Open Solscan ‚Üí
            </button>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üè∑Ô∏è Status Flags</div>
          <div
            id="sidebar-badges"
            style="display: flex; flex-wrap: wrap; gap: 6px"
          >
            <!-- Badges will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // ============================================================================
  // CHART INTEGRATION
  // ============================================================================

  let tokenChartManager = null;

  /**
   * Show chart error message
   * @param {string} message - Error message to display
   */
  function showChartError(message) {
    const loading = document.getElementById("chart-loading");
    const error = document.getElementById("chart-error");

    console.log("[TokenChart] showChartError:", message);

    if (loading) loading.style.display = "none";
    if (error) {
      error.style.display = "flex";
      const errorText = error.querySelector("p");
      if (errorText) {
        errorText.textContent = message;
      }
    }
  }

  /**
   * Initialize token chart in modal
   * @param {string} mint - Token mint address
   */
  async function initTokenChart(mint) {
    console.log("[TokenChart] Initializing chart for mint:", mint);

    // Destroy existing chart if any
    if (tokenChartManager) {
      tokenChartManager.destroy();
      tokenChartManager = null;
    }

    // CRITICAL FIX: Validate token has OHLCV data before attempting to load
    const tokenData = tokenModalData?.token || getTokenByMint(mint);
    if (!tokenData?.has_ohlcv) {
      console.warn("[TokenChart] Token does not have OHLCV data available:", {
        mint,
        has_ohlcv: tokenData?.has_ohlcv,
        tokenData: tokenData,
      });
      showChartError("üìä OHLCV data not available for this token");
      return;
    }

    console.log(
      "[TokenChart] Token has OHLCV data, proceeding with initialization"
    );

    // Get current theme
    const currentTheme =
      document.documentElement.getAttribute("data-theme") || "dark";

    try {
      // Create chart manager
      tokenChartManager = new ChartManager("token-chart", {
        theme: currentTheme,
        height: 500,
        responsive: true,
        showVolume: document.getElementById("show-volume")?.checked !== false,
        indicators: [],
      });

      // Load token data with default timeframe
      const activeTimeframe =
        document.querySelector(".tf-btn.active")?.dataset.tf || "5m";
      await tokenChartManager.loadToken(mint, activeTimeframe);

      // Setup timeframe buttons
      setupTimeframeButtons(mint);

      // Setup indicator toggles
      setupIndicatorToggles();

      console.log("[TokenChart] Chart initialized successfully");
    } catch (error) {
      console.error("[TokenChart] Initialization error:", error);
      showChartError(`Failed to load chart: ${error.message}`);
    }
  }

  /**
   * Setup timeframe button handlers
   * @param {string} mint - Token mint address
   */
  function setupTimeframeButtons(mint) {
    const tfButtons = document.querySelectorAll(".tf-btn");
    tfButtons.forEach((btn) => {
      btn.addEventListener("click", async (e) => {
        // Update active state
        tfButtons.forEach((b) => b.classList.remove("active"));
        e.target.classList.add("active");

        // Change timeframe
        const timeframe = e.target.dataset.tf;
        if (tokenChartManager) {
          await tokenChartManager.setTimeframe(timeframe);
        }
      });
    });
  }

  /**
   * Setup indicator toggle handlers
   */
  function setupIndicatorToggles() {
    const volumeToggle = document.getElementById("show-volume");
    const ma20Toggle = document.getElementById("show-ma20");
    const ma50Toggle = document.getElementById("show-ma50");

    if (volumeToggle) {
      volumeToggle.addEventListener("change", (e) => {
        if (tokenChartManager) {
          tokenChartManager.toggleOverlay("volume");
        }
      });
    }

    if (ma20Toggle) {
      ma20Toggle.addEventListener("change", async (e) => {
        if (tokenChartManager) {
          if (e.target.checked) {
            await tokenChartManager.addIndicator("SMA", {
              period: 20,
              color: "#2196F3",
            });
          } else {
            tokenChartManager.removeIndicator("indicator:SMA:20");
          }
        }
      });
    }

    if (ma50Toggle) {
      ma50Toggle.addEventListener("change", async (e) => {
        if (tokenChartManager) {
          if (e.target.checked) {
            await tokenChartManager.addIndicator("SMA", {
              period: 50,
              color: "#FF9800",
            });
          } else {
            tokenChartManager.removeIndicator("indicator:SMA:50");
          }
        }
      });
    }
  }

  /**
   * Retry chart load (called from error button)
   */
  function retryChartLoad() {
    if (currentModalMint) {
      initTokenChart(currentModalMint);
    }
  }

  /**
   * Update chart theme when dashboard theme changes
   */
  function updateChartTheme(theme) {
    if (tokenChartManager) {
      tokenChartManager.setTheme(theme);
    }
  }

  // Listen for theme changes
  if (window.ThemeManager) {
    const originalSetTheme = window.ThemeManager.setTheme;
    window.ThemeManager.setTheme = function (theme) {
      originalSetTheme.call(window.ThemeManager, theme);
      updateChartTheme(theme);
    };
  }

  // Make retryChartLoad globally accessible
  window.retryChartLoad = retryChartLoad;

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initTokensPage();
</script>
