<style>
  .token-row {
    transition: background-color 0.45s ease;
  }

  .token-row--changed {
    animation: token-row-flash 1.25s ease-out;
  }

  .token-row--up {
    --token-glow-color: rgba(34, 197, 94, 0.2);
  }

  .token-row--down {
    --token-glow-color: rgba(239, 68, 68, 0.2);
  }

  @keyframes token-row-flash {
    0% {
      background-color: var(--token-glow-color, rgba(59, 130, 246, 0.14));
    }
    75% {
      background-color: rgba(15, 23, 42, 0.08);
    }
    100% {
      background-color: transparent;
    }
  }

  .price-cell {
    text-align: right;
  }

  .price-cell__inner {
    display: inline-flex;
    align-items: center;
    justify-content: flex-end;
    gap: 6px;
    font-variant-numeric: tabular-nums;
    position: relative;
  }

  .price-value {
    transition: color 0.25s ease;
    padding-left: 1.1em;
    display: inline-block;
  }

  .price-cell__inner--up .price-value {
    color: #22c55e;
  }

  .price-cell__inner--down .price-value {
    color: #ef4444;
  }

  .price-arrow {
    display: inline-block;
    width: 0.9em;
    min-width: 0.9em;
    max-width: 0.9em;
    font-size: 0.85em;
    transform: translateY(-1px);
    transition: opacity 0.25s ease;
    text-align: center;
    position: absolute;
    left: 0;
  }

  .price-arrow--up {
    color: #22c55e;
  }

  .price-arrow--down {
    color: #ef4444;
  }
</style>
<script>
  var TOKENS_DEFAULT_PAGE_SIZE = Number("__TOKENS_DEFAULT_PAGE_SIZE__") || 50;
  var TOKENS_MAX_PAGE_SIZE =
    Number("__TOKENS_MAX_PAGE_SIZE__") || TOKENS_DEFAULT_PAGE_SIZE;
  var DEFAULT_TOKENS_VIEW = "pool";
  var TOKENS_VIEW_DEFS = [
    { id: "pool", label: "üíß Pool Service" },
    { id: "all", label: "üìã All Tokens" },
    { id: "passed", label: "‚úÖ Passed" },
    { id: "rejected", label: "‚õî Rejected" },
    { id: "blacklisted", label: "üö´ Blacklisted" },
    { id: "positions", label: "üìä Positions" },
    { id: "secure", label: "üõ°Ô∏è Secure" },
    { id: "recent", label: "üÜï Recent" },
  ];
  var TOKENS_VIEWS = TOKENS_VIEW_DEFS.map(function (view) {
    return view.id;
  });
  var TOKENS_SORT_KEYS = [
    "symbol",
    "price_sol",
    "liquidity_usd",
    "volume_24h",
    "fdv",
    "market_cap",
    "price_change_h1",
    "price_change_h24",
    "security_score",
    "updated_at",
  ];
  var DEFAULT_SORT_KEY = "symbol";
  var DEFAULT_SORT_DIR = "asc";
  var VIEW_LABELS = {
    pool: "with available prices",
    all: "in database",
    passed: "that passed filtering",
    rejected: "rejected by filtering",
    blacklisted: "blacklisted",
    positions: "with open positions",
    secure: "secure",
    recent: "recently updated",
  };

  var tokensState = window.tokensState || {
    view: DEFAULT_TOKENS_VIEW,
    sortBy: DEFAULT_SORT_KEY,
    sortDir: DEFAULT_SORT_DIR,
    searchTerm: "",
  };
  window.tokensState = tokensState;
  var TOKENS_COLUMN_DEFINITIONS = [
    {
      id: "token",
      label: "Token",
      sortKey: "symbol",
      defaultVisible: true,
      required: true,
      minWidth: 240,
      defaultWidth: 260,
      align: "left",
      headerAlign: "left",
    },
    {
      id: "price_sol",
      label: "Price (SOL)",
      sortKey: "price_sol",
      defaultVisible: true,
      minWidth: 140,
      defaultWidth: 150,
      align: "right",
      headerAlign: "right",
      cellClass: "num price-cell align-right",
    },
    {
      id: "liquidity_usd",
      label: "Liquidity",
      sortKey: "liquidity_usd",
      defaultVisible: true,
      minWidth: 120,
      defaultWidth: 140,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "volume_24h",
      label: "24h Vol",
      sortKey: "volume_24h",
      defaultVisible: true,
      minWidth: 110,
      defaultWidth: 140,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "fdv",
      label: "FDV",
      sortKey: "fdv",
      defaultVisible: true,
      minWidth: 110,
      defaultWidth: 140,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "market_cap",
      label: "Mkt Cap",
      sortKey: "market_cap",
      defaultVisible: true,
      minWidth: 110,
      defaultWidth: 140,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "price_change_h1",
      label: "1h",
      sortKey: "price_change_h1",
      defaultVisible: true,
      minWidth: 90,
      defaultWidth: 100,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "price_change_h24",
      label: "24h",
      sortKey: "price_change_h24",
      defaultVisible: true,
      minWidth: 90,
      defaultWidth: 100,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "security_score",
      label: "Security",
      sortKey: "security_score",
      defaultVisible: true,
      minWidth: 100,
      defaultWidth: 110,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
    {
      id: "status",
      label: "Status",
      defaultVisible: true,
      minWidth: 120,
      defaultWidth: 140,
      align: "left",
      headerAlign: "left",
    },
    {
      id: "updated_at",
      label: "Updated",
      sortKey: "updated_at",
      defaultVisible: true,
      minWidth: 110,
      defaultWidth: 130,
      align: "left",
      headerAlign: "left",
      cellClass: "tokens-updated-text",
    },
    {
      id: "actions",
      label: "Actions",
      defaultVisible: true,
      minWidth: 80,
      defaultWidth: 88,
      maxWidth: 120,
      align: "center",
      headerAlign: "center",
      resizable: false,
    },
    {
      id: "total_holders",
      label: "Holders",
      sortKey: "total_holders",
      defaultVisible: false,
      minWidth: 110,
      defaultWidth: 120,
      align: "right",
      headerAlign: "right",
      cellClass: "num align-right",
    },
  ];

  var TOKENS_DEFAULT_VISIBLE_COLUMN_IDS = TOKENS_COLUMN_DEFINITIONS.filter(
    function (column) {
      return column.required || column.defaultVisible !== false;
    }
  ).map(function (column) {
    return column.id;
  });

  var tokensColumnManager = window.tokensColumnManager || null;
  window.tokensColumnManager = tokensColumnManager;

  var tokensColumnDialogState = window.tokensColumnDialogState || {
    root: null,
    list: null,
    checkboxMap: new Map(),
    tempVisibleIds: new Set(),
    initialized: false,
    previouslyFocused: null,
    applyButton: null,
    resetButton: null,
    closeButton: null,
  };
  if (!(tokensColumnDialogState.checkboxMap instanceof Map)) {
    tokensColumnDialogState.checkboxMap = new Map();
  }
  if (!(tokensColumnDialogState.tempVisibleIds instanceof Set)) {
    tokensColumnDialogState.tempVisibleIds = new Set();
  }
  window.tokensColumnDialogState = tokensColumnDialogState;

  var TOKENS_SCROLL_GUARD_HTML =
    '<tr id="tokens-scroll-guard" class="scroll-guard-row"><td class="scroll-guard-cell"></td></tr>';

  var tokensTableState = window.tokensTableState || {
    items: [],
    pageSize: 0,
    currentPage: 0,
    totalPages: 0,
    totalCount: 0,
    loading: false,
    pendingReload: false,
    scrollObserver: null,
    scrollContainer: null,
  };

  window.tokensTableState = tokensTableState;

  var allTokensData = tokensTableState.items;
  var currentModalMint = null;
  var tokenModalData = null;
  var searchDebounceHandle = null;
  var tokensFetchState = window.tokensFetchState || {
    inProgress: false,
    message: "",
    abortController: null,
  };
  window.tokensFetchState = tokensFetchState;
  var tokensAutoRefreshState = window.tokensAutoRefreshState || {
    poller: null,
  };
  window.tokensAutoRefreshState = tokensAutoRefreshState;
  var tokensPriceState = window.tokensPriceState || {
    lastPrices: new Map(),
    lastDirections: new Map(),
    lastChangeAt: new Map(),
  };
  if (!(tokensPriceState.lastPrices instanceof Map)) {
    tokensPriceState.lastPrices = new Map();
  }
  if (!(tokensPriceState.lastDirections instanceof Map)) {
    tokensPriceState.lastDirections = new Map();
  }
  if (!(tokensPriceState.lastChangeAt instanceof Map)) {
    tokensPriceState.lastChangeAt = new Map();
  }
  window.tokensPriceState = tokensPriceState;

  // Enhanced populateTokenModal function with improvements
  function populateTokenModal(token, detail) {
    if (!token) return;

    const detailData = detail || {};
    const toNumber = (value) => {
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };
    const pick = (...values) => {
      for (let i = 0; i < values.length; i += 1) {
        const value = values[i];
        if (value !== undefined && value !== null && value !== "") {
          return value;
        }
      }
      return undefined;
    };
    const normalizeTxnPeriod = (period) => {
      if (!period) return null;
      const buys = toNumber(period.buys);
      const sells = toNumber(period.sells);
      if (!Number.isFinite(buys) && !Number.isFinite(sells)) {
        return null;
      }
      return { buys, sells };
    };

    const priceSol = toNumber(pick(detailData.price_sol, token.price_sol));
    const priceUsd = toNumber(detailData.price_usd);
    const priceChange24h = toNumber(
      pick(
        detailData.price_change_periods?.h24,
        detailData.price_change_h24,
        token.price_change_h24
      )
    );
    const changeClass = Number.isFinite(priceChange24h)
      ? priceChange24h > 0
        ? "positive"
        : priceChange24h < 0
        ? "negative"
        : ""
      : "";

    const taglineValue = pick(detailData.tagline);
    const descriptionText = pick(detailData.description);
    const websiteUrl = pick(detailData.website);
    const boostsActive = toNumber(detailData.boosts_active);
    const securityScore = toNumber(detailData.security_score);
    const rugged = detailData.rugged === true;
    const isVerified = detailData.verified === true;
    const isBlacklisted = detailData.blacklisted ?? token.blacklisted;

    const statusFlags = {
      has_pool_price: detailData.has_pool_price ?? token.has_pool_price,
      has_ohlcv: detailData.has_ohlcv ?? token.has_ohlcv,
      has_open_position:
        detailData.has_open_position ?? token.has_open_position,
      blacklisted: isBlacklisted,
      boosts_active: boostsActive,
    };

    const logoEl = document.getElementById("modalTokenLogo");
    const logoUrl = pick(detailData.logo_url, token.logo_url);
    if (logoEl) {
      if (logoUrl) {
        logoEl.src = logoUrl;
        logoEl.style.display = "block";
      } else {
        logoEl.src = "";
        logoEl.style.display = "none";
      }
    }

    const taglineEl = document.getElementById("modalTokenTagline");
    if (taglineEl) {
      if (taglineValue) {
        taglineEl.textContent = taglineValue;
        taglineEl.classList.add("is-visible");
      } else {
        taglineEl.textContent = "";
        taglineEl.classList.remove("is-visible");
      }
    }

    const headerBadgesEl = document.getElementById("modalTokenBadges");
    if (headerBadgesEl) {
      headerBadgesEl.innerHTML = renderModalHeaderBadges({
        verified: isVerified,
        rugged,
        blacklisted: isBlacklisted,
        securityScore,
        hasPoolPrice: statusFlags.has_pool_price,
        hasOpenPosition: statusFlags.has_open_position,
      });
    }

    const websiteBtn = document.getElementById("action-website");
    if (websiteBtn) {
      if (websiteUrl) {
        websiteBtn.disabled = false;
        websiteBtn.classList.remove("quick-action-btn--disabled");
      } else {
        websiteBtn.disabled = true;
        websiteBtn.classList.add("quick-action-btn--disabled");
      }
    }

    Utils.setText(
      "modalTokenSymbol",
      pick(detailData.symbol, token.symbol, "‚Äî")
    );
    Utils.setText("modalTokenName", pick(detailData.name, token.name, "‚Äî"));

    const headerTags = Array.from(
      new Set(
        []
          .concat(detailData.pair_labels || [])
          .concat(detailData.tags || [])
          .filter(Boolean)
      )
    ).slice(0, 5);
    const tagsEl = document.getElementById("modalTokenTags");
    if (tagsEl) {
      tagsEl.innerHTML = headerTags
        .map((tag) => `<span class="tag-badge">${Utils.escapeHtml(tag)}</span>`)
        .join("");
    }

    Utils.setText(
      "modalTokenPrice",
      priceSol !== null
        ? Utils.formatPriceSol(priceSol, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "modalTokenPriceUsd",
      priceUsd !== null
        ? Utils.formatCurrencyUSD(priceUsd, { fallback: "‚Äî" })
        : "‚Äî"
    );

    const changeEl = document.getElementById("modalTokenChange");
    if (changeEl) {
      changeEl.textContent =
        priceChange24h !== null
          ? Utils.formatPercentValue(priceChange24h, { fallback: "‚Äî" })
          : "‚Äî";
      changeEl.classList.remove("positive", "negative");
      if (changeClass) changeEl.classList.add(changeClass);
    }

    Utils.setText(
      "summary-price-sol",
      priceSol !== null
        ? Utils.formatPriceSol(priceSol, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "summary-price-usd",
      priceUsd !== null
        ? Utils.formatCurrencyUSD(priceUsd, { fallback: "‚Äî" })
        : "‚Äî"
    );

    const descriptionEl = document.getElementById("detail-description");
    if (descriptionEl) {
      if (descriptionText) {
        descriptionEl.textContent = descriptionText;
        descriptionEl.classList.remove("is-empty");
      } else {
        descriptionEl.textContent = "No project overview available.";
        descriptionEl.classList.add("is-empty");
      }
    }
    const summaryDeltaEl = document.getElementById("summary-change-24h");
    if (summaryDeltaEl) {
      summaryDeltaEl.textContent =
        priceChange24h !== null
          ? Utils.formatPercentValue(priceChange24h, { fallback: "‚Äî" })
          : "‚Äî";
      applyDeltaClass(summaryDeltaEl, priceChange24h);
    }

    const liquidityValue = toNumber(
      pick(detailData.liquidity_usd, token.liquidity_usd)
    );
    Utils.setText(
      "summary-liquidity",
      liquidityValue !== null
        ? Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
        : "‚Äî"
    );

    const confidence = toNumber(detailData.price_confidence);
    Utils.setText(
      "summary-confidence",
      confidence !== null
        ? `Confidence ${(Math.max(0, Math.min(1, confidence)) * 100).toFixed(
            1
          )}%`
        : "Confidence ‚Äî"
    );

    const priceUpdatedAt = pick(detailData.price_updated_at);
    Utils.setText(
      "summary-last-updated",
      priceUpdatedAt !== undefined && priceUpdatedAt !== null
        ? `Price updated ${Utils.formatTimeAgo(priceUpdatedAt, {
            fallback: "‚Äî",
          })}`
        : "Price updated ‚Äî"
    );

    const volumePeriods = {
      m5: toNumber(pick(detailData.volume_periods?.m5)),
      h1: toNumber(pick(detailData.volume_periods?.h1)),
      h6: toNumber(pick(detailData.volume_periods?.h6)),
      h24: toNumber(
        pick(
          detailData.volume_periods?.h24,
          detailData.volume_24h,
          token.volume_24h
        )
      ),
    };

    const volume24hValue = volumePeriods.h24;
    Utils.setText(
      "summary-volume",
      volume24hValue !== null
        ? Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "summary-volume-1h",
      volumePeriods.h1 !== null
        ? `1h ${Utils.formatCurrencyUSD(volumePeriods.h1, { fallback: "‚Äî" })}`
        : "1h ‚Äî"
    );
    Utils.setText(
      "summary-volume-5m",
      volumePeriods.m5 !== null
        ? `5m ${Utils.formatCurrencyUSD(volumePeriods.m5, { fallback: "‚Äî" })}`
        : "5m ‚Äî"
    );

    const txnPeriods = {
      m5: normalizeTxnPeriod(detailData.txn_periods?.m5 || detailData.txns?.m5),
      h1: normalizeTxnPeriod(detailData.txn_periods?.h1 || detailData.txns?.h1),
      h6: normalizeTxnPeriod(detailData.txn_periods?.h6 || detailData.txns?.h6),
      h24: normalizeTxnPeriod(
        detailData.txn_periods?.h24 || detailData.txns?.h24
      ),
    };

    const buys24h = toNumber(pick(detailData.buys_24h, txnPeriods.h24?.buys));
    const sells24h = toNumber(
      pick(detailData.sells_24h, txnPeriods.h24?.sells)
    );
    const netFlow24h =
      toNumber(detailData.net_flow_24h) ??
      (Number.isFinite(buys24h) && Number.isFinite(sells24h)
        ? buys24h - sells24h
        : null);
    const ratio24h =
      toNumber(detailData.buy_sell_ratio_24h) ??
      (Number.isFinite(buys24h) && Number.isFinite(sells24h) && sells24h !== 0
        ? buys24h / sells24h
        : null);

    Utils.setText(
      "summary-netflow",
      netFlow24h !== null
        ? `${netFlow24h > 0 ? "+" : netFlow24h < 0 ? "-" : ""}${Math.abs(
            Math.round(netFlow24h)
          )}`
        : "‚Äî"
    );
    Utils.setText(
      "summary-buys-sells",
      `Buys ${Number.isFinite(buys24h) ? Math.round(buys24h) : "‚Äî"} / Sells ${
        Number.isFinite(sells24h) ? Math.round(sells24h) : "‚Äî"
      }`
    );
    Utils.setText(
      "summary-ratio",
      ratio24h !== null ? `Ratio ${ratio24h.toFixed(2)}` : "Ratio ‚Äî"
    );

    const priceChangePeriods = {
      m5: toNumber(
        pick(detailData.price_change_periods?.m5, detailData.price_change_m5)
      ),
      h1: toNumber(
        pick(
          detailData.price_change_periods?.h1,
          detailData.price_change_h1,
          token.price_change_h1
        )
      ),
      h6: toNumber(
        pick(detailData.price_change_periods?.h6, detailData.price_change_h6)
      ),
      h24: priceChange24h,
    };

    Utils.setHtml("detail-price-table", buildPriceTable(priceChangePeriods));
    Utils.setHtml(
      "detail-activity-table",
      buildActivityTable(volumePeriods, txnPeriods)
    );

    const mintValue = pick(detailData.mint, token.mint);
    const mintEl = document.getElementById("detail-mint");
    if (mintEl) {
      mintEl.textContent = mintValue || "‚Äî";
      mintEl.title = mintValue || "";
    }

    Utils.setText(
      "detail-decimals",
      pick(detailData.decimals, token.decimals, "‚Äî")
    );
    Utils.setText(
      "detail-verified",
      Utils.formatBooleanFlag(detailData.verified, "‚Äî")
    );
    Utils.setText(
      "detail-blacklisted",
      Utils.formatBooleanFlag(detailData.blacklisted ?? token.blacklisted, "‚Äî")
    );

    const launchTimestamp = pick(
      detailData.pair_created_at,
      detailData.created_at
    );
    Utils.setText(
      "detail-launch-date",
      launchTimestamp !== undefined && launchTimestamp !== null
        ? Utils.formatTimestamp(launchTimestamp, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-last-updated",
      detailData.last_updated !== undefined && detailData.last_updated !== null
        ? Utils.formatTimestamp(detailData.last_updated, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-boosts",
      boostsActive !== null
        ? String(Math.max(0, Math.round(boostsActive)))
        : "‚Äî"
    );

    Utils.setText(
      "detail-liquidity",
      liquidityValue !== null
        ? Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-base-liquidity",
      Utils.formatCompactNumber(detailData.liquidity_base, 2, "‚Äî")
    );
    Utils.setText(
      "detail-quote-liquidity",
      Utils.formatCompactNumber(detailData.liquidity_quote, 2, "‚Äî")
    );
    Utils.setText(
      "detail-fdv",
      Utils.formatCurrencyUSD(detailData.fdv, { fallback: "‚Äî" })
    );
    Utils.setText(
      "detail-marketcap",
      Utils.formatCurrencyUSD(detailData.market_cap, { fallback: "‚Äî" })
    );

    Utils.setText("detail-dex", pick(detailData.pool_dex, "‚Äî"));

    const poolLinkEl = document.getElementById("detail-pool-link");
    const poolAddress = pick(detailData.pool_address, detailData.pool?.address);
    const pairUrl = detailData.pair_url;
    if (poolLinkEl) {
      if (pairUrl || poolAddress) {
        poolLinkEl.textContent = poolAddress
          ? formatAddress(poolAddress, 6)
          : "Open Pool";
        poolLinkEl.href =
          pairUrl || `https://solscan.io/account/${poolAddress}`;
        poolLinkEl.classList.remove("metric-link--disabled");
        poolLinkEl.title = poolAddress || poolLinkEl.textContent;
      } else {
        poolLinkEl.textContent = "‚Äî";
        poolLinkEl.removeAttribute("href");
        poolLinkEl.removeAttribute("title");
        poolLinkEl.classList.add("metric-link--disabled");
      }
    }

    Utils.setText(
      "detail-sol-reserves",
      Utils.formatCompactNumber(detailData.pool_reserves_sol, 2, "‚Äî")
    );
    Utils.setText(
      "detail-token-reserves",
      Utils.formatCompactNumber(detailData.pool_reserves_token, 2, "‚Äî")
    );
    Utils.setText(
      "detail-confidence",
      confidence !== null ? confidence.toFixed(2) : "‚Äî"
    );
    Utils.setText(
      "detail-price-updated",
      priceUpdatedAt !== undefined && priceUpdatedAt !== null
        ? Utils.formatTimeAgo(priceUpdatedAt, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "detail-pool-age",
      launchTimestamp !== undefined && launchTimestamp !== null
        ? Utils.formatTimeAgo(launchTimestamp, { fallback: "‚Äî" })
        : "‚Äî"
    );

    renderBadgeList("detail-tag-badges", detailData.tags, "No tags assigned");
    renderBadgeList(
      "detail-label-badges",
      detailData.pair_labels,
      "No pool labels"
    );

    const badge = document.getElementById("security-badge");
    if (badge) {
      const statusClass = rugged
        ? "critical"
        : securityScore >= 700
        ? "excellent"
        : securityScore >= 500
        ? "good"
        : securityScore >= 300
        ? "warning"
        : "critical";
      badge.className = `security-badge ${statusClass}`.trim();
    }

    const progress = document.getElementById("security-progress");
    if (progress) {
      let pct = toNumber(detailData.security_score_normalized);
      if (!Number.isFinite(pct)) {
        pct = securityScore !== null ? securityScore / 10 : 0;
      }
      if (!Number.isFinite(pct)) pct = 0;
      const safePct = Math.max(0, Math.min(100, pct));
      progress.style.width = `${safePct}%`;
    }

    Utils.setHtml(
      "security-score-value",
      securityScore !== null ? `${securityScore}` : "‚Äî"
    );
    const securitySummary =
      detailData.security_summary ||
      (rugged
        ? "‚ö†Ô∏è Token flagged as rugged. Investigate before trading."
        : "No security summary available.");
    Utils.setHtml("security-status", securitySummary);
    Utils.setText("detail-mint-auth", detailData.mint_authority ?? "Unknown");
    Utils.setText(
      "detail-freeze-auth",
      detailData.freeze_authority ?? "Unknown"
    );
    Utils.setText("detail-holders", detailData.total_holders ?? "‚Äî");

    const top10Raw = toNumber(detailData.top_10_concentration);
    if (top10Raw !== null) {
      const display = top10Raw <= 1 ? top10Raw * 100 : top10Raw;
      Utils.setText("detail-top10", `${display.toFixed(2)}%`);
    } else {
      Utils.setText("detail-top10", "‚Äî");
    }

    Utils.setHtml(
      "risk-factors-list",
      renderRiskFactors(detailData.security_risks)
    );

    Utils.setText(
      "sidebar-price",
      priceSol !== null
        ? Utils.formatPriceSol(priceSol, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "sidebar-volume",
      volume24hValue !== null
        ? Utils.formatCurrencyUSD(volume24hValue, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "sidebar-liq",
      liquidityValue !== null
        ? Utils.formatCurrencyUSD(liquidityValue, { fallback: "‚Äî" })
        : "‚Äî"
    );
    Utils.setText(
      "sidebar-mcap",
      Utils.formatCurrencyUSD(detailData.market_cap, { fallback: "‚Äî" })
    );

    renderLinkList("sidebar-websites", detailData.websites || [], {
      emptyMessage: "No websites listed",
      getLabel: (link) => link.label,
    });
    renderLinkList("sidebar-socials", detailData.socials || [], {
      emptyMessage: "No social links",
      getLabel: (link) =>
        link.platform ? link.platform.toUpperCase() : extractDomain(link.url),
    });

    Utils.setHtml("sidebar-badges", renderSidebarBadges(statusFlags));

    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.add("active");
    } else {
      console.error("Modal element not found!");
    }
  }

  var tokensColumnManager = window.tokensColumnManager || null;
  window.tokensColumnManager = tokensColumnManager;

  var tokensColumnDialogState = window.tokensColumnDialogState || {
    root: null,
    list: null,
    checkboxMap: new Map(),
    tempVisibleIds: new Set(),
    initialized: false,
    previouslyFocused: null,
    applyButton: null,
    resetButton: null,
    closeButton: null,
  };
  if (!(tokensColumnDialogState.checkboxMap instanceof Map)) {
    tokensColumnDialogState.checkboxMap = new Map();
  }
  if (!(tokensColumnDialogState.tempVisibleIds instanceof Set)) {
    tokensColumnDialogState.tempVisibleIds = new Set();
  }
  window.tokensColumnDialogState = tokensColumnDialogState;

  var TOKENS_SCROLL_GUARD_HTML =
    '<tr id="tokens-scroll-guard" class="scroll-guard-row"><td class="scroll-guard-cell"></td></tr>';

  var tokensTableState = window.tokensTableState || {
    items: [],
    pageSize: 0,
    currentPage: 0,
    totalPages: 0,
    totalCount: 0,
    loading: false,
    pendingReload: false,
    scrollObserver: null,
    scrollContainer: null,
  };

  window.tokensTableState = tokensTableState;

  var allTokensData = tokensTableState.items;
  var currentModalMint = null;
  var tokenModalData = null;
  var searchDebounceHandle = null;
  var tokensFetchState = window.tokensFetchState || {
    inProgress: false,
    message: "",
    abortController: null,
  };
  window.tokensFetchState = tokensFetchState;
  var tokensAutoRefreshState = window.tokensAutoRefreshState || {
    poller: null,
  };
  window.tokensAutoRefreshState = tokensAutoRefreshState;
  var tokensPriceState = window.tokensPriceState || {
    lastPrices: new Map(),
    lastDirections: new Map(),
    lastChangeAt: new Map(),
  };
  if (!(tokensPriceState.lastPrices instanceof Map)) {
    tokensPriceState.lastPrices = new Map();
  }
  if (!(tokensPriceState.lastDirections instanceof Map)) {
    tokensPriceState.lastDirections = new Map();
  }
  if (!(tokensPriceState.lastChangeAt instanceof Map)) {
    tokensPriceState.lastChangeAt = new Map();
  }
  window.tokensPriceState = tokensPriceState;

  function getTokensColumnDefinitionById(columnId) {
    if (!columnId) return null;
    for (let i = 0; i < TOKENS_COLUMN_DEFINITIONS.length; i += 1) {
      const column = TOKENS_COLUMN_DEFINITIONS[i];
      if (column && column.id === columnId) {
        return column;
      }
    }
    return null;
  }

  function getActiveTokenColumns() {
    if (
      tokensColumnManager &&
      typeof tokensColumnManager.getVisibleColumns === "function"
    ) {
      const columns = tokensColumnManager.getVisibleColumns();
      if (Array.isArray(columns) && columns.length > 0) {
        return columns;
      }
    }

    return TOKENS_DEFAULT_VISIBLE_COLUMN_IDS.map(function (id) {
      return getTokensColumnDefinitionById(id);
    }).filter(Boolean);
  }

  function getCurrentVisibleTokenColumnIds() {
    if (
      tokensColumnManager &&
      typeof tokensColumnManager.getVisibleColumns === "function"
    ) {
      const columns = tokensColumnManager.getVisibleColumns();
      if (Array.isArray(columns) && columns.length > 0) {
        return columns.map(function (column) {
          return column.id;
        });
      }
    }
    return TOKENS_DEFAULT_VISIBLE_COLUMN_IDS.slice();
  }

  function getTokensTableColspan() {
    const columns = getActiveTokenColumns();
    if (!Array.isArray(columns) || columns.length === 0) {
      return TOKENS_DEFAULT_VISIBLE_COLUMN_IDS.length || 1;
    }
    return Math.max(1, columns.length);
  }

  function updateTokensPlaceholderColspans() {
    const colSpan = getTokensTableColspan();
    const placeholderCells = document.querySelectorAll(
      '#tokensTableBody td[data-tokens-colspan="true"]'
    );
    placeholderCells.forEach(function (cell) {
      cell.colSpan = colSpan;
    });

    const guardCell = document.querySelector(
      "#tokens-scroll-guard .scroll-guard-cell"
    );
    if (guardCell) {
      guardCell.dataset.tokensColspan = "true";
      guardCell.colSpan = colSpan;
    }
  }

  function setTokensColumnManager(instance) {
    tokensColumnManager = instance || null;
    window.tokensColumnManager = tokensColumnManager;
    updateTokensPlaceholderColspans();
    renderTokensColumnDialogList();
    updateSortIndicators();
  }

  function handleTokensColumnLayoutChange(event) {
    updateTokensPlaceholderColspans();

    if (event && event.type === "visibility") {
      const isLoading =
        tokensFetchState &&
        tokensFetchState.inProgress &&
        (!Array.isArray(tokensTableState.items) ||
          tokensTableState.items.length === 0);

      if (isLoading) {
        showTokensLoading(tokensFetchState.message || "Loading tokens...");
      } else {
        const currentItems = Array.isArray(tokensTableState.items)
          ? tokensTableState.items
          : Array.isArray(allTokensData)
          ? allTokensData
          : [];
        renderTokens(currentItems, { mode: "replace" });
      }
      renderTokensColumnDialogList();
    } else {
      renderTokensColumnDialogList();
    }

    updateSortIndicators();
  }

  function ensureTokensColumnDialogElements() {
    const state = tokensColumnDialogState;
    if (!state) return null;

    if (!(state.root instanceof HTMLElement)) {
      state.root = document.getElementById("tokensColumnDialog");
    }
    if (!state.root) {
      return null;
    }

    if (!(state.list instanceof HTMLElement)) {
      state.list = document.getElementById("tokensColumnList");
    }
    if (!state.list) {
      return null;
    }

    if (!(state.applyButton instanceof HTMLElement)) {
      state.applyButton = document.getElementById("tokensColumnApply");
    }
    if (state.applyButton && state.applyButton.dataset.bound !== "1") {
      state.applyButton.addEventListener("click", (event) => {
        event.preventDefault();
        applyTokensColumnDialogSelection();
      });
      state.applyButton.dataset.bound = "1";
    }

    if (!(state.resetButton instanceof HTMLElement)) {
      state.resetButton = document.getElementById("tokensColumnReset");
    }
    if (state.resetButton && state.resetButton.dataset.bound !== "1") {
      state.resetButton.addEventListener("click", (event) => {
        event.preventDefault();
        if (
          !tokensColumnManager ||
          typeof tokensColumnManager.resetVisibility !== "function"
        ) {
          renderTokensColumnDialogList();
          return;
        }
        const changed = tokensColumnManager.resetVisibility();
        if (!changed) {
          renderTokensColumnDialogList();
        }
      });
      state.resetButton.dataset.bound = "1";
    }

    if (!(state.closeButton instanceof HTMLElement)) {
      state.closeButton = document.getElementById("tokensColumnClose");
    }
    if (state.closeButton && state.closeButton.dataset.bound !== "1") {
      state.closeButton.addEventListener("click", (event) => {
        event.preventDefault();
        closeTokensColumnDialog();
      });
      state.closeButton.dataset.bound = "1";
    }

    if (!state.initialized) {
      state.root.addEventListener("click", (event) => {
        if (event.target === state.root) {
          closeTokensColumnDialog();
        }
      });
      state.root.addEventListener("keydown", (event) => {
        if (event.key === "Escape" || event.key === "Esc") {
          event.preventDefault();
          closeTokensColumnDialog();
        }
      });
      state.initialized = true;
    }

    return state.root;
  }

  function renderTokensColumnDialogList() {
    const state = tokensColumnDialogState;
    if (!state) return;

    const root = ensureTokensColumnDialogElements();
    if (!root || !state.list) return;

    if (
      !tokensColumnManager ||
      typeof tokensColumnManager.getAllColumns !== "function"
    ) {
      state.list.innerHTML = "";
      state.checkboxMap.clear();
      state.tempVisibleIds.clear();
      return;
    }

    const columns = tokensColumnManager.getAllColumns();
    const visibleIds = new Set(getCurrentVisibleTokenColumnIds());

    state.list.innerHTML = "";
    state.checkboxMap.clear();
    state.tempVisibleIds = new Set(visibleIds);

    columns.forEach((column) => {
      const item = document.createElement("label");
      item.className = "column-dialog__item";
      item.dataset.columnId = column.id;
      if (column.required) {
        item.classList.add("column-dialog__item--locked");
      }

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = column.id;
      checkbox.checked = visibleIds.has(column.id);
      checkbox.disabled = column.required === true;
      checkbox.dataset.columnId = column.id;

      if (!checkbox.disabled) {
        checkbox.addEventListener(
          "change",
          handleTokensColumnDialogCheckboxChange
        );
      }

      const labelSpan = document.createElement("span");
      labelSpan.className = "column-dialog__item-label";
      labelSpan.textContent = column.label;

      item.appendChild(checkbox);
      item.appendChild(labelSpan);

      if (column.required) {
        const hint = document.createElement("span");
        hint.className = "column-dialog__hint";
        hint.textContent = "Required";
        item.appendChild(hint);
      }

      state.list.appendChild(item);
      state.checkboxMap.set(column.id, checkbox);
    });
  }

  function handleTokensColumnDialogCheckboxChange(event) {
    const checkbox = event.target;
    if (!checkbox) return;
    const columnId = checkbox.value;
    if (!columnId) return;

    const state = tokensColumnDialogState;
    if (!(state.tempVisibleIds instanceof Set)) {
      state.tempVisibleIds = new Set(getCurrentVisibleTokenColumnIds());
    }

    if (checkbox.checked) {
      state.tempVisibleIds.add(columnId);
    } else {
      state.tempVisibleIds.delete(columnId);
    }

    if (state.tempVisibleIds.size === 0) {
      state.tempVisibleIds.add(columnId);
      checkbox.checked = true;
      if (window.Utils && typeof Utils.showToast === "function") {
        Utils.showToast("At least one column must remain visible.", "warning");
      }
    }
  }

  function applyTokensColumnDialogSelection() {
    if (
      !tokensColumnManager ||
      typeof tokensColumnManager.setVisibleColumns !== "function"
    ) {
      closeTokensColumnDialog();
      return;
    }

    const state = tokensColumnDialogState;
    const selection =
      state.tempVisibleIds instanceof Set && state.tempVisibleIds.size > 0
        ? Array.from(state.tempVisibleIds)
        : getCurrentVisibleTokenColumnIds();

    const changed = tokensColumnManager.setVisibleColumns(selection);
    if (!changed) {
      renderTokensColumnDialogList();
    }

    closeTokensColumnDialog();
  }

  function openTokensColumnDialog() {
    const manager = initializeTokensColumnManager();
    if (!manager || typeof manager.getVisibleColumns !== "function") {
      if (window.Utils && typeof Utils.showToast === "function") {
        Utils.showToast("‚ö†Ô∏è Column manager unavailable", "info");
      }
      return;
    }

    const root = ensureTokensColumnDialogElements();
    if (!root) {
      return;
    }

    renderTokensColumnDialogList();

    tokensColumnDialogState.previouslyFocused =
      document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;

    root.setAttribute("aria-hidden", "false");
    document.body.classList.add("column-dialog-open");

    const focusTarget =
      root.querySelector(".column-dialog__item input:not(:disabled)") ||
      tokensColumnDialogState.closeButton ||
      root;
    if (focusTarget && typeof focusTarget.focus === "function") {
      focusTarget.focus({ preventScroll: true });
    }
  }

  function closeTokensColumnDialog() {
    const state = tokensColumnDialogState;
    if (!state) return;
    const root = ensureTokensColumnDialogElements();
    if (!root) return;

    root.setAttribute("aria-hidden", "true");
    document.body.classList.remove("column-dialog-open");

    const focusTarget = state.previouslyFocused;
    state.previouslyFocused = null;
    if (focusTarget && typeof focusTarget.focus === "function") {
      try {
        focusTarget.focus({ preventScroll: true });
      } catch (_) {
        /* no-op */
      }
    }
  }

  function initializeTokensColumnManager() {
    if (
      tokensColumnManager &&
      typeof tokensColumnManager.getVisibleColumns === "function"
    ) {
      if (
        typeof tokensColumnManager.setSortState === "function" &&
        tokensState
      ) {
        tokensColumnManager.setSortState(
          tokensState.sortBy,
          tokensState.sortDir
        );
      }
      setTokensColumnManager(tokensColumnManager);
      return tokensColumnManager;
    }

    if (
      !window.TableColumnManager ||
      typeof window.TableColumnManager.create !== "function"
    ) {
      console.warn("[Tokens] TableColumnManager is unavailable");
      return null;
    }

    const table = document.getElementById("tokensTable");
    if (!table) {
      console.warn("[Tokens] tokensTable element not found");
      return null;
    }

    try {
      const manager = window.TableColumnManager.create({
        table,
        columns: TOKENS_COLUMN_DEFINITIONS,
        storageKey: "tokensTable",
        onLayoutChange: handleTokensColumnLayoutChange,
      });
      setTokensColumnManager(manager);
      if (typeof manager.setSortState === "function" && tokensState) {
        manager.setSortState(tokensState.sortBy, tokensState.sortDir);
      }
      return manager;
    } catch (err) {
      console.error("[Tokens] Failed to initialize column manager", err);
      return null;
    }
  }

  var TOKENS_PRICE_HIGHLIGHT_TTL_MS = 4500;
  var TOKENS_PAGE_LIMIT = TOKENS_DEFAULT_PAGE_SIZE;

  function replaceAllTokensData(next) {
    tokensTableState.items = Array.isArray(next) ? next : [];
    allTokensData = tokensTableState.items;
  }

  function appendTokensToState(items) {
    if (!Array.isArray(items) || items.length === 0) return;
    if (!Array.isArray(tokensTableState.items)) {
      tokensTableState.items = [];
    }
    Array.prototype.push.apply(tokensTableState.items, items);
    allTokensData = tokensTableState.items;
  }

  function clampTokensPageSize(size) {
    const numeric = Number(size);
    if (!Number.isFinite(numeric) || numeric <= 0) {
      return TOKENS_PAGE_LIMIT;
    }
    return Math.min(Math.max(1, Math.floor(numeric)), TOKENS_MAX_PAGE_SIZE);
  }

  function resetTokensPagination(options) {
    const { preserveItems = false } = options || {};
    if (!preserveItems) {
      replaceAllTokensData([]);
    }
    tokensTableState.pageSize = TOKENS_PAGE_LIMIT;
    tokensTableState.currentPage = 0;
    tokensTableState.totalPages = 0;
    tokensTableState.totalCount = preserveItems
      ? tokensTableState.totalCount
      : 0;
    tokensTableState.loading = false;
    tokensTableState.pendingReload = false;
    teardownTokensScrollObserver();
  }

  // Global init function for Router to call during SPA navigation
  window.initTokensPage = function () {
    console.log("[Tokens] Initializing page");
    hydrateTokensState();
    initializeTokensColumnManager();
    ensureTokensPageReady({ updateStatus: false });
    setupSortableHeaders();
    attachGlobalListeners();
    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => cleanupTokensPage());
    }
    reloadTokensList("Loading tokens...");
  };

  // Debug helper to inspect pagination state
  window.debugTokensPagination = function () {
    const tbody = document.getElementById("tokensTableBody");
    const guard = document.getElementById("tokens-scroll-guard");
    const rowCount = tbody ? tbody.querySelectorAll("tr[data-mint]").length : 0;

    console.log("=== Tokens Pagination Debug ===");
    console.log("State:", {
      currentPage: tokensTableState.currentPage,
      totalPages: tokensTableState.totalPages,
      totalCount: tokensTableState.totalCount,
      pageSize: tokensTableState.pageSize,
      itemsInMemory: tokensTableState.items ? tokensTableState.items.length : 0,
      allTokensDataLength: allTokensData ? allTokensData.length : 0,
      rowsInDOM: rowCount,
      loading: tokensTableState.loading,
      hasObserver: !!tokensTableState.scrollObserver,
      guardExists: !!guard,
      guardIsLastChild:
        guard && tbody ? tbody.lastElementChild === guard : false,
      guardState: guard ? guard.dataset.state : "N/A",
    });
    console.log("View:", tokensState.view);
    console.log("Search:", tokensState.searchTerm || "(none)");
    console.log("Sort:", tokensState.sortBy, tokensState.sortDir);
    console.log("===============================");

    // Enable verbose logging
    window.__DEBUG_TOKENS_VERBOSE = true;
    console.log(
      "Verbose logging ENABLED. Disable with: window.__DEBUG_TOKENS_VERBOSE = false"
    );
  };

  function hydrateTokensState() {
    const savedView = window.sessionStorage.getItem("tokens.view");
    if (savedView && TOKENS_VIEWS.includes(savedView)) {
      tokensState.view = savedView;
    } else if (savedView) {
      console.warn("[Tokens] Ignoring unsupported stored view", savedView);
      window.sessionStorage.removeItem("tokens.view");
    }

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }

    const savedSearch = window.sessionStorage.getItem("tokens.search");
    if (typeof savedSearch === "string") {
      tokensState.searchTerm = savedSearch;
    }

    const savedSortBy = window.sessionStorage.getItem("tokens.sortBy");
    if (savedSortBy) {
      if (TOKENS_SORT_KEYS.includes(savedSortBy)) {
        tokensState.sortBy = savedSortBy;
      } else {
        console.warn(
          "[Tokens] Ignoring unsupported stored sortBy",
          savedSortBy
        );
        window.sessionStorage.removeItem("tokens.sortBy");
      }
    }

    const savedSortDir = window.sessionStorage.getItem("tokens.sortDir");
    if (savedSortDir) {
      if (savedSortDir === "asc" || savedSortDir === "desc") {
        tokensState.sortDir = savedSortDir;
      } else {
        console.warn(
          "[Tokens] Ignoring unsupported stored sortDir",
          savedSortDir
        );
        window.sessionStorage.removeItem("tokens.sortDir");
      }
    }

    if (!TOKENS_SORT_KEYS.includes(tokensState.sortBy)) {
      tokensState.sortBy = DEFAULT_SORT_KEY;
    }

    if (tokensState.sortDir !== "asc" && tokensState.sortDir !== "desc") {
      tokensState.sortDir = tokensState.sortBy === "symbol" ? "asc" : "desc";
    }

    persistTokensSortState();
  }

  function getTokenByMint(mint) {
    if (!mint) return null;
    return allTokensData.find((token) => token?.mint === mint) || null;
  }

  async function fetchTokenDetail(mint) {
    const fetchStart = performance.now();
    console.log(`[TokenDetail] fetchTokenDetail START mint=${mint}`);
    try {
      const res = await fetch(`/api/tokens/${mint}`);
      const fetchEnd = performance.now();
      console.log(
        `[TokenDetail] fetch completed elapsed=${(
          fetchEnd - fetchStart
        ).toFixed(2)}ms`
      );
      if (!res.ok) throw new Error(`Token request failed (${res.status})`);
      const parseStart = performance.now();
      const data = await res.json();
      const parseEnd = performance.now();
      console.log(
        `[TokenDetail] JSON parse elapsed=${(parseEnd - parseStart).toFixed(
          2
        )}ms`
      );
      console.log(
        `[TokenDetail] fetchTokenDetail COMPLETE total_elapsed=${(
          parseEnd - fetchStart
        ).toFixed(2)}ms`
      );
      return data;
    } catch (error) {
      console.error("Failed to fetch token detail:", error);
      Utils.showToast("‚ùå Failed to load token details", "error");
      return null;
    }
  }

  function renderModalHeaderBadges(options) {
    if (!options) return "";
    const badges = [];

    if (options.blacklisted) {
      badges.push(
        '<span class="modal-token-badge modal-token-badge--blacklisted">üö´ Blacklisted</span>'
      );
    }

    if (options.rugged && !options.blacklisted) {
      badges.push(
        '<span class="modal-token-badge modal-token-badge--rugged">‚ö†Ô∏è Rug Risk</span>'
      );
    }

    if (options.verified) {
      badges.push(
        '<span class="modal-token-badge modal-token-badge--verified">‚úÖ Verified</span>'
      );
    }

    if (Number.isFinite(options.securityScore)) {
      const scoreText = Utils.escapeHtml(
        String(Math.round(options.securityScore))
      );
      badges.push(
        `<span class="modal-token-badge modal-token-badge--score">üõ°Ô∏è Score ${scoreText}</span>`
      );
    }

    if (options.hasPoolPrice) {
      badges.push(
        '<span class="modal-token-badge modal-token-badge--pool">üíß Pool Price</span>'
      );
    }

    if (options.hasOpenPosition) {
      badges.push(
        '<span class="modal-token-badge modal-token-badge--position">üìä Position</span>'
      );
    }

    return badges.join("");
  }

  function renderSidebarBadges(token) {
    const badges = [];
    if (token?.has_pool_price)
      badges.push(
        '<span class="badge" style="background:#dbeafe;color:#1e40af;border:1px solid #bfdbfe;">POOL</span>'
      );
    if (token?.has_ohlcv)
      badges.push(
        '<span class="badge" style="background:#dcfce7;color:#166534;border:1px solid #bbf7d0;">OHLCV</span>'
      );
    if (token?.has_open_position)
      badges.push(
        '<span class="badge" style="background:#fde68a;color:#92400e;border:1px solid #fcd34d;">POS</span>'
      );
    const boostCount = Number(token?.boosts_active ?? 0);
    if (Number.isFinite(boostCount) && boostCount > 0)
      badges.push(
        `<span class="badge" style="background:#ede9fe;color:#5b21b6;border:1px solid #ddd6fe;">BOOST √ó${Math.round(
          boostCount
        )}</span>`
      );
    if (token?.blacklisted)
      badges.push(
        '<span class="badge" style="background:#fee2e2;color:#991b1b;border:1px solid #fecaca;">BL</span>'
      );
    return badges.join(" ");
  }

  function renderRiskFactors(risks) {
    if (!Array.isArray(risks) || risks.length === 0) {
      return '<div style="color:#94a3b8;">No risk factors reported.</div>';
    }

    return risks
      .map((risk) => {
        const level = (risk.level || "").toUpperCase();
        const prefix = level ? `[${level}] ` : "";
        const title = risk.name || risk.title || "Risk factor";
        const description = risk.description || "‚Äî";
        return `
                        <div class="risk-item">
                            <div class="risk-item-title">${prefix}${title}</div>
                            <div class="risk-item-desc">${description}</div>
                        </div>
                    `;
      })
      .join("");
  }

  const PERIOD_LABELS = {
    m5: "5 minutes",
    h1: "1 hour",
    h6: "6 hours",
    h24: "24 hours",
  };
  const PERIOD_KEYS = ["m5", "h1", "h6", "h24"];

  function extractDomain(url) {
    if (typeof url !== "string" || url.trim() === "") {
      return "";
    }
    try {
      const { hostname } = new URL(url);
      return hostname.replace(/^www\./i, "");
    } catch (error) {
      return url;
    }
  }

  function formatAddress(address, visible = 4) {
    if (typeof address !== "string" || address.length === 0) {
      return "‚Äî";
    }
    if (address.length <= visible * 2) {
      return address;
    }
    return `${address.slice(0, visible)}‚Ä¶${address.slice(-visible)}`;
  }

  function applyDeltaClass(element, value) {
    if (!element) return;
    element.classList.remove("positive", "negative");
    if (!Number.isFinite(value)) {
      return;
    }
    if (value > 0) {
      element.classList.add("positive");
    } else if (value < 0) {
      element.classList.add("negative");
    }
  }

  function buildPriceTable(periods) {
    const rows = PERIOD_KEYS.map((key) => {
      const value = Number(periods[key]);
      const hasValue = Number.isFinite(value);
      const className = value > 0 ? "positive" : value < 0 ? "negative" : "";
      const formatted = hasValue
        ? Utils.formatPercentValue(value, { fallback: "‚Äî" })
        : "‚Äî";
      return `<tr><td>${Utils.escapeHtml(
        PERIOD_LABELS[key]
      )}</td><td class="${className}">${formatted}</td></tr>`;
    }).join("");

    return `
      <table>
        <thead>
          <tr>
            <th>Period</th>
            <th>Change</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function buildActivityTable(volumePeriods, txnPeriods) {
    const rows = PERIOD_KEYS.map((key) => {
      const volume = Number(volumePeriods[key]);
      const volumeCell = Number.isFinite(volume)
        ? Utils.formatCurrencyUSD(volume, { fallback: "‚Äî" })
        : "‚Äî";

      const buys = txnPeriods[key]?.buys;
      const sells = txnPeriods[key]?.sells;
      const hasBuys = Number.isFinite(buys);
      const hasSells = Number.isFinite(sells);
      const net = hasBuys && hasSells ? buys - sells : null;
      const ratio = hasBuys && hasSells && sells !== 0 ? buys / sells : null;
      const netClass = Number.isFinite(net)
        ? net > 0
          ? "positive"
          : net < 0
          ? "negative"
          : ""
        : "";
      const netCell = Number.isFinite(net)
        ? `${net > 0 ? "+" : net < 0 ? "-" : ""}${Math.abs(Math.round(net))}`
        : "‚Äî";
      const buysCell = hasBuys ? Math.round(buys) : "‚Äî";
      const sellsCell = hasSells ? Math.round(sells) : "‚Äî";
      const ratioCell = Number.isFinite(ratio) ? ratio.toFixed(2) : "‚Äî";

      return `<tr>
        <td>${Utils.escapeHtml(PERIOD_LABELS[key])}</td>
        <td>${volumeCell}</td>
        <td>${buysCell}</td>
        <td>${sellsCell}</td>
        <td class="${netClass}">${netCell}</td>
        <td>${ratioCell}</td>
      </tr>`;
    }).join("");

    return `
      <table>
        <thead>
          <tr>
            <th>Period</th>
            <th>Volume</th>
            <th>Buys</th>
            <th>Sells</th>
            <th>Net</th>
            <th>Ratio</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function renderBadgeList(containerId, values, emptyMessage) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = "";

    const entries = Array.isArray(values)
      ? Array.from(new Set(values.filter(Boolean)))
      : [];

    if (entries.length === 0) {
      if (emptyMessage) {
        const empty = document.createElement("div");
        empty.className = "empty-state";
        empty.textContent = emptyMessage;
        container.appendChild(empty);
      }
      return;
    }

    const fragment = document.createDocumentFragment();
    entries.forEach((value) => {
      const badge = document.createElement("span");
      badge.className = "badge-item";
      badge.textContent = value;
      fragment.appendChild(badge);
    });
    container.appendChild(fragment);
  }

  function renderLinkList(
    containerId,
    links,
    { emptyMessage = "", getLabel } = {}
  ) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = "";

    if (!Array.isArray(links) || links.length === 0) {
      if (emptyMessage) {
        const empty = document.createElement("div");
        empty.className = "empty-state";
        empty.textContent = emptyMessage;
        container.appendChild(empty);
      }
      return;
    }

    const fragment = document.createDocumentFragment();
    links.forEach((link) => {
      if (!link || !link.url) {
        return;
      }
      const anchor = document.createElement("a");
      let resolvedUrl;
      try {
        const parsed = new URL(link.url, window.location.origin);
        if (!/^https?:$/i.test(parsed.protocol)) {
          return;
        }
        resolvedUrl = parsed.href;
      } catch (error) {
        return;
      }
      anchor.href = resolvedUrl;
      anchor.target = "_blank";
      anchor.rel = "noopener";
      const rawLabel = getLabel ? getLabel(link) : link.label;
      anchor.textContent =
        rawLabel && String(rawLabel).trim().length
          ? rawLabel
          : extractDomain(link.url);
      fragment.appendChild(anchor);
    });
    container.appendChild(fragment);
  }

  function resetTokenModal() {
    const modal = document.getElementById("tokenModal");
    if (modal) {
      modal.classList.remove("active");
    }

    // CRITICAL FIX: Destroy chart instance on modal close to prevent stale data
    if (tokenChartManager) {
      console.log("[TokenDetail] Destroying chart on modal close");
      tokenChartManager.destroy();
      tokenChartManager = null;
    }

    const websiteBtn = document.getElementById("action-website");
    if (websiteBtn) {
      websiteBtn.disabled = true;
      websiteBtn.classList.add("quick-action-btn--disabled");
    }

    const taglineEl = document.getElementById("modalTokenTagline");
    if (taglineEl) {
      taglineEl.textContent = "";
      taglineEl.classList.remove("is-visible");
    }

    const headerBadgesEl = document.getElementById("modalTokenBadges");
    if (headerBadgesEl) {
      headerBadgesEl.innerHTML = "";
    }

    currentModalMint = null;
    tokenModalData = null;
  }

  async function openTokenModal(mint) {
    const modalStart = performance.now();
    console.log(`[TokenDetail] openTokenModal START mint=${mint}`);

    if (!mint) {
      console.warn("openTokenModal: no mint provided");
      return;
    }

    const cacheStart = performance.now();
    const cached = getTokenByMint(mint);
    const cacheEnd = performance.now();
    console.log(
      `[TokenDetail] cache lookup elapsed=${(cacheEnd - cacheStart).toFixed(
        2
      )}ms found=${!!cached}`
    );

    if (!cached) {
      console.warn("openTokenModal: token not found in cache");
      Utils.showToast("‚ùå Token not found in cache", "error");
      return;
    }

    const detail = await fetchTokenDetail(mint);
    if (!detail) {
      console.warn("openTokenModal: failed to fetch token detail");
      return; // fetchTokenDetail already shows error toast
    }

    const populateStart = performance.now();
    currentModalMint = mint;
    tokenModalData = { token: cached, detail };
    populateTokenModal(cached, detail);
    const populateEnd = performance.now();

    console.log(
      `[TokenDetail] populateTokenModal elapsed=${(
        populateEnd - populateStart
      ).toFixed(2)}ms`
    );
    console.log(
      `[TokenDetail] openTokenModal COMPLETE total_elapsed=${(
        populateEnd - modalStart
      ).toFixed(2)}ms`
    );

    // CRITICAL FIX: Check if chart tab is already active from previous modal session
    // If so, initialize chart immediately with new token
    const chartTab = document.querySelector('.modal-tab[onclick*="chart"]');
    const chartTabPane = document.getElementById("tab-chart");
    if (
      chartTab?.classList.contains("active") ||
      chartTabPane?.classList.contains("active")
    ) {
      console.log(
        "[TokenDetail] Chart tab already active, initializing chart for:",
        mint
      );
      initTokenChart(mint);
    }
  }

  function closeTokenModal(event) {
    if (event && event.target && event.target !== event.currentTarget) {
      return;
    }
    resetTokenModal();
  }

  function switchModalTab(tabId) {
    const content = document.querySelectorAll(".tab-pane");
    const tabs = document.querySelectorAll(".modal-tab");
    content.forEach((pane) => {
      pane.classList.toggle("active", pane.id === `tab-${tabId}`);
    });
    tabs.forEach((tab) => {
      tab.classList.toggle(
        "active",
        tab.textContent.includes(tabId.charAt(0).toUpperCase())
      );
    });

    // CRITICAL FIX: Always re-initialize chart when switching to chart tab
    // This ensures correct token data is loaded, even if chart was previously initialized
    if (tabId === "chart" && currentModalMint) {
      console.log(
        "[TokenDetail] Switching to chart tab, initializing chart for:",
        currentModalMint
      );
      initTokenChart(currentModalMint);
    }
  }

  function copyMintFromModal() {
    if (!currentModalMint) return;
    Utils.copyMint(currentModalMint);
  }

  function openWebsiteFromModal() {
    if (!tokenModalData || !tokenModalData.detail) {
      Utils.showToast("‚ÑπÔ∏è No website available", "info");
      return;
    }
    const rawUrl = tokenModalData.detail.website;
    if (!rawUrl || typeof rawUrl !== "string" || !rawUrl.trim().length) {
      Utils.showToast("‚ÑπÔ∏è No website available", "info");
      return;
    }
    try {
      let resolved = rawUrl.trim();
      if (!/^https?:\/\//i.test(resolved)) {
        resolved = `https://${resolved}`;
      }
      window.open(resolved, "_blank", "noopener");
    } catch (error) {
      console.error("Failed to open website", error);
      Utils.showToast("‚ùå Failed to open website", "error");
    }
  }

  function openDexScreenerFromModal() {
    if (!currentModalMint) return;
    Utils.openDexScreener(currentModalMint);
  }

  function openGMGNFromModal() {
    if (!currentModalMint) return;
    Utils.openGMGN(currentModalMint);
  }

  function openSolscanFromModal() {
    if (!currentModalMint) return;
    Utils.openSolscan(currentModalMint);
  }

  function attachGlobalListeners() {
    if (!window.__tokensVisibilityHandler) {
      window.__tokensVisibilityHandler = handleVisibilityChange;
      document.addEventListener(
        "visibilitychange",
        window.__tokensVisibilityHandler
      );
    }
  }

  function handleVisibilityChange() {
    if (document.visibilityState !== "visible") {
      return;
    }
    if (window.Router && Router.currentPage !== "tokens") {
      return;
    }
    reloadTokensList("Refreshing after returning...", {
      preserveItems: true,
    });
  }

  function isTokensPageActive() {
    if (typeof document !== "undefined") {
      const state = document.visibilityState;
      if (state && state !== "visible") {
        return false;
      }
    }
    if (
      window.Router &&
      Router.currentPage &&
      Router.currentPage !== "tokens"
    ) {
      return false;
    }
    return true;
  }

  function tokensAutoRefreshPoll() {
    if (!isTokensPageActive()) {
      return;
    }
    if (tokensFetchState.inProgress) {
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] Skipping auto refresh; request in flight");
      }
      return;
    }
    reloadTokensList(null, { preserveItems: true, silent: true });
  }

  function ensureTokensAutoRefresh() {
    const state = window.tokensAutoRefreshState;
    if (!state) {
      return;
    }

    if (state.poller) {
      if (typeof state.poller.start === "function") {
        state.poller.start({ silent: true });
      }
      return;
    }

    if (window.PagePoller && typeof window.PagePoller.create === "function") {
      state.poller = window.PagePoller.create({
        label: "Tokens",
        onPoll: tokensAutoRefreshPoll,
      });
      state.poller.start({ silent: true });
      return;
    }

    console.warn(
      "[Tokens] PagePoller unavailable; using fallback polling logic"
    );
    state.poller = createTokensFallbackPoller(tokensAutoRefreshPoll);
    if (state.poller && typeof state.poller.start === "function") {
      state.poller.start({ silent: true });
    }
  }

  function createTokensFallbackPoller(onPoll) {
    const logPrefix = "[Tokens] (fallback)";
    let intervalId = null;
    let listener = null;

    const computeInterval = () => {
      if (
        window.PollingManager &&
        typeof window.PollingManager.getInterval === "function"
      ) {
        const value = Number(window.PollingManager.getInterval());
        if (Number.isFinite(value) && value > 0) {
          return value;
        }
      }
      return 1000;
    };

    const ensureListener = () => {
      if (
        !window.PollingManager ||
        typeof window.PollingManager.onChange !== "function" ||
        listener
      ) {
        return;
      }

      listener = window.PollingManager.onChange(() => {
        if (!intervalId) {
          return;
        }
        start({ silent: true });
        console.log(`${logPrefix} Polling interval changed`);
      });
    };

    const start = ({ silent } = {}) => {
      stop({ silent: true });
      const interval = computeInterval();
      intervalId = setInterval(() => {
        try {
          onPoll();
        } catch (error) {
          console.error(`${logPrefix} Poll failed`, error);
        }
      }, interval);

      if (window.Router && typeof Router.trackInterval === "function") {
        Router.trackInterval(intervalId);
      }

      ensureListener();

      if (!silent) {
        console.log(`${logPrefix} Started polling every ${interval} ms`);
      }

      return interval;
    };

    const stop = ({ silent } = {}) => {
      if (!intervalId) {
        return;
      }
      clearInterval(intervalId);
      intervalId = null;
      if (!silent) {
        console.log(`${logPrefix} Stopped polling`);
      }
    };

    const cleanup = () => {
      stop({ silent: true });
      if (
        listener &&
        window.PollingManager &&
        typeof window.PollingManager.removeListener === "function"
      ) {
        window.PollingManager.removeListener(listener);
      }
      listener = null;
    };

    return {
      start,
      stop,
      restart: () => start({ silent: true }),
      cleanup,
    };
  }

  function stopTokensAutoRefresh() {
    const state = window.tokensAutoRefreshState;
    if (!state || !state.poller) {
      return;
    }

    if (typeof state.poller.cleanup === "function") {
      state.poller.cleanup();
    } else if (typeof state.poller.stop === "function") {
      state.poller.stop();
    }

    state.poller = null;
  }

  function initTokensSubTabs() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    subTabsContainer.innerHTML = TOKENS_VIEW_DEFS.map(function (view) {
      var isActive = view.id === tokensState.view;
      return (
        '<button class="sub-tab ' +
        (isActive ? "active" : "") +
        '" data-view="' +
        view.id +
        '">' +
        view.label +
        "</button>"
      );
    }).join("");

    subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
      button.addEventListener("click", () =>
        switchTokensSubTab(button.dataset.view)
      );
    });

    subTabsContainer.style.display = "flex";
  }

  function ensureTokensSubTabsVisible() {
    const subTabsContainer = document.getElementById("subTabsContainer");
    if (!subTabsContainer) return;

    if (!TOKENS_VIEWS.includes(tokensState.view)) {
      tokensState.view = DEFAULT_TOKENS_VIEW;
      window.sessionStorage.setItem("tokens.view", tokensState.view);
    }

    const needsInit = subTabsContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(subTabsContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      subTabsContainer.style.display === "none";

    if (needsInit) {
      initTokensSubTabs();
    } else {
      subTabsContainer.querySelectorAll(".sub-tab").forEach((button) => {
        button.classList.toggle(
          "active",
          button.dataset.view === tokensState.view
        );
      });
    }

    if (hidden) {
      subTabsContainer.style.display = "flex";
    }
  }

  function switchTokensSubTab(view) {
    var nextView = view;
    if (!nextView || !TOKENS_VIEWS.includes(nextView)) {
      console.warn("[Tokens] Unsupported sub-tab selection", nextView);
      nextView = DEFAULT_TOKENS_VIEW;
    }

    if (tokensState.view === nextView) {
      ensureTokensSubTabsVisible();
      return;
    }

    tokensState.view = nextView;
    window.sessionStorage.setItem("tokens.view", tokensState.view);

    document.querySelectorAll("#subTabsContainer .sub-tab").forEach((tab) => {
      tab.classList.toggle("active", tab.dataset.view === tokensState.view);
    });

    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const loadMessage = viewLabel
      ? `Loading tokens ${viewLabel}...`
      : "Loading tokens...";

    reloadTokensList(loadMessage);
  }

  function ensureTokensToolbarVisible(options = {}) {
    const { updateStatus = true } = options;
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    const needsInit = toolbarContainer.children.length === 0;
    const computed =
      typeof window.getComputedStyle === "function"
        ? window.getComputedStyle(toolbarContainer)
        : null;
    const hidden =
      (computed && computed.display === "none") ||
      toolbarContainer.style.display === "none";

    if (needsInit) {
      initTokensToolbar();
    } else {
      const searchInput = toolbarContainer.querySelector("#searchInput");
      if (searchInput) {
        searchInput.value = tokensState.searchTerm;
      }
    }

    if (hidden) {
      toolbarContainer.style.display = "flex";
    }

    if (!updateStatus) {
      return;
    }

    let statusMessage = null;
    if (tokensFetchState.inProgress && tokensFetchState.message) {
      statusMessage = tokensFetchState.message;
    } else {
      const totalAvailable = Number(tokensTableState.totalCount) || 0;
      const loaded = Array.isArray(tokensTableState.items)
        ? tokensTableState.items.length
        : allTokensData.length;
      if (totalAvailable > 0 || loaded > 0) {
        const viewLabel = VIEW_LABELS[tokensState.view] || "";
        if (totalAvailable > 0 && loaded > 0 && loaded < totalAvailable) {
          statusMessage = viewLabel
            ? `${loaded}/${totalAvailable} tokens ${viewLabel}`
            : `${loaded}/${totalAvailable} tokens`;
        } else {
          const value = totalAvailable || loaded;
          statusMessage = viewLabel
            ? `${value} tokens ${viewLabel}`
            : `${value} tokens`;
        }
      }
    }

    if (statusMessage) {
      setTokenCountStatus(statusMessage);
    }
  }

  function ensureTokensPageReady(options = {}) {
    initializeTokensColumnManager();
    ensureTokensSubTabsVisible();
    ensureTokensToolbarVisible(options);
    attachGlobalListeners();
    ensureTokensAutoRefresh();
  }

  window.ensureTokensPageReady = ensureTokensPageReady;

  function initTokensToolbar() {
    const toolbarContainer = document.getElementById("toolbarContainer");
    if (!toolbarContainer) return;

    toolbarContainer.innerHTML = `
                <input
                    type="text"
                    id="searchInput"
                    placeholder="Search by symbol or mint..."
                    style="flex: 1; max-width: 300px; padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9em; background: var(--bg-primary); color: var(--text-primary);"
                >
                <div class="spacer"></div>
                <span id="tokenCount" style="color: var(--text-secondary); font-size: 0.9em; font-weight: 500;">Loading...</span>
        <button id="tokensColumnsBtn" class="btn btn-secondary" style="padding: 6px 12px;">
          üìê Columns
        </button>
                <button id="tokensRefreshBtn" class="btn btn-primary" style="padding: 6px 12px;">
                    üîÑ Refresh
                </button>
                <button id="tokensExportBtn" class="btn btn-secondary" style="padding: 6px 12px;">
                    üì• Export
                </button>
            `;
    toolbarContainer.style.display = "flex";

    const searchInput = toolbarContainer.querySelector("#searchInput");
    if (searchInput) {
      searchInput.value = tokensState.searchTerm;
      searchInput.addEventListener("input", handleSearchInput);
    }

    const columnsBtn = toolbarContainer.querySelector("#tokensColumnsBtn");
    if (columnsBtn) {
      columnsBtn.addEventListener("click", (event) => {
        event.preventDefault();
        openTokensColumnDialog();
      });
    }

    const refreshBtn = toolbarContainer.querySelector("#tokensRefreshBtn");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () => {
        const originalLabel = refreshBtn.textContent;
        refreshBtn.disabled = true;
        refreshBtn.textContent = "Refreshing‚Ä¶";
        reloadTokensList(null, { preserveItems: true, silent: true })
          .catch(() => {
            /* handled via toast */
          })
          .finally(() => {
            refreshBtn.disabled = false;
            refreshBtn.textContent = originalLabel;
          });
      });
    }

    const exportBtn = toolbarContainer.querySelector("#tokensExportBtn");
    if (exportBtn) {
      exportBtn.addEventListener("click", exportTokens);
    }
  }

  function handleSearchInput(event) {
    tokensState.searchTerm = event.target.value.trim();
    window.sessionStorage.setItem("tokens.search", tokensState.searchTerm);

    const message = tokensState.searchTerm
      ? "Applying search filter..."
      : "Refreshing tokens...";

    setTokenCountStatus(message);

    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }

    searchDebounceHandle = setTimeout(() => {
      reloadTokensList(message, { preserveItems: true });
    }, 350);
  }

  function persistTokensSortState() {
    try {
      window.sessionStorage.setItem("tokens.sortBy", tokensState.sortBy);
      window.sessionStorage.setItem("tokens.sortDir", tokensState.sortDir);
    } catch (err) {
      console.warn("[Tokens] Failed to persist sort state", err);
    }
  }

  async function exportTokens() {
    const exportButton = document.getElementById("tokensExportBtn");
    if (exportButton) {
      exportButton.disabled = true;
      exportButton.textContent = "Exporting‚Ä¶";
    }

    const statusBefore = document.getElementById("tokenCount")?.textContent;
    setTokenCountStatus("üì¶ Preparing export‚Ä¶");

    try {
      const maxPages = 50; // safeguard to prevent unbounded loops
      let page = 1;
      const pageSize = clampTokensPageSize(
        tokensTableState.pageSize || TOKENS_PAGE_LIMIT
      );
      const rows = [];
      let totalPages = 1;
      let totalCount = 0;

      while (page <= totalPages && page <= maxPages) {
        const result = await fetchTokensListPage(page, {
          pageSize,
        });
        rows.push(...result.items);
        totalPages = result.totalPages || totalPages;
        totalCount = result.total || totalCount;
        page += 1;
        setTokenCountStatus(
          `üì¶ Exporting tokens‚Ä¶ (${Math.min(rows.length, totalCount)}/${
            totalCount || "?"
          })`
        );
        if (result.items.length === 0) {
          break;
        }
      }

      if (rows.length === 0) {
        Utils.showToast("No tokens available to export", "info");
        return;
      }

      const header = [
        "mint",
        "symbol",
        "name",
        "price_sol",
        "liquidity_usd",
        "volume_24h",
        "fdv",
        "market_cap",
        "price_change_h1",
        "price_change_h24",
        "security_score",
        "total_holders",
        "has_pool_price",
        "has_ohlcv",
        "has_open_position",
        "blacklisted",
        "price_updated_at",
      ];

      const csvLines = [header.join(",")];
      rows.forEach((token) => {
        const line = header
          .map((field) => {
            const raw = token[field];
            if (raw === null || raw === undefined) {
              return "";
            }
            const str = String(raw);
            const needsEscape = /[",\n]/.test(str);
            const escaped = str.replace(/"/g, '""');
            return needsEscape ? `"${escaped}"` : escaped;
          })
          .join(",");
        csvLines.push(line);
      });

      const blob = new Blob([csvLines.join("\n")], {
        type: "text/csv;charset=utf-8;",
      });
      const url = URL.createObjectURL(blob);
      const filename = `tokens_${tokensState.view}_${
        tokensState.searchTerm ? "search" : "all"
      }_${new Date().toISOString().replace(/[:.]/g, "-")}.csv`;
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      Utils.showToast(`Exported ${rows.length} tokens`, "success");
    } catch (err) {
      console.error("[Tokens] Export failed", err);
      Utils.showToast("‚ùå Failed to export tokens", "error");
    } finally {
      if (statusBefore) {
        setTokenCountStatus(statusBefore);
      } else {
        updateTokenCount(tokensTableState.totalCount || allTokensData.length);
      }
      if (exportButton) {
        exportButton.disabled = false;
        exportButton.textContent = "üì• Export";
      }
    }
  }

  function normalizeTokenFromApi(rawToken) {
    if (!rawToken || typeof rawToken !== "object") return rawToken;
    const token = { ...rawToken };

    if (token.price_updated_at) {
      const numericTimestamp = Number(token.price_updated_at);
      if (Number.isFinite(numericTimestamp)) {
        token.price_updated_at = numericTimestamp;
      } else {
        const parsed = Date.parse(token.price_updated_at);
        token.price_updated_at = Number.isFinite(parsed)
          ? Math.floor(parsed / 1000)
          : null;
      }
    } else {
      token.price_updated_at = null;
    }

    return token;
  }

  function dedupeTokensByMint(tokens) {
    if (!Array.isArray(tokens) || tokens.length === 0) {
      return [];
    }

    const seen = new Set();
    const deduped = [];

    for (const token of tokens) {
      if (!token || typeof token !== "object") continue;
      const mint = token.mint;
      if (!mint || seen.has(mint)) continue;
      seen.add(mint);
      deduped.push(token);
    }

    return deduped;
  }

  function pruneStalePriceHighlights(now) {
    if (!tokensPriceState || !tokensPriceState.lastChangeAt) {
      return;
    }
    const ttl = Number(TOKENS_PRICE_HIGHLIGHT_TTL_MS) || 0;
    if (ttl <= 0) {
      if (typeof tokensPriceState.lastChangeAt.clear === "function") {
        tokensPriceState.lastChangeAt.clear();
      } else {
        tokensPriceState.lastChangeAt = new Map();
      }
      if (typeof tokensPriceState.lastDirections.clear === "function") {
        tokensPriceState.lastDirections.clear();
      } else {
        tokensPriceState.lastDirections = new Map();
      }
      return;
    }

    for (const [mint, timestamp] of tokensPriceState.lastChangeAt) {
      if (!Number.isFinite(timestamp) || now - timestamp > ttl) {
        tokensPriceState.lastChangeAt.delete(mint);
        tokensPriceState.lastDirections.delete(mint);
      }
    }
  }

  function annotateTokensWithPriceChange(tokens) {
    if (!Array.isArray(tokens) || tokens.length === 0) {
      return tokens;
    }

    const now = Date.now();
    pruneStalePriceHighlights(now);
    const ttl = Number(TOKENS_PRICE_HIGHLIGHT_TTL_MS) || 0;

    for (const token of tokens) {
      if (!token || typeof token !== "object") {
        continue;
      }

      const mint = token.mint;
      const currentPrice = Number(token.price_sol);
      const prevPrice = mint ? tokensPriceState.lastPrices.get(mint) : null;
      let changed = false;
      let direction = null;

      if (mint && Number.isFinite(currentPrice)) {
        if (Number.isFinite(prevPrice)) {
          if (currentPrice > prevPrice) {
            direction = "up";
            changed = true;
          } else if (currentPrice < prevPrice) {
            direction = "down";
            changed = true;
          }
        }

        tokensPriceState.lastPrices.set(mint, currentPrice);
      } else if (mint) {
        tokensPriceState.lastPrices.delete(mint);
      }

      if (changed && mint) {
        tokensPriceState.lastDirections.set(mint, direction);
        tokensPriceState.lastChangeAt.set(mint, now);
      }

      const lastDirection = mint
        ? tokensPriceState.lastDirections.get(mint)
        : null;
      const changeAt = mint ? tokensPriceState.lastChangeAt.get(mint) : null;
      const highlightActive =
        Boolean(lastDirection) && Number.isFinite(changeAt)
          ? now - changeAt <= ttl
          : false;
      const indicatorDirection = changed
        ? direction
        : highlightActive
        ? lastDirection
        : null;

      token.__previousPrice = Number.isFinite(prevPrice) ? prevPrice : null;
      token.__priceChanged = changed;
      token.__priceHighlight = Boolean(highlightActive);
      token.__priceDirection = indicatorDirection;
      token.__priceChangeAt = Number.isFinite(changeAt) ? changeAt : null;

      if (!highlightActive && !changed && mint) {
        tokensPriceState.lastChangeAt.delete(mint);
        tokensPriceState.lastDirections.delete(mint);
      }
    }

    return tokens;
  }

  function renderTokensPlaceholder(message, options) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;

    const opts = options || {};
    const row = document.createElement("tr");
    row.className = "tokens-placeholder-row";

    const cell = document.createElement("td");
    cell.dataset.tokensColspan = "true";
    cell.className = "tokens-placeholder-cell";
    if (opts.variant === "error") {
      cell.classList.add("tokens-placeholder-cell--error");
    } else {
      cell.classList.add("tokens-placeholder-cell--muted");
    }

    cell.colSpan = getTokensTableColspan();
    if (opts.allowHtml) {
      cell.innerHTML = message;
    } else {
      cell.textContent = message;
    }

    row.appendChild(cell);
    tbody.innerHTML = "";
    tbody.appendChild(row);

    if (opts.teardownObserver !== false) {
      teardownTokensScrollObserver();
    }

    updateTokensPlaceholderColspans();
  }

  function showTokensError(message) {
    const finalMessage =
      typeof message === "string" && message.trim().length > 0
        ? message
        : "‚ùå Failed to load tokens";
    renderTokensPlaceholder(finalMessage, { variant: "error" });
    setTokenCountStatus(finalMessage);
  }

  function updateTokenCount(total) {
    const label = document.getElementById("tokenCount");
    if (!label) return;

    const parsedTotal = Number(total);
    let totalValue = Number.isFinite(parsedTotal)
      ? parsedTotal
      : tokensTableState.totalCount;
    if (!Number.isFinite(totalValue) || totalValue < 0) {
      totalValue = allTokensData.length;
    }
    const loaded = Array.isArray(tokensTableState.items)
      ? tokensTableState.items.length
      : allTokensData.length;
    const viewLabel = VIEW_LABELS[tokensState.view] || "";
    const hasFilter =
      typeof tokensState.searchTerm === "string" &&
      tokensState.searchTerm.trim() !== "";

    if (tokensState.view === "all" && !hasFilter) {
      label.textContent = `${totalValue} tokens in database`;
      return;
    }

    if (totalValue > 0 && loaded > 0 && loaded < totalValue) {
      label.textContent = viewLabel
        ? `${loaded}/${totalValue} tokens ${viewLabel}`
        : `${loaded}/${totalValue} tokens`;
      return;
    }

    if (loaded > 0 && totalValue === 0) {
      label.textContent = viewLabel
        ? `${loaded} tokens ${viewLabel}`
        : `${loaded} tokens`;
      return;
    }

    label.textContent = viewLabel
      ? `${totalValue} tokens ${viewLabel}`
      : `${totalValue} tokens`;
  }

  function computeTokenRowClassNames(token) {
    const classes = ["token-row"];
    const priceIndicator = token && token.__priceDirection;
    const highlightActive = token && token.__priceHighlight === true;
    const justChanged = token && token.__priceChanged === true;

    if (
      highlightActive &&
      (priceIndicator === "up" || priceIndicator === "down")
    ) {
      classes.push(
        priceIndicator === "down" ? "token-row--down" : "token-row--up"
      );
    }

    if (justChanged && (priceIndicator === "up" || priceIndicator === "down")) {
      classes.push("token-row--changed");
    }

    return classes.join(" ");
  }

  function createTokenRowElement(token) {
    const row = document.createElement("tr");
    if (token && token.mint) {
      row.dataset.mint = token.mint;
    } else {
      row.dataset.mint = "";
    }
    row.className = computeTokenRowClassNames(token);
    row.style.cursor = "pointer";
    row.title = "Click to view details";

    row.addEventListener("click", () => {
      if (token && token.mint) {
        openTokenDetail(token.mint);
      }
    });

    const columns = getActiveTokenColumns();
    columns.forEach((column) => {
      const cell = document.createElement("td");
      cell.dataset.columnId = column.id;
      applyTokenCell(cell, column, token);
      row.appendChild(cell);
    });

    return row;
  }

  function applyTokenCell(cell, column, token) {
    if (!cell || !column) return;

    const classNames = [];
    if (column.cellClass && typeof column.cellClass === "string") {
      column.cellClass
        .split(/\s+/)
        .filter(Boolean)
        .forEach((cls) => classNames.push(cls));
    }
    if (column.align === "right") {
      classNames.push("align-right");
    } else if (column.align === "center") {
      classNames.push("align-center");
    }

    cell.className = "";
    classNames.forEach((cls) => cell.classList.add(cls));

    switch (column.id) {
      case "token": {
        const symbol = Utils.escapeHtml(token?.symbol || "");
        const name = token?.name ? Utils.escapeHtml(token.name) : "";
        const logo = safeLogoHtml(token?.logo_url, token?.symbol);
        cell.innerHTML = `<div style="display:flex; align-items:center; gap:12px; min-width:0;">${logo}<div style="display:flex; flex-direction:column; gap:1px; min-width:0;"><div style="font-weight:600; color:var(--link-color); font-size:0.95em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${symbol}</div><div style="font-size:0.8em; color:#94a3b8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 260px;">${name}</div></div></div>`;
        break;
      }
      case "price_sol": {
        const priceDisplay = Utils.formatPriceSol(token?.price_sol, {
          fallback: "N/A",
        });
        const rawPrice = Number(token?.price_sol);
        const priceTitle = Number.isFinite(rawPrice)
          ? rawPrice.toFixed(12)
          : token?.price_sol ?? "";
        const priceIndicator = token?.__priceDirection;
        const priceInnerClassNames = ["price-cell__inner"];
        if (priceIndicator === "up") {
          priceInnerClassNames.push("price-cell__inner--up");
        } else if (priceIndicator === "down") {
          priceInnerClassNames.push("price-cell__inner--down");
        }
        cell.title = priceTitle;
        cell.innerHTML = `<div class="${priceInnerClassNames.join(
          " "
        )}"><span class="price-arrow price-arrow--up" aria-hidden="true">‚ñ≤</span><span class="price-arrow price-arrow--down" aria-hidden="true">‚ñº</span><span class="price-value">${priceDisplay}</span></div>`;
        break;
      }
      case "liquidity_usd": {
        cell.textContent = Utils.formatCurrencyUSD(token?.liquidity_usd, {
          fallback: "‚Äî",
        });
        cell.title = token?.liquidity_usd ?? "";
        break;
      }
      case "volume_24h": {
        cell.textContent = Utils.formatCurrencyUSD(token?.volume_24h, {
          fallback: "‚Äî",
        });
        cell.title = token?.volume_24h ?? "";
        break;
      }
      case "fdv": {
        cell.textContent = Utils.formatCurrencyUSD(token?.fdv, {
          fallback: "‚Äî",
        });
        cell.title = token?.fdv ?? "";
        break;
      }
      case "market_cap": {
        cell.textContent = Utils.formatCurrencyUSD(token?.market_cap, {
          fallback: "‚Äî",
        });
        cell.title = token?.market_cap ?? "";
        break;
      }
      case "price_change_h1": {
        cell.innerHTML = Utils.formatPercent(token?.price_change_h1, {
          style: "token",
          fallback: "‚Äî",
        });
        cell.title = token?.price_change_h1 ?? "";
        break;
      }
      case "price_change_h24": {
        cell.innerHTML = Utils.formatPercent(token?.price_change_h24, {
          style: "token",
          fallback: "‚Äî",
        });
        cell.title = token?.price_change_h24 ?? "";
        break;
      }
      case "security_score": {
        cell.innerHTML = renderSecurity(token?.security_score, token?.rugged);
        cell.title = token?.security_score ?? "";
        break;
      }
      case "status": {
        cell.innerHTML = renderStatusBadges(token);
        break;
      }
      case "updated_at": {
        const timeAgo = token?.price_updated_at
          ? Utils.formatTimeAgo(token.price_updated_at, { fallback: "-" })
          : "N/A";
        cell.textContent = timeAgo;
        break;
      }
      case "actions": {
        const mintRaw = token?.mint || "";
        const mintEscaped = Utils.escapeHtml(mintRaw);
        cell.classList.add("align-center");
        cell.innerHTML = `<div class="dropdown-container" data-mint="${mintEscaped}"><button class="dropdown-btn" type="button" onclick="Utils.toggleDropdown(event)" aria-label="Actions">‚ãÆ</button><div class="dropdown-menu"><button onclick="Utils.copyMint('${mintRaw}')" class="dropdown-item">üìã Copy Mint</button><button onclick="Utils.openGMGN('${mintRaw}')" class="dropdown-item">üîó Open GMGN</button><button onclick="Utils.openDexScreener('${mintRaw}')" class="dropdown-item">üìä Open DexScreener</button><button onclick="Utils.openSolscan('${mintRaw}')" class="dropdown-item">üîç Open Solscan</button><button onclick="openTokenDetail('${mintRaw}')" class="dropdown-item">üîé View Details</button></div></div>`;
        cell.addEventListener("click", (event) => {
          event.stopPropagation();
        });
        break;
      }
      case "total_holders": {
        cell.textContent = Utils.formatNumber(token?.total_holders, {
          decimals: 0,
          fallback: "‚Äî",
        });
        cell.title = token?.total_holders ?? "";
        break;
      }
      default: {
        const value =
          token && Object.prototype.hasOwnProperty.call(token, column.id)
            ? token[column.id]
            : null;
        if (value === null || value === undefined || value === "") {
          cell.textContent = "‚Äî";
        } else {
          cell.textContent = String(value);
        }
      }
    }
  }

  function renderTokens(tokens, options) {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return;

    let mode = (options && options.mode) || "replace";
    if (mode === "update") {
      const stateItems = Array.isArray(tokensTableState.items)
        ? tokensTableState.items
        : [];
      if (stateItems.length > 0) {
        tokens = stateItems;
      }
      mode = "replace";
    }
    const table = tbody.closest("table");
    let scrollContainer = null;
    if (
      tokensTableState.scrollContainer instanceof HTMLElement &&
      tokensTableState.scrollContainer.contains(tbody)
    ) {
      scrollContainer = tokensTableState.scrollContainer;
    } else if (table && table.parentElement instanceof HTMLElement) {
      scrollContainer = table.parentElement;
    }

    const previousScroll =
      scrollContainer instanceof HTMLElement
        ? {
            top: scrollContainer.scrollTop,
            left: scrollContainer.scrollLeft,
          }
        : null;
    const openState = captureOpenDropdownState();

    const finalizeRender = () => {
      if (scrollContainer && previousScroll) {
        if (scrollContainer.scrollTop !== previousScroll.top) {
          scrollContainer.scrollTop = previousScroll.top;
        }
        if (scrollContainer.scrollLeft !== previousScroll.left) {
          scrollContainer.scrollLeft = previousScroll.left;
        }
      }
    };

    try {
      if (!Array.isArray(tokens) || tokens.length === 0) {
        if (mode === "append") {
          return;
        }

        if (window.__DEBUG_TOKENS_VERBOSE) {
          console.warn("[TokensDBG] renderTokens: empty data", {
            view: tokensState.view,
            search: tokensState.searchTerm,
            sortBy: tokensState.sortBy,
            sortDir: tokensState.sortDir,
            allTokensDataLen: Array.isArray(allTokensData)
              ? allTokensData.length
              : 0,
            totalCount: tokensTableState.totalCount,
            loading: tokensFetchState.inProgress,
          });
        }

        let statusMessage = "No tokens available.";
        if (
          tokensState &&
          typeof tokensState.searchTerm === "string" &&
          tokensState.searchTerm.trim() !== ""
        ) {
          statusMessage = `No tokens match ‚Äú${tokensState.searchTerm.trim()}‚Äù in this view.`;
        } else if (tokensState.view === "pool") {
          statusMessage =
            "Pool service is warming up ‚Äî waiting for price-enabled tokens.";
        } else {
          const viewLabel = VIEW_LABELS[tokensState.view];
          if (viewLabel) {
            statusMessage = `No tokens ${viewLabel}.`;
          } else if (tokensState.view) {
            statusMessage = `No tokens available for view: ${tokensState.view}.`;
          }
        }

        setTokenCountStatus(statusMessage);
        renderTokensPlaceholder(statusMessage, { variant: "muted" });
        return;
      }

      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] renderTokens: rendering rows", {
          count: tokens.length,
          view: tokensState.view,
          mode,
        });
      }

      if (mode === "append") {
        const guard = ensureTokensScrollGuard();
        const targetParent =
          guard && guard.parentElement ? guard.parentElement : tbody;
        const existingMints = new Set(
          Array.from(tbody.querySelectorAll("tr[data-mint]"))
            .map((row) => row.getAttribute("data-mint"))
            .filter(Boolean)
        );
        const fragment = document.createDocumentFragment();

        tokens.forEach((token) => {
          if (!token || !token.mint || existingMints.has(token.mint)) {
            return;
          }
          existingMints.add(token.mint);
          fragment.appendChild(createTokenRowElement(token));
        });

        if (fragment.childNodes.length > 0) {
          if (guard && guard.parentElement === targetParent) {
            targetParent.insertBefore(fragment, guard);
          } else {
            targetParent.appendChild(fragment);
          }
        }

        ensureTokensScrollGuard();
      } else {
        const fragment = document.createDocumentFragment();
        tokens.forEach((token) => {
          fragment.appendChild(createTokenRowElement(token));
        });

        const guard = document.getElementById("tokens-scroll-guard");
        if (guard && guard.parentElement === tbody) {
          guard.parentElement.removeChild(guard);
        }

        tbody.innerHTML = "";
        tbody.appendChild(fragment);
        ensureTokensScrollGuard();
      }

      updateTokensPlaceholderColspans();
    } finally {
      finalizeRender();
      restoreDropdownState(openState);
    }
  }

  function ensureTokensScrollGuard() {
    const tbody = document.getElementById("tokensTableBody");
    if (!tbody) return null;
    let guard = document.getElementById("tokens-scroll-guard");
    if (!guard) {
      tbody.insertAdjacentHTML("beforeend", TOKENS_SCROLL_GUARD_HTML);
      guard = document.getElementById("tokens-scroll-guard");
    } else if (guard.parentElement !== tbody) {
      guard.parentElement.removeChild(guard);
      tbody.appendChild(guard);
    } else if (tbody.lastElementChild !== guard) {
      tbody.appendChild(guard);
    }
    return guard;
  }

  function setTokensScrollGuardState(state) {
    const guard = ensureTokensScrollGuard();
    if (!guard) return;
    const cell = guard.querySelector(".scroll-guard-cell");
    if (!cell) return;
    if (state === "hidden") {
      guard.style.display = "none";
    } else {
      guard.style.display = "";
    }
    cell.classList.toggle("loading", state === "loading");
    if (state === "loading") {
      cell.textContent = "Loading more tokens‚Ä¶";
    } else if (state === "end") {
      cell.textContent =
        tokensTableState.items.length > 0 ? "No more tokens" : "";
    } else {
      cell.textContent = "";
    }
  }

  function teardownTokensScrollObserver() {
    if (tokensTableState.scrollObserver) {
      try {
        tokensTableState.scrollObserver.disconnect();
      } catch (_) {}
    }
    tokensTableState.scrollObserver = null;
    tokensTableState.scrollContainer = null;
  }

  function ensureScrollObserverActive() {
    const guard = document.getElementById("tokens-scroll-guard");
    const container = document.querySelector(".table-wrap");
    const tbody = document.getElementById("tokensTableBody");

    if (!guard || !container || !tbody) {
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log(
          "[TokensDBG] ensureScrollObserverActive: missing elements",
          {
            guard: !!guard,
            container: !!container,
            tbody: !!tbody,
          }
        );
      }
      return false;
    }

    // Ensure guard is last child of tbody
    if (guard.parentElement === tbody && tbody.lastElementChild !== guard) {
      tbody.appendChild(guard);
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] Guard repositioned to bottom");
      }
    }

    // Re-observe if observer exists
    if (tokensTableState.scrollObserver) {
      tokensTableState.scrollObserver.disconnect();
      tokensTableState.scrollObserver.observe(guard);
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] Observer reconnected to guard");
      }
    } else {
      setupTokensScrollObserver();
    }

    return true;
  }

  function setupTokensScrollObserver() {
    teardownTokensScrollObserver();
    const guard = ensureTokensScrollGuard();
    const container = document.querySelector(".table-wrap");
    if (!guard || !container) {
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log(
          "[TokensDBG] setupTokensScrollObserver: missing guard or container"
        );
      }
      return;
    }

    // SAFEGUARD: If we have items rendered but currentPage is 0, fix to 1 so next load fetches page 2
    if (
      tokensTableState.currentPage === 0 &&
      Array.isArray(tokensTableState.items) &&
      tokensTableState.items.length > 0
    ) {
      tokensTableState.currentPage = 1;
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] Fixed currentPage from 0 to 1");
      }
    }

    if (
      tokensTableState.totalPages <= 1 ||
      tokensTableState.currentPage >= tokensTableState.totalPages
    ) {
      setTokensScrollGuardState("end");
      if (window.__DEBUG_TOKENS_VERBOSE) {
        console.log("[TokensDBG] No more pages, setting guard to end state");
      }
      return;
    }

    setTokensScrollGuardState("idle");
    tokensTableState.scrollContainer = container;
    tokensTableState.scrollObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (window.__DEBUG_TOKENS_VERBOSE) {
              console.log("[TokensDBG] Guard intersecting, loading next page");
            }
            loadNextTokensPage({ skipObserverRefresh: true });
          }
        });
      },
      { root: container, rootMargin: "320px 0px 0px 0px", threshold: 0 }
    );

    tokensTableState.scrollObserver.observe(guard);

    if (window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] ScrollObserver setup complete", {
        currentPage: tokensTableState.currentPage,
        totalPages: tokensTableState.totalPages,
        guardExists: !!guard,
      });
    }
  }

  function captureOpenDropdownState() {
    const menu = document.querySelector(".dropdown-menu.show");
    if (!menu) return null;
    const row = menu.closest("tr[data-mint]");
    if (!row) return null;
    return { mint: row.dataset.mint };
  }

  function restoreDropdownState(state) {
    if (!state || !state.mint) return;
    const container = document.querySelector(
      `.dropdown-container[data-mint="${state.mint}"]`
    );
    if (!container) return;

    const btn = container.querySelector(".dropdown-btn");
    const menu = container.querySelector(".dropdown-menu");
    if (!btn || !menu) return;

    openDropdownMenu(btn, menu);
  }

  function setTokenCountStatus(text) {
    const label = document.getElementById("tokenCount");
    if (!label) return;
    label.textContent = text;
  }

  function showTokensLoading(message) {
    const finalMessage =
      typeof message === "string" && message.trim().length > 0
        ? message
        : "Loading tokens...";
    renderTokensPlaceholder(finalMessage, {
      variant: "muted",
      teardownObserver: true,
    });
    setTokenCountStatus(finalMessage);
  }

  function buildTokensListQuery(page, pageSize) {
    const params = new URLSearchParams();
    params.set("view", tokensState.view);
    if (tokensState.searchTerm) {
      params.set("search", tokensState.searchTerm);
    }
    params.set("sort_by", tokensState.sortBy);
    params.set("sort_dir", tokensState.sortDir);
    params.set("page", String(page));
    const requestedSize =
      pageSize || tokensTableState.pageSize || TOKENS_PAGE_LIMIT;
    const safeSize = clampTokensPageSize(requestedSize);
    params.set("page_size", String(safeSize));
    return params;
  }

  async function fetchTokensListPage(page, options) {
    const opts = options || {};
    const requestedSize =
      opts.pageSize || tokensTableState.pageSize || TOKENS_PAGE_LIMIT;
    const pageSize = clampTokensPageSize(requestedSize);
    const params = buildTokensListQuery(page, pageSize);
    const url = `/api/tokens/list?${params.toString()}`;
    if (window.__DEBUG_TOKENS_VERBOSE) {
      console.log("[TokensDBG] HTTP page fetch", { page, pageSize, url });
    }
    const res = await fetch(url, {
      headers: { "X-Requested-With": "fetch" },
      signal: opts.signal,
    });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const body = await res.json();
    const normalized = Array.isArray(body.items)
      ? body.items.map(normalizeTokenFromApi)
      : [];
    const deduped = dedupeTokensByMint(normalized);
    annotateTokensWithPriceChange(deduped);
    const total = Number(body.total) || normalized.length;
    const totalPages =
      Number(body.total_pages) ||
      (pageSize > 0 ? Math.ceil(total / pageSize) : 1);
    const responsePageSize = Number(body.page_size) || pageSize;
    return {
      items: deduped,
      total,
      totalPages,
      pageSize: responsePageSize,
    };
  }

  async function loadNextTokensPage(options) {
    const opts = options || {};
    if (tokensTableState.loading) {
      tokensTableState.pendingReload = true;
      return false;
    }

    if (
      tokensTableState.totalPages <= 1 ||
      tokensTableState.currentPage >= tokensTableState.totalPages
    ) {
      setTokensScrollGuardState("end");
      return false;
    }

    const nextPage = tokensTableState.currentPage + 1;
    tokensTableState.loading = true;
    setTokensScrollGuardState("loading");

    try {
      const result = await fetchTokensListPage(nextPage, {
        pageSize: opts.pageSize,
        signal: opts.signal,
      });
      tokensTableState.pageSize = clampTokensPageSize(
        result.pageSize || tokensTableState.pageSize
      );
      tokensTableState.totalPages =
        result.totalPages || tokensTableState.totalPages;
      tokensTableState.totalCount = result.total || tokensTableState.totalCount;

      const existingMints = new Set(
        (tokensTableState.items || []).map((token) => token && token.mint)
      );
      const fresh = result.items.filter((token) => {
        if (!token || !token.mint) return false;
        if (existingMints.has(token.mint)) {
          return false;
        }
        existingMints.add(token.mint);
        return true;
      });

      if (fresh.length > 0) {
        const tbody = document.getElementById("tokensTableBody");
        const rowCountBefore = tbody
          ? tbody.querySelectorAll("tr[data-mint]").length
          : 0;

        appendTokensToState(fresh);
        renderTokens(fresh, { mode: "append" });

        // Verify append succeeded by checking DOM row count
        const rowCountAfter = tbody
          ? tbody.querySelectorAll("tr[data-mint]").length
          : 0;
        const actuallyAdded = rowCountAfter - rowCountBefore;

        if (actuallyAdded > 0) {
          // Success - update page counter
          tokensTableState.currentPage = Math.min(
            nextPage,
            tokensTableState.totalPages
          );

          if (window.__DEBUG_TOKENS_VERBOSE) {
            console.log(
              `[TokensDBG] Page ${nextPage} loaded: ${actuallyAdded} rows added, total: ${rowCountAfter}`
            );
          }
        } else {
          // Failed to add rows - don't increment page counter
          console.error(
            `[Tokens] Failed to append rows for page ${nextPage}:`,
            {
              freshCount: fresh.length,
              rowsBefore: rowCountBefore,
              rowsAfter: rowCountAfter,
            }
          );
        }
      } else {
        // No new items, still increment page counter to avoid retry loop
        tokensTableState.currentPage = Math.min(
          nextPage,
          tokensTableState.totalPages
        );

        if (window.__DEBUG_TOKENS_VERBOSE) {
          console.log(
            `[TokensDBG] Page ${nextPage}: no new items (all duplicates)`
          );
        }
      }

      updateTokenCount(tokensTableState.totalCount);

      if (tokensTableState.currentPage >= tokensTableState.totalPages) {
        setTokensScrollGuardState("end");
        teardownTokensScrollObserver();
      } else {
        setTokensScrollGuardState("idle");
        if (!opts.skipObserverRefresh) {
          setupTokensScrollObserver();
        } else {
          // Even if skipping full setup, ensure guard is positioned correctly
          ensureScrollObserverActive();
        }
      }

      return fresh.length > 0;
    } catch (err) {
      console.warn("[Tokens] Failed to load additional tokens", err);
      setTokensScrollGuardState("end");
      return false;
    } finally {
      tokensTableState.loading = false;
      tokensTableState.pendingReload = false;
    }
  }

  async function reloadTokensList(message, options) {
    const opts = options || {};
    const statusMessage = message || "Loading tokens...";
    const preserveItems = opts.preserveItems === true;
    // If we're preserving items (auto-refresh/search), do NOT reset pagination by default
    const resetPagination =
      opts.resetPagination !== undefined
        ? opts.resetPagination
        : !preserveItems;
    const silent = opts.silent === true;

    if (tokensFetchState.abortController) {
      try {
        tokensFetchState.abortController.abort();
      } catch (_) {
        /* no-op */
      }
    }

    if (resetPagination) {
      resetTokensPagination({ preserveItems });
    } else {
      tokensTableState.loading = true;
      tokensTableState.pendingReload = true;
    }

    tokensFetchState.inProgress = true;
    tokensFetchState.message = silent ? "" : statusMessage;
    tokensTableState.loading = true;
    tokensTableState.pendingReload = true;

    const hasExistingRows =
      Array.isArray(allTokensData) && allTokensData.length > 0;
    if (!preserveItems || !hasExistingRows) {
      showTokensLoading(statusMessage);
    } else if (!silent) {
      setTokenCountStatus(statusMessage);
    }

    if (!silent || !hasExistingRows) {
      setTokensScrollGuardState("loading");
    }

    const controller = new AbortController();
    tokensFetchState.abortController = controller;

    try {
      const result = await fetchTokensListPage(1, {
        pageSize: opts.pageSize,
        signal: controller.signal,
      });

      if (preserveItems && hasExistingRows) {
        // Auto-refresh mode: refresh top rows while preserving scroll position
        const updateMap = new Map(result.items.map((t) => [t.mint, t]));
        const existingItems = Array.isArray(tokensTableState.items)
          ? tokensTableState.items
          : [];

        const seenMints = new Set();
        const reorderedItems = [];

        // Start with freshly sorted page 1 results
        result.items.forEach((token) => {
          if (!token || !token.mint || seenMints.has(token.mint)) {
            return;
          }
          reorderedItems.push(token);
          seenMints.add(token.mint);
        });

        // Append any previously loaded tokens that were not in the fresh page
        existingItems.forEach((existingToken) => {
          if (!existingToken || !existingToken.mint) return;
          if (seenMints.has(existingToken.mint)) return;
          const freshData = updateMap.get(existingToken.mint);
          reorderedItems.push(freshData || existingToken);
          seenMints.add(existingToken.mint);
        });

        tokensTableState.items = reorderedItems;
        allTokensData = tokensTableState.items;

        // Patch only the visible rows to avoid scroll jumps while keeping order
        renderTokens(result.items, { mode: "update" });

        // Update metadata but preserve pagination state
        tokensTableState.totalCount =
          Number(result.total) || tokensTableState.totalCount;
        tokensTableState.totalPages =
          result.totalPages || tokensTableState.totalPages;
        // SAFEGUARD: Ensure currentPage is at least 1 when we have items
        if (
          tokensTableState.currentPage === 0 &&
          Array.isArray(tokensTableState.items) &&
          tokensTableState.items.length > 0
        ) {
          tokensTableState.currentPage = 1;
        }

        updateTokenCount(tokensTableState.totalCount);

        const viewLabel = VIEW_LABELS[tokensState.view] || "";
        const status = viewLabel
          ? `${tokensTableState.totalCount} tokens ${viewLabel}`
          : `${tokensTableState.totalCount} tokens`;
        setTokenCountStatus(status);

        // Ensure scroll observer remains active if more pages are available
        if (tokensTableState.currentPage >= tokensTableState.totalPages) {
          setTokensScrollGuardState("end");
          teardownTokensScrollObserver();
        } else {
          setTokensScrollGuardState("idle");
          // Always ensure observer is active and guard is positioned correctly after update
          if (
            !tokensTableState.scrollObserver ||
            typeof tokensTableState.scrollObserver.observe !== "function"
          ) {
            setupTokensScrollObserver();
          } else {
            // Observer exists, just ensure guard is positioned and re-observed
            ensureScrollObserverActive();
          }
        }

        if (window.__DEBUG_TOKENS_VERBOSE) {
          console.log("[TokensDBG] Auto-refresh complete:", {
            currentPage: tokensTableState.currentPage,
            totalPages: tokensTableState.totalPages,
            itemsInMemory: tokensTableState.items.length,
            rowsInDOM: document.querySelectorAll(
              "#tokensTableBody tr[data-mint]"
            ).length,
            observerActive: !!tokensTableState.scrollObserver,
          });
        }
      } else {
        // Full reload: replace everything
        replaceAllTokensData(result.items);

        tokensTableState.pageSize = clampTokensPageSize(
          result.pageSize || TOKENS_PAGE_LIMIT
        );
        tokensTableState.currentPage =
          tokensTableState.items.length > 0 ? 1 : 0;
        tokensTableState.totalPages =
          result.totalPages || (tokensTableState.currentPage > 0 ? 1 : 0);
        tokensTableState.totalCount =
          Number(result.total) || tokensTableState.items.length;

        if (tokensTableState.items.length === 0) {
          renderTokens(tokensTableState.items, { mode: "replace" });
          updateTokenCount(tokensTableState.totalCount);
          setTokensScrollGuardState("hidden");
          teardownTokensScrollObserver();
        } else {
          renderTokens(tokensTableState.items, { mode: "replace" });
          updateTokenCount(tokensTableState.totalCount);

          if (tokensTableState.currentPage < tokensTableState.totalPages) {
            setTokensScrollGuardState("idle");
            setupTokensScrollObserver();
          } else {
            setTokensScrollGuardState("end");
            teardownTokensScrollObserver();
          }

          const viewLabel = VIEW_LABELS[tokensState.view] || "";
          const status = viewLabel
            ? `${tokensTableState.totalCount} tokens ${viewLabel}`
            : `${tokensTableState.totalCount} tokens`;
          setTokenCountStatus(status);
        }
      }
    } catch (err) {
      if (err && err.name === "AbortError") {
        return;
      }
      console.error("[Tokens] Failed to load tokens list", err);
      if (silent && preserveItems) {
        Utils.showToast("‚ùå Failed to refresh tokens", "error");
      } else {
        showTokensError("‚ùå Failed to load tokens");
      }
    } finally {
      if (tokensFetchState.abortController === controller) {
        tokensFetchState.abortController = null;
      }
      tokensFetchState.inProgress = false;
      tokensFetchState.message = "";
      tokensTableState.loading = false;
      tokensTableState.pendingReload = false;
    }
  }

  function cleanupTokensPage() {
    teardownTokensScrollObserver();

    if (tokensFetchState.abortController) {
      try {
        tokensFetchState.abortController.abort();
      } catch (_) {
        /* no-op */
      }
      tokensFetchState.abortController = null;
    }

    tokensFetchState.inProgress = false;
    tokensFetchState.message = "";
    tokensTableState.loading = false;
    tokensTableState.pendingReload = false;

    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
      searchDebounceHandle = null;
    }

    if (window.__tokensVisibilityHandler) {
      document.removeEventListener(
        "visibilitychange",
        window.__tokensVisibilityHandler
      );
      window.__tokensVisibilityHandler = null;
    }

    stopTokensAutoRefresh();
    closeTokensColumnDialog();
  }

  function openDropdownMenu(btn, menu) {
    const rect = btn.getBoundingClientRect();
    const menuWidth = Math.max(200, menu.offsetWidth || 200);
    const viewportWidth = window.innerWidth;
    const rightSpace = viewportWidth - rect.right;

    menu.classList.add("show");
    menu.style.position = "fixed";
    menu.style.top = `${Math.round(rect.bottom + 4)}px`;
    if (rightSpace < menuWidth) {
      menu.style.left = `${Math.max(8, Math.round(rect.right - menuWidth))}px`;
      menu.style.right = "";
    } else {
      menu.style.left = `${Math.round(rect.left)}px`;
      menu.style.right = "";
    }
    menu.style.width = `${menuWidth}px`;
  }

  function setupSortableHeaders() {
    const thead = document.querySelector("#tokensTable thead");
    if (!thead) return;
    if (window.__tokensSortHeadersSetup) return;
    thead.addEventListener("click", (e) => {
      if (e.target.closest(".column-resize-handle")) {
        return;
      }
      const th = e.target.closest("th.sortable");
      if (!th) return;
      const key = th.getAttribute("data-sort-key");
      if (!key) return;
      if (tokensState.sortBy === key) {
        tokensState.sortDir = tokensState.sortDir === "asc" ? "desc" : "asc";
      } else {
        tokensState.sortBy = key;
        tokensState.sortDir = key === "symbol" ? "asc" : "desc";
      }
      persistTokensSortState();
      updateSortIndicators();
      reloadTokensList("Sorting tokens...");
    });
    updateSortIndicators();
    window.__tokensSortHeadersSetup = true;
  }

  function updateSortIndicators() {
    const indicators = document.querySelectorAll(
      "#tokensTable .sort-indicator"
    );
    indicators.forEach((el) => {
      const sortKey = el.getAttribute("data-sort-key");
      if (sortKey === tokensState.sortBy) {
        el.textContent = tokensState.sortDir === "asc" ? "‚ñ≤" : "‚ñº";
      } else {
        el.textContent = "";
      }
    });

    if (
      tokensColumnManager &&
      typeof tokensColumnManager.setSortState === "function"
    ) {
      tokensColumnManager.setSortState(tokensState.sortBy, tokensState.sortDir);
    }
  }

  function safeLogoHtml(url, symbol) {
    let fallback = "?";
    if (symbol && typeof symbol === "string") {
      for (const ch of symbol) {
        const u = ch.toUpperCase();
        if (/^[A-Z0-9]$/.test(u)) {
          fallback = u;
          break;
        }
      }
    }
    if (!url) {
      return `<div style="width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg, #1565c0 0%, #0f4c81 100%);color:white;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:0.85em;flex-shrink:0;">${fallback}</div>`;
    }
    const esc = (s) =>
      (s || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    return `<img src="${esc(url)}" alt="${esc(
      symbol || ""
    )}" width="32" height="32" style="border-radius:8px;object-fit:cover;flex-shrink:0;box-shadow:0 1px 3px rgba(0,0,0,0.1);" onerror="fallbackLogo(this, '${fallback}')">`;
  }

  function fallbackLogo(img, letter) {
    try {
      img.onerror = null;
      const div = document.createElement("div");
      div.style.width = "32px";
      div.style.height = "32px";
      div.style.borderRadius = "8px";
      div.style.background =
        "linear-gradient(135deg, #1565c0 0%, #0f4c81 100%)";
      div.style.color = "white";
      div.style.display = "flex";
      div.style.alignItems = "center";
      div.style.justifyContent = "center";
      div.style.fontWeight = "700";
      div.style.fontSize = "0.85em";
      div.style.flexShrink = "0";
      div.textContent = letter && /^[A-Z0-9]$/.test(letter) ? letter : "?";
      img.replaceWith(div);
    } catch (_) {
      /* no-op */
    }
  }

  function renderSecurity(score, rugged) {
    if (rugged === true) {
      return '<span class="badge error">RUG</span>';
    }
    if (score === null || score === undefined) return "‚Äî";
    let tier = "baseline";
    if (score >= 700) tier = "elite";
    else if (score >= 500) tier = "high";
    else if (score >= 300) tier = "medium";
    else if (score >= 0) tier = "low";
    return `<span class="security-score security-score--${tier}">${score}</span>`;
  }

  function renderStatusBadges(token) {
    const badges = [];
    if (token.has_pool_price)
      badges.push('<span class="badge badge--pool">POOL</span>');
    if (token.has_ohlcv)
      badges.push('<span class="badge badge--ohlcv">OHLCV</span>');
    if (token.has_open_position)
      badges.push('<span class="badge badge--position">POS</span>');
    if (token.blacklisted)
      badges.push('<span class="badge badge--blacklisted">BL</span>');
    return badges.join(" ");
  }

  function openTokenDetail(mint) {
    if (!mint) return;
    openTokenModal(mint).catch((err) => {
      console.error("Failed to open token modal:", err);
      Utils.showToast("‚ùå Failed to open token details", "error");
    });
  }
</script>

<div class="page-table">
  <div class="table-wrap">
    <table class="table" id="tokensTable">
      <thead>
        <tr></tr>
      </thead>
      <tbody id="tokensTableBody">
        <tr class="tokens-placeholder-row">
          <td
            data-tokens-colspan="true"
            class="tokens-placeholder-cell tokens-placeholder-cell--muted"
            colspan="12"
          >
            <div class="loading-text">Loading tokens...</div>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div class="column-dialog" id="tokensColumnDialog" aria-hidden="true">
  <div
    class="column-dialog__panel"
    role="dialog"
    aria-modal="true"
    aria-labelledby="tokensColumnDialogTitle"
  >
    <header class="column-dialog__header">
      <h2 class="column-dialog__title" id="tokensColumnDialogTitle">
        Table Columns
      </h2>
      <button
        type="button"
        class="column-dialog__close"
        id="tokensColumnClose"
        aria-label="Close"
      >
        √ó
      </button>
    </header>
    <div class="column-dialog__body">
      <div class="column-dialog__list" id="tokensColumnList"></div>
    </div>
    <footer class="column-dialog__footer">
      <div class="column-dialog__hint">
        Toggle columns to customize the table. Drag headers to resize widths.
      </div>
      <div class="spacer"></div>
      <button type="button" class="btn btn-secondary" id="tokensColumnReset">
        Reset
      </button>
      <button type="button" class="btn btn-primary" id="tokensColumnApply">
        Apply
      </button>
    </footer>
  </div>
</div>

<!-- Token Details Modal -->
<div
  class="token-modal-overlay"
  id="tokenModal"
  onclick="closeTokenModal(event)"
>
  <div class="token-modal" onclick="event.stopPropagation()">
    <!-- Modal Header -->
    <div class="modal-header">
      <div class="modal-header-left">
        <img id="modalTokenLogo" class="modal-token-logo" src="" alt="" />
        <div class="modal-token-info">
          <div class="modal-token-symbol" id="modalTokenSymbol">SONIC</div>
          <div class="modal-token-name" id="modalTokenName">Sonic SVM</div>
          <div class="modal-token-tagline" id="modalTokenTagline"></div>
          <div class="modal-token-badges" id="modalTokenBadges"></div>
          <div class="modal-token-tags" id="modalTokenTags"></div>
        </div>
      </div>
      <div class="modal-price-info">
        <div class="modal-price-stack">
          <div class="modal-price" id="modalTokenPrice">0.00077622</div>
          <div class="modal-price-sub" id="modalTokenPriceUsd">$0.00</div>
        </div>
        <div class="modal-price-change positive" id="modalTokenChange">
          +2.12%
        </div>
      </div>
      <button
        class="modal-close-btn"
        onclick="closeTokenModal()"
        title="Close (ESC)"
      >
        √ó
      </button>
    </div>

    <!-- Modal Body -->
    <div class="modal-body token-detail-body">
      <!-- Main Content Area -->
      <div class="modal-main">
        <!-- Tabs Navigation -->
        <div class="modal-tabs">
          <button class="modal-tab active" onclick="switchModalTab('overview')">
            üìä Overview
          </button>
          <button class="modal-tab" onclick="switchModalTab('security')">
            üõ°Ô∏è Security
          </button>
          <button class="modal-tab" onclick="switchModalTab('chart')">
            üìà Chart
          </button>
          <button class="modal-tab" onclick="switchModalTab('transactions')">
            üí± Transactions
          </button>
        </div>

        <!-- Tab Content -->
        <div class="modal-content">
          <!-- Overview Tab -->
          <div class="tab-pane active" id="tab-overview">
            <div class="overview-summary">
              <div class="summary-card">
                <div class="summary-card__label">Price</div>
                <div class="summary-card__value" id="summary-price-sol">‚Äî</div>
                <div class="summary-card__meta" id="summary-price-usd">‚Äî</div>
                <div class="summary-card__delta" id="summary-change-24h">‚Äî</div>
              </div>
              <div class="summary-card">
                <div class="summary-card__label">Liquidity</div>
                <div class="summary-card__value" id="summary-liquidity">‚Äî</div>
                <div class="summary-card__meta" id="summary-confidence">
                  Confidence ‚Äî
                </div>
                <div class="summary-card__meta" id="summary-last-updated">
                  Price updated ‚Äî
                </div>
              </div>
              <div class="summary-card">
                <div class="summary-card__label">Volume 24h</div>
                <div class="summary-card__value" id="summary-volume">‚Äî</div>
                <div class="summary-card__meta" id="summary-volume-1h">
                  1h ‚Äî
                </div>
                <div class="summary-card__meta" id="summary-volume-5m">
                  5m ‚Äî
                </div>
              </div>
              <div class="summary-card">
                <div class="summary-card__label">Net Flow 24h</div>
                <div class="summary-card__value" id="summary-netflow">‚Äî</div>
                <div class="summary-card__meta" id="summary-buys-sells">
                  Buys ‚Äî / Sells ‚Äî
                </div>
                <div class="summary-card__meta" id="summary-ratio">Ratio ‚Äî</div>
              </div>
            </div>

            <div class="metric-card metric-card--wide token-text-card">
              <div class="metric-card-header">üìù Token Overview</div>
              <div class="token-description is-empty" id="detail-description">
                No project overview available.
              </div>
            </div>

            <div class="metrics-grid metrics-grid--responsive">
              <div class="metric-card">
                <div class="metric-card-header">üßæ Token Profile</div>
                <div
                  class="metric-row metric-row--wrap"
                  title="Full mint address"
                >
                  <span class="metric-label">Mint</span>
                  <span
                    class="metric-value metric-value--muted"
                    id="detail-mint"
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">Decimals</span>
                  <span class="metric-value" id="detail-decimals">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Verified</span>
                  <span class="metric-value" id="detail-verified">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Blacklisted</span>
                  <span class="metric-value" id="detail-blacklisted">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Launch</span>
                  <span class="metric-value" id="detail-launch-date">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Last Updated</span>
                  <span class="metric-value" id="detail-last-updated">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Boosts Active</span>
                  <span class="metric-value" id="detail-boosts">‚Äî</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üí∞ Market Metrics</div>
                <div class="metric-row">
                  <span class="metric-label">Liquidity (USD)</span>
                  <span class="metric-value" id="detail-liquidity">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Base Reserves</span>
                  <span class="metric-value" id="detail-base-liquidity">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Quote Reserves</span>
                  <span class="metric-value" id="detail-quote-liquidity"
                    >‚Äî</span
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">FDV</span>
                  <span class="metric-value" id="detail-fdv">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Market Cap</span>
                  <span class="metric-value" id="detail-marketcap">‚Äî</span>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-card-header">üèä Pool</div>
                <div class="metric-row">
                  <span class="metric-label">DEX</span>
                  <span class="metric-value" id="detail-dex">‚Äî</span>
                </div>
                <div class="metric-row metric-row--wrap">
                  <span class="metric-label">Pool Address</span>
                  <a
                    class="metric-value metric-link"
                    id="detail-pool-link"
                    href="#"
                    target="_blank"
                    rel="noopener"
                    >‚Äî</a
                  >
                </div>
                <div class="metric-row">
                  <span class="metric-label">SOL Reserves</span>
                  <span class="metric-value" id="detail-sol-reserves">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Token Reserves</span>
                  <span class="metric-value" id="detail-token-reserves">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Confidence</span>
                  <span class="metric-value" id="detail-confidence">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Price Updated</span>
                  <span class="metric-value" id="detail-price-updated">‚Äî</span>
                </div>
                <div class="metric-row">
                  <span class="metric-label">Pool Age</span>
                  <span class="metric-value" id="detail-pool-age">‚Äî</span>
                </div>
              </div>

              <div class="metric-card metric-card--wide">
                <div class="metric-card-header">üìä Price Movement</div>
                <div class="metric-table" id="detail-price-table"></div>
              </div>

              <div class="metric-card metric-card--wide">
                <div class="metric-card-header">
                  üí± Volume &amp; Transactions
                </div>
                <div class="metric-table" id="detail-activity-table"></div>
              </div>

              <div class="metric-card metric-card--wide">
                <div class="metric-card-header">üè∑Ô∏è Tags &amp; Labels</div>
                <div class="badge-grid" id="detail-tag-badges"></div>
                <div class="badge-grid" id="detail-label-badges"></div>
              </div>
            </div>
          </div>

          <!-- Security Tab -->
          <div class="tab-pane" id="tab-security">
            <div class="security-badge excellent" id="security-badge">
              <span>üõ°Ô∏è</span>
              <span
                >Security Score: <span id="security-score-value">35593</span> /
                40000</span
              >
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">Overall Security Analysis</div>
              <div class="progress-bar">
                <div
                  class="progress-fill"
                  id="security-progress"
                  style="width: 89%"
                ></div>
              </div>
              <div
                style="margin-top: 12px; color: #94a3b8; font-size: 0.9em"
                id="security-status"
              >
                ‚úÖ This token passes major security checks
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üîë Token Authorities</div>
              <div class="metric-row">
                <span class="metric-label">Mint Authority</span>
                <span
                  class="metric-value"
                  id="detail-mint-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
              <div class="metric-row">
                <span class="metric-label">Freeze Authority</span>
                <span
                  class="metric-value"
                  id="detail-freeze-auth"
                  style="font-size: 0.75em"
                  >None ‚úÖ</span
                >
              </div>
            </div>

            <div class="metric-card" style="margin-bottom: 20px">
              <div class="metric-card-header">üë• Holder Distribution</div>
              <div class="metric-row">
                <span class="metric-label">Total Holders</span>
                <span class="metric-value" id="detail-holders">1,234</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Top 10 Concentration</span>
                <span class="metric-value" id="detail-top10">45.2%</span>
              </div>
            </div>

            <div class="metric-card-header" style="margin-bottom: 12px">
              ‚ö†Ô∏è Risk Factors
            </div>
            <div class="risk-list" id="risk-factors-list">
              <!-- Risk items will be populated here -->
            </div>
          </div>

          <!-- Chart Tab -->
          <div class="tab-pane" id="tab-chart">
            <div
              id="token-chart-container"
              style="
                height: 500px;
                width: 100%;
                position: relative;
                background: #1a1a1a;
                border-radius: 8px;
                overflow: hidden;
              "
            >
              <div id="token-chart" style="width: 100%; height: 100%"></div>
              <div id="chart-loading" class="chart-loading">
                <div class="spinner"></div>
                <p>Loading chart data...</p>
              </div>
              <div id="chart-error" class="chart-error" style="display: none">
                <p>Failed to load chart data</p>
                <button onclick="retryChartLoad()">Retry</button>
              </div>
            </div>

            <!-- Chart Controls -->
            <div class="chart-controls">
              <div class="timeframe-selector">
                <button class="tf-btn active" data-tf="1m">1m</button>
                <button class="tf-btn" data-tf="5m">5m</button>
                <button class="tf-btn" data-tf="15m">15m</button>
                <button class="tf-btn" data-tf="1h">1h</button>
                <button class="tf-btn" data-tf="4h">4h</button>
                <button class="tf-btn" data-tf="1d">1D</button>
              </div>

              <div class="indicator-toggles">
                <label
                  ><input type="checkbox" id="show-volume" checked />
                  Volume</label
                >
                <label><input type="checkbox" id="show-ma20" /> MA(20)</label>
                <label><input type="checkbox" id="show-ma50" /> MA(50)</label>
              </div>
            </div>
          </div>

          <!-- Transactions Tab -->
          <div class="tab-pane" id="tab-transactions">
            <div class="metric-card">
              <div class="metric-card-header">üìú Recent Transactions</div>
              <div
                id="transactions-list"
                style="color: #94a3b8; text-align: center; padding: 40px"
              >
                Loading recent transactions...
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="modal-sidebar">
        <div class="sidebar-section">
          <div class="sidebar-section-title">‚ö° Live Metrics</div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Price (SOL)</span>
            <span class="sidebar-metric-value" id="sidebar-price"
              >0.00077622</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">24h Volume</span>
            <span class="sidebar-metric-value" id="sidebar-volume"
              >$124.3K</span
            >
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Liquidity</span>
            <span class="sidebar-metric-value" id="sidebar-liq">$628.7K</span>
          </div>
          <div class="sidebar-metric">
            <span class="sidebar-metric-label">Market Cap</span>
            <span class="sidebar-metric-value" id="sidebar-mcap">$64.86M</span>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üîó Quick Actions</div>
          <div class="quick-actions">
            <button
              class="quick-action-btn"
              id="action-copy-mint"
              onclick="copyMintFromModal()"
            >
              üìã Copy Mint Address
            </button>
            <button
              class="quick-action-btn quick-action-btn--disabled"
              id="action-website"
              onclick="openWebsiteFromModal()"
              disabled
            >
              üåê Open Website ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-dexscreener"
              onclick="openDexScreenerFromModal()"
            >
              üìä Open DexScreener ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-gmgn"
              onclick="openGMGNFromModal()"
            >
              üîó Open GMGN ‚Üí
            </button>
            <button
              class="quick-action-btn"
              id="action-solscan"
              onclick="openSolscanFromModal()"
            >
              üîç Open Solscan ‚Üí
            </button>
          </div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üåê External Links</div>
          <div class="sidebar-link-list" id="sidebar-websites"></div>
          <div class="sidebar-link-list" id="sidebar-socials"></div>
        </div>

        <div class="sidebar-section">
          <div class="sidebar-section-title">üè∑Ô∏è Status Flags</div>
          <div id="sidebar-badges" class="badge-grid"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // ============================================================================
  // CHART INTEGRATION
  // ============================================================================

  let tokenChartManager = null;

  /**
   * Show chart error message
   * @param {string} message - Error message to display
   */
  function showChartError(message) {
    const loading = document.getElementById("chart-loading");
    const error = document.getElementById("chart-error");

    console.log("[TokenChart] showChartError:", message);

    if (loading) loading.style.display = "none";
    if (error) {
      error.style.display = "flex";
      const errorText = error.querySelector("p");
      if (errorText) {
        errorText.textContent = message;
      }
    }
  }

  /**
   * Initialize token chart in modal
   * @param {string} mint - Token mint address
   */
  async function initTokenChart(mint) {
    console.log("[TokenChart] Initializing chart for mint:", mint);

    // Destroy existing chart if any
    if (tokenChartManager) {
      tokenChartManager.destroy();
      tokenChartManager = null;
    }

    // CRITICAL FIX: Validate token has OHLCV data before attempting to load
    const tokenData = tokenModalData?.token || getTokenByMint(mint);
    if (!tokenData?.has_ohlcv) {
      console.warn("[TokenChart] Token does not have OHLCV data available:", {
        mint,
        has_ohlcv: tokenData?.has_ohlcv,
        tokenData: tokenData,
      });
      showChartError("üìä OHLCV data not available for this token");
      return;
    }

    console.log(
      "[TokenChart] Token has OHLCV data, proceeding with initialization"
    );

    // Get current theme
    const currentTheme =
      document.documentElement.getAttribute("data-theme") || "dark";

    try {
      // Create chart manager
      tokenChartManager = new ChartManager("token-chart", {
        theme: currentTheme,
        height: 500,
        responsive: true,
        showVolume: document.getElementById("show-volume")?.checked !== false,
        indicators: [],
      });

      // Load token data with default timeframe
      const activeTimeframe =
        document.querySelector(".tf-btn.active")?.dataset.tf || "5m";
      await tokenChartManager.loadToken(mint, activeTimeframe);

      // Setup timeframe buttons
      setupTimeframeButtons();

      // Setup indicator toggles
      setupIndicatorToggles();

      console.log("[TokenChart] Chart initialized successfully");
    } catch (error) {
      console.error("[TokenChart] Initialization error:", error);
      showChartError(`Failed to load chart: ${error.message}`);
    }
  }

  /**
   * Setup timeframe button handlers
   */
  function setupTimeframeButtons() {
    const tfButtons = document.querySelectorAll(".tf-btn");
    tfButtons.forEach((btn) => {
      if (btn.dataset.chartBound === "1") {
        return;
      }
      btn.dataset.chartBound = "1";
      btn.addEventListener("click", async (e) => {
        if (!tokenChartManager) {
          return;
        }

        const timeframe = e.currentTarget.dataset.tf;
        if (!timeframe) {
          return;
        }

        const state = tokenChartManager.getState?.();
        if (state?.loading || state?.timeframe === timeframe) {
          return;
        }

        document.querySelectorAll(".tf-btn").forEach((b) => {
          b.classList.toggle("active", b.dataset.tf === timeframe);
        });

        await tokenChartManager.setTimeframe(timeframe);
      });
    });
  }

  /**
   * Setup indicator toggle handlers
   */
  function setupIndicatorToggles() {
    const volumeToggle = document.getElementById("show-volume");
    const ma20Toggle = document.getElementById("show-ma20");
    const ma50Toggle = document.getElementById("show-ma50");

    const managerState = tokenChartManager?.getState?.();
    const overlayPrefMap = managerState
      ? new Map(managerState.overlayPreferences || [])
      : null;
    const indicatorKeys = managerState
      ? new Set((managerState.indicators || []).map(([key]) => String(key)))
      : null;

    if (managerState && volumeToggle) {
      const overlayPref = overlayPrefMap?.has("volume")
        ? overlayPrefMap.get("volume")
        : managerState.overlays?.includes?.("volume");
      volumeToggle.checked =
        overlayPref === undefined ? true : Boolean(overlayPref);
    }

    if (indicatorKeys && ma20Toggle) {
      ma20Toggle.checked = indicatorKeys.has("indicator:SMA:20");
    }

    if (indicatorKeys && ma50Toggle) {
      ma50Toggle.checked = indicatorKeys.has("indicator:SMA:50");
    }

    if (volumeToggle && volumeToggle.dataset.chartBound !== "1") {
      volumeToggle.dataset.chartBound = "1";
      volumeToggle.addEventListener("change", () => {
        if (!tokenChartManager) {
          return;
        }

        const state = tokenChartManager.getState?.();
        if (state?.loading) {
          const stateOverlayPref = state.overlayPreferences
            ? new Map(state.overlayPreferences)
            : null;
          const previousValue = stateOverlayPref?.has("volume")
            ? stateOverlayPref.get("volume")
            : state.overlays?.includes?.("volume");
          volumeToggle.checked =
            previousValue === undefined
              ? volumeToggle.checked
              : Boolean(previousValue);
          return;
        }

        tokenChartManager.toggleOverlay("volume");
      });
    }

    if (ma20Toggle && ma20Toggle.dataset.chartBound !== "1") {
      ma20Toggle.dataset.chartBound = "1";
      ma20Toggle.addEventListener("change", async (e) => {
        if (!tokenChartManager) {
          return;
        }

        const state = tokenChartManager.getState?.();
        if (state?.loading) {
          const stateIndicatorKeys = state?.indicators
            ? new Set(state.indicators.map(([key]) => String(key)))
            : null;
          if (stateIndicatorKeys) {
            ma20Toggle.checked = stateIndicatorKeys.has("indicator:SMA:20");
          }
          return;
        }

        if (e.target.checked) {
          await tokenChartManager.addIndicator("SMA", {
            period: 20,
            color: "#2196F3",
          });
        } else {
          tokenChartManager.removeIndicator("indicator:SMA:20");
        }
      });
    }

    if (ma50Toggle && ma50Toggle.dataset.chartBound !== "1") {
      ma50Toggle.dataset.chartBound = "1";
      ma50Toggle.addEventListener("change", async (e) => {
        if (!tokenChartManager) {
          return;
        }

        const state = tokenChartManager.getState?.();
        if (state?.loading) {
          const stateIndicatorKeys = state?.indicators
            ? new Set(state.indicators.map(([key]) => String(key)))
            : null;
          if (stateIndicatorKeys) {
            ma50Toggle.checked = stateIndicatorKeys.has("indicator:SMA:50");
          }
          return;
        }

        if (e.target.checked) {
          await tokenChartManager.addIndicator("SMA", {
            period: 50,
            color: "#FF9800",
          });
        } else {
          tokenChartManager.removeIndicator("indicator:SMA:50");
        }
      });
    }
  }

  /**
   * Retry chart load (called from error button)
   */
  function retryChartLoad() {
    if (currentModalMint) {
      initTokenChart(currentModalMint);
    }
  }

  /**
   * Update chart theme when dashboard theme changes
   */
  function updateChartTheme(theme) {
    if (tokenChartManager) {
      tokenChartManager.setTheme(theme);
    }
  }

  // Listen for theme changes
  if (window.ThemeManager) {
    const originalSetTheme = window.ThemeManager.setTheme;
    window.ThemeManager.setTheme = function (theme) {
      originalSetTheme.call(window.ThemeManager, theme);
      updateChartTheme(theme);
    };
  }

  // Make retryChartLoad globally accessible
  window.retryChartLoad = retryChartLoad;

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initTokensPage();
</script>
