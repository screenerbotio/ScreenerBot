<style>
  .pnl-positive {
    color: #10b981;
    font-weight: 600;
  }

  .pnl-negative {
    color: #ef4444;
    font-weight: 600;
  }

  .pnl-neutral {
    color: #6b7280;
  }

  .status-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: 600;
    display: inline-block;
  }

  .status-open {
    background: #10b98120;
    color: #10b981;
  }

  .status-closed {
    background: #64748b20;
    color: #64748b;
  }

  .status-synthetic {
    background: #f59e0b20;
    color: #f59e0b;
  }

  .position-row {
    cursor: pointer;
    transition: background-color 0.25s ease;
  }

  .position-row:hover {
    background-color: rgba(59, 130, 246, 0.08);
  }

  .position-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.72);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 24px;
    z-index: 900;
  }

  .position-modal-overlay.active {
    display: flex;
  }

  .position-modal {
    width: min(960px, 95vw);
    max-height: 90vh;
    background: var(--bg-primary);
    border-radius: 16px;
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .position-modal-header {
    padding: 20px 24px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
  }

  .position-modal-header-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .position-modal-header h2 {
    margin: 0;
    font-size: 1.25rem;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .position-modal-body {
    padding: 20px 24px 28px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }

  .position-section {
    background: var(--bg-secondary);
    border-radius: 12px;
    padding: 16px 18px;
    border: 1px solid rgba(148, 163, 184, 0.16);
  }

  .position-section h3 {
    margin: 0 0 12px 0;
    font-size: 1rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .position-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px 18px;
  }

  .position-metric {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .position-metric-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-muted);
  }

  .position-metric-value {
    font-size: 1rem;
    font-weight: 600;
  }

  .position-modal-close {
    background: transparent;
    border: none;
    color: var(--text-muted);
    font-size: 1.75rem;
    cursor: pointer;
    line-height: 1;
  }

  .position-modal-header .status-badge {
    font-size: 0.75rem;
  }

  .position-modal-content.hidden {
    display: none;
  }

  .position-modal-loading {
    display: none;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--text-secondary);
    font-size: 0.95rem;
    padding: 24px 0;
  }

  .position-modal-loading.active {
    display: flex;
  }

  .position-modal-spinner {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 3px solid rgba(148, 163, 184, 0.35);
    border-top-color: #3b82f6;
    animation: position-modal-spin 0.8s linear infinite;
  }

  @keyframes position-modal-spin {
    to {
      transform: rotate(360deg);
    }
  }

  .position-modal-error {
    display: none;
    padding: 14px 16px;
    border-radius: 10px;
    background: rgba(239, 68, 68, 0.12);
    border: 1px solid rgba(239, 68, 68, 0.3);
    color: #f87171;
    font-size: 0.95rem;
  }

  .position-modal-error.active {
    display: block;
  }

  .position-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px 18px;
  }

  .position-table-container {
    overflow-x: auto;
    border-radius: 10px;
    border: 1px solid rgba(148, 163, 184, 0.12);
  }

  .position-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
    background: var(--bg-primary);
  }

  .position-table thead {
    background: rgba(148, 163, 184, 0.1);
  }

  .position-table th,
  .position-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(148, 163, 184, 0.12);
    text-align: left;
    white-space: nowrap;
  }

  .position-table th {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-muted);
    font-weight: 600;
  }

  .position-table td {
    color: var(--text-primary);
  }

  .position-table tbody tr:hover {
    background: rgba(59, 130, 246, 0.08);
  }

  .position-signature-cell {
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: "SFMono-Regular", ui-monospace, SFMono, Menlo, Monaco, Consolas,
      "Liberation Mono", "Courier New", monospace;
    font-size: 0.78rem;
  }

  .position-signature-button {
    border: none;
    background: rgba(59, 130, 246, 0.14);
    color: #60a5fa;
    padding: 4px 6px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.7rem;
    transition: background-color 0.2s ease;
  }

  .position-signature-button:hover {
    background: rgba(59, 130, 246, 0.25);
  }

  .position-timeline {
    list-style: none;
    margin: 0;
    padding: 0;
    display: grid;
    gap: 12px;
  }

  .position-timeline-item {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    border: 1px solid rgba(148, 163, 184, 0.12);
    border-radius: 10px;
    padding: 10px 12px;
    background: rgba(148, 163, 184, 0.06);
  }

  .position-timeline-item strong {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-secondary);
  }

  .position-timeline-meta {
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 160px;
    text-align: right;
    color: var(--text-muted);
    font-size: 0.8rem;
  }

  .position-empty {
    padding: 14px;
    text-align: center;
    color: var(--text-muted);
    font-size: 0.9rem;
  }

  @media (max-width: 720px) {
    .position-modal-body {
      padding: 18px;
      gap: 14px;
    }

    .position-modal-header {
      padding: 18px;
    }

    .position-modal {
      width: 100%;
      max-height: 92vh;
    }
  }
</style>
<div class="page-table">
  <div class="toolbar">
    <span style="font-weight: 600">üí∞ Positions</span>
    <select
      id="statusFilter"
      onchange="onPositionsStatusChanged()"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="all">All</option>
      <option value="open" selected>Open</option>
      <option value="closed">Closed</option>
    </select>
    <input
      type="text"
      id="searchInput"
      placeholder="Search symbol, name, or mint"
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <div class="spacer"></div>
    <span
      id="positionCount"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button onclick="refreshPositions()" class="btn btn-primary">
      üîÑ Refresh
    </button>
  </div>
  <div class="table-wrap">
    <table class="table" id="positionsTable">
      <thead>
        <tr>
          <th style="min-width: 80px">Status</th>
          <th style="min-width: 100px">Symbol</th>
          <th style="min-width: 150px">Name</th>
          <th style="min-width: 120px">Entry Price</th>
          <th style="min-width: 120px">Current/Exit</th>
          <th style="min-width: 100px">Size (SOL)</th>
          <th style="min-width: 120px">P&L</th>
          <th style="min-width: 120px">P&L %</th>
          <th style="min-width: 150px">Entry Time</th>
          <th style="min-width: 100px">Actions</th>
        </tr>
      </thead>
      <tbody id="positionsTableBody">
        <tr>
          <td
            colspan="10"
            style="text-align: center; padding: 20px; color: #64748b"
          >
            Loading positions...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div
  class="position-modal-overlay"
  id="positionModal"
  onclick="closePositionModal(event)"
>
  <div
    class="position-modal"
    role="dialog"
    aria-modal="true"
    aria-labelledby="positionModalTitle"
    onclick="event.stopPropagation()"
  >
    <div class="position-modal-header">
      <h2 id="positionModalTitle">
        <span id="positionModalSymbol">‚Äî</span>
        <span
          id="positionModalName"
          style="font-size: 0.85rem; color: var(--text-secondary)"
        >
          ‚Äî
        </span>
      </h2>
      <div class="position-modal-header-right">
        <span class="status-badge" id="positionModalStatus">OPEN</span>
        <button
          class="position-modal-close"
          type="button"
          aria-label="Close"
          onclick="closePositionModal()"
        >
          √ó
        </button>
      </div>
    </div>
    <div class="position-modal-body">
      <div class="position-modal-loading" id="positionModalLoading">
        <div class="position-modal-spinner"></div>
        <span id="positionModalLoadingText">Loading position details...</span>
      </div>
      <div class="position-modal-error" id="positionModalError"></div>
      <div class="position-modal-content hidden" id="positionModalContent">
        <div class="position-section">
          <h3>Overview</h3>
          <div class="position-info-grid">
            <div class="position-metric">
              <span class="position-metric-label">Mint</span>
              <span class="position-metric-value" id="positionMint">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Position Id</span>
              <span class="position-metric-value" id="positionId">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">State</span>
              <span class="position-metric-value" id="positionState">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Position Type</span>
              <span class="position-metric-value" id="positionPositionType"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Liquidity Tier</span>
              <span class="position-metric-value" id="positionLiquidityTier"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Profit Targets</span>
              <span class="position-metric-value" id="positionProfitTargets"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Phantom</span>
              <span class="position-metric-value" id="positionPhantom">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Phantom First Seen</span>
              <span class="position-metric-value" id="positionPhantomFirstSeen"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Synthetic Exit</span>
              <span class="position-metric-value" id="positionSynthetic"
                >‚Äî</span
              >
            </div>
          </div>
        </div>

        <div class="position-section">
          <h3>Performance</h3>
          <div class="position-info-grid">
            <div class="position-metric">
              <span class="position-metric-label">Entry Price (SOL)</span>
              <span class="position-metric-value" id="positionEntryPrice"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Effective Entry Price</span>
              <span
                class="position-metric-value"
                id="positionEffectiveEntryPrice"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Entry Size (SOL)</span>
              <span class="position-metric-value" id="positionEntrySize"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Total Size (SOL)</span>
              <span class="position-metric-value" id="positionTotalSize"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Price High</span>
              <span class="position-metric-value" id="positionPriceHigh"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Price Low</span>
              <span class="position-metric-value" id="positionPriceLow">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Current Price (SOL)</span>
              <span class="position-metric-value" id="positionCurrentPrice"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Updated</span>
              <span class="position-metric-value" id="positionCurrentUpdated"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Unrealized P&L</span>
              <span class="position-metric-value" id="positionUnrealizedPnl"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Unrealized P&L %</span>
              <span class="position-metric-value" id="positionUnrealizedPercent"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Realized P&L</span>
              <span class="position-metric-value" id="positionRealizedPnl"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Realized P&L %</span>
              <span class="position-metric-value" id="positionRealizedPercent"
                >‚Äî</span
              >
            </div>
          </div>
        </div>

        <div class="position-section">
          <h3>Entry Details</h3>
          <div class="position-info-grid">
            <div class="position-metric">
              <span class="position-metric-label">Entry Timestamp</span>
              <span class="position-metric-value" id="positionEntryTime"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Entry Signature</span>
              <span class="position-metric-value" id="positionEntrySig">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Entry Verified</span>
              <span class="position-metric-value" id="positionEntryVerified"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Entry Fee</span>
              <span class="position-metric-value" id="positionEntryFee">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Token Amount</span>
              <span class="position-metric-value" id="positionTokenAmount"
                >‚Äî</span
              >
            </div>
          </div>
        </div>

        <div class="position-section" id="positionExitSection">
          <h3>Exit Details</h3>
          <div class="position-info-grid">
            <div class="position-metric">
              <span class="position-metric-label">Exit Price (SOL)</span>
              <span class="position-metric-value" id="positionExitPrice"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Effective Exit Price</span>
              <span
                class="position-metric-value"
                id="positionEffectiveExitPrice"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">SOL Received</span>
              <span class="position-metric-value" id="positionSolReceived"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Exit Timestamp</span>
              <span class="position-metric-value" id="positionExitTime">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Exit Signature</span>
              <span class="position-metric-value" id="positionExitSig">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Exit Verified</span>
              <span class="position-metric-value" id="positionExitVerified"
                >‚Äî</span
              >
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Exit Fee</span>
              <span class="position-metric-value" id="positionExitFee">‚Äî</span>
            </div>
            <div class="position-metric">
              <span class="position-metric-label">Closed Reason</span>
              <span class="position-metric-value" id="positionClosedReason"
                >‚Äî</span
              >
            </div>
          </div>
        </div>

        <div class="position-section" id="positionCurrentSection">
          <h3>Executions</h3>
          <div class="position-table-container">
            <table class="position-table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Timestamp</th>
                  <th>Price (SOL)</th>
                  <th>Effective (SOL)</th>
                  <th>Size (SOL)</th>
                  <th>SOL Œî</th>
                  <th>Tokens</th>
                  <th>Fee (SOL)</th>
                  <th>Verified</th>
                  <th>Signature</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody id="positionExecutionsBody">
                <tr>
                  <td colspan="11" class="position-empty">No execution data</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="position-section">
          <h3>Transactions</h3>
          <div class="position-table-container">
            <table class="position-table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Status</th>
                  <th>Success</th>
                  <th>Timestamp</th>
                  <th>Slot</th>
                  <th>Fee (SOL)</th>
                  <th>Direction</th>
                  <th>Router</th>
                  <th>SOL Œî</th>
                  <th>Signature</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody id="positionTransactionsBody">
                <tr>
                  <td colspan="11" class="position-empty">
                    No transaction data
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="position-section">
          <h3>Lifecycle</h3>
          <ul class="position-timeline" id="positionStateTimeline">
            <li class="position-empty">No state history recorded</li>
          </ul>
        </div>

        <div class="position-section">
          <h3>Links</h3>
          <div class="position-grid" style="gap: 10px 12px">
            <button
              class="btn btn-secondary"
              type="button"
              onclick="copyPositionMint()"
            >
              üìã Copy Mint
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              onclick="openPositionTokenDetail()"
            >
              üîé Token Detail
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              onclick="openPositionGMGN()"
            >
              üîó Open GMGN
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              onclick="openPositionDexScreener()"
            >
              üìä Open DexScreener
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              onclick="openPositionSolscan()"
            >
              üîç Open Solscan
            </button>
            <button
              class="btn btn-secondary"
              type="button"
              onclick="copyPositionDebug()"
            >
              üêõ Copy Debug Info
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var positionsStore =
    window.positionsStore instanceof Map ? window.positionsStore : new Map();
  window.positionsStore = positionsStore;

  var POSITION_MODAL_REFETCH_INTERVAL_MS = 15000;

  var positionModalState = window.positionModalState || {
    currentKey: null,
    keydownHandler: null,
    detail: null,
    detailKey: null,
    abortController: null,
    lastFetchedAt: 0,
  };
  window.positionModalState = positionModalState;

  var POSITION_MODAL_FIELD_IDS = [
    "positionMint",
    "positionId",
    "positionState",
    "positionPositionType",
    "positionLiquidityTier",
    "positionProfitTargets",
    "positionPhantom",
    "positionPhantomFirstSeen",
    "positionSynthetic",
    "positionEntryPrice",
    "positionEffectiveEntryPrice",
    "positionEntrySize",
    "positionTotalSize",
    "positionPriceHigh",
    "positionPriceLow",
    "positionCurrentPrice",
    "positionCurrentUpdated",
    "positionEntryTime",
    "positionEntrySig",
    "positionEntryVerified",
    "positionEntryFee",
    "positionTokenAmount",
    "positionExitPrice",
    "positionEffectiveExitPrice",
    "positionSolReceived",
    "positionExitTime",
    "positionExitSig",
    "positionExitVerified",
    "positionExitFee",
    "positionClosedReason",
    "positionModalSymbol",
    "positionModalName",
  ];

  function getPositionFromStore(key) {
    if (!key) {
      return null;
    }
    try {
      return positionsStore.get(key) || null;
    } catch (_) {
      return null;
    }
  }

  function setPositionModalText(id, value) {
    const el = document.getElementById(id);
    if (!el) return;
    if (value === undefined || value === null) {
      el.textContent = "‚Äî";
      return;
    }
    el.textContent = String(value);
  }

  function escapeHtml(value) {
    if (value === null || value === undefined) return "";
    return String(value)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function formatPositionTimestamp(value) {
    if (typeof Utils !== "undefined" && Utils?.formatTimeFromSeconds) {
      return Utils.formatTimeFromSeconds(value, { fallback: "‚Äî" });
    }
    if (!Number.isFinite(value)) return "‚Äî";
    const date = new Date(value * 1000);
    if (Number.isNaN(date.getTime())) {
      return "‚Äî";
    }
    return date.toLocaleString();
  }

  function formatPositionPrice(value) {
    if (value === null || value === undefined) {
      return "‚Äî";
    }
    if (typeof Utils !== "undefined" && Utils?.formatPriceSol) {
      return Utils.formatPriceSol(value, { fallback: "‚Äî" });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    return num.toFixed(12);
  }

  function formatPositionSol(value, { decimals = 4, fallback = "‚Äî" } = {}) {
    if (value === null || value === undefined) {
      return fallback;
    }
    if (typeof Utils !== "undefined" && Utils?.formatSol) {
      return Utils.formatSol(value, { decimals, fallback });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return `${num.toFixed(decimals)} SOL`;
  }

  function formatPositionSolDelta(value) {
    if (value === null || value === undefined) return "‚Äî";
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    const formatted = formatPositionSol(Math.abs(num));
    if (formatted === "‚Äî") return formatted;
    if (num > 0) return `+${formatted}`;
    if (num < 0) return `-${formatted}`;
    return formatted;
  }

  function formatPercentPlain(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    const magnitude = Math.abs(num).toFixed(2);
    if (num > 0) return `+${magnitude}%`;
    if (num < 0) return `-${magnitude}%`;
    return `${magnitude}%`;
  }

  function formatBooleanFlag(value) {
    if (typeof Utils !== "undefined" && Utils?.formatBooleanFlag) {
      return Utils.formatBooleanFlag(value, "‚Äî");
    }
    if (value === true) return "Yes";
    if (value === false) return "No";
    return "‚Äî";
  }

  function formatTokenAmount(value) {
    if (value === null || value === undefined) return "‚Äî";
    const num = Number(value);
    if (!Number.isFinite(num)) return String(value);
    if (typeof Utils !== "undefined" && Utils?.formatNumber) {
      return Utils.formatNumber(num, {
        decimals: 0,
        fallback: "‚Äî",
        useGrouping: true,
      });
    }
    return num.toLocaleString();
  }

  function lamportsToSolNumber(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    return num / 1_000_000_000;
  }

  function formatLamportsToSol(value) {
    const sol = lamportsToSolNumber(value);
    if (sol === null) return "‚Äî";
    return formatPositionSol(sol, { decimals: 6, fallback: "‚Äî" });
  }

  function formatProfitTargets(min, max) {
    const hasMin = Number.isFinite(Number(min));
    const hasMax = Number.isFinite(Number(max));
    if (!hasMin && !hasMax) {
      return "‚Äî";
    }
    const minText = hasMin ? formatPercentPlain(min) : "‚Äî";
    const maxText = hasMax ? formatPercentPlain(max) : "‚Äî";
    return `${minText} / ${maxText}`;
  }

  function setPositionModalPnl(id, value, { decimals = 4 } = {}) {
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.remove("pnl-positive", "pnl-negative", "pnl-neutral");
    if (value === null || value === undefined) {
      el.textContent = "‚Äî";
      el.classList.add("pnl-neutral");
      return;
    }

    const num = Number(value);
    if (!Number.isFinite(num)) {
      el.textContent = "‚Äî";
      el.classList.add("pnl-neutral");
      return;
    }

    const sign = num > 0 ? "+" : num < 0 ? "-" : "";
    const magnitude = Math.abs(num).toFixed(decimals);
    el.textContent = `${sign}${magnitude} SOL`;

    if (num > 0) {
      el.classList.add("pnl-positive");
    } else if (num < 0) {
      el.classList.add("pnl-negative");
    } else {
      el.classList.add("pnl-neutral");
    }
  }

  function setPositionModalPercent(id, value, { decimals = 2 } = {}) {
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.remove("pnl-positive", "pnl-negative", "pnl-neutral");
    if (value === null || value === undefined) {
      el.textContent = "‚Äî";
      el.classList.add("pnl-neutral");
      return;
    }

    const num = Number(value);
    if (!Number.isFinite(num)) {
      el.textContent = "‚Äî";
      el.classList.add("pnl-neutral");
      return;
    }

    const sign = num > 0 ? "+" : num < 0 ? "-" : "";
    const magnitude = Math.abs(num).toFixed(decimals);
    el.textContent = `${sign}${magnitude}%`;

    if (num > 0) {
      el.classList.add("pnl-positive");
    } else if (num < 0) {
      el.classList.add("pnl-negative");
    } else {
      el.classList.add("pnl-neutral");
    }
  }

  function getPositionStatusInfo(position) {
    if (!position) {
      return {
        label: "Unknown",
        className: "status-closed",
        state: "Unknown",
      };
    }
    if (position.synthetic_exit) {
      return {
        label: "Synthetic",
        className: "status-synthetic",
        state: "Synthetic Exit",
      };
    }
    if (position.transaction_exit_verified) {
      return {
        label: "Closed",
        className: "status-closed",
        state: "Closed",
      };
    }
    return {
      label: "Open",
      className: "status-open",
      state: "Open",
    };
  }

  function applyStatusBadge(element, info) {
    if (!element || !info) return;
    element.classList.remove(
      "status-open",
      "status-closed",
      "status-synthetic"
    );
    element.classList.add(info.className);
    element.textContent = info.label.toUpperCase();
  }

  function setPositionModalLoading(text) {
    const loading = document.getElementById("positionModalLoading");
    const content = document.getElementById("positionModalContent");
    const error = document.getElementById("positionModalError");
    if (loading) {
      loading.classList.add("active");
      const textEl = document.getElementById("positionModalLoadingText");
      if (textEl) {
        textEl.textContent = text || "Loading position details...";
      }
    }
    if (content) {
      content.classList.add("hidden");
    }
    if (error) {
      error.classList.remove("active");
      error.textContent = "";
    }
  }

  function clearPositionModalError() {
    const error = document.getElementById("positionModalError");
    if (error) {
      error.classList.remove("active");
      error.textContent = "";
    }
  }

  function setPositionModalError(message) {
    const loading = document.getElementById("positionModalLoading");
    const content = document.getElementById("positionModalContent");
    const error = document.getElementById("positionModalError");
    if (loading) {
      loading.classList.remove("active");
    }
    if (content) {
      content.classList.add("hidden");
    }
    if (error) {
      error.textContent = message || "Failed to load position details";
      error.classList.add("active");
    }
  }

  function showPositionModalContent() {
    const loading = document.getElementById("positionModalLoading");
    const content = document.getElementById("positionModalContent");
    if (loading) {
      loading.classList.remove("active");
    }
    if (content) {
      content.classList.remove("hidden");
    }
  }

  function renderPositionModal(detail) {
    if (!detail || !detail.position) {
      setPositionModalError("Position detail unavailable");
      return;
    }

    const position = detail.position;
    clearPositionModalError();
    showPositionModalContent();

    setPositionModalText("positionModalSymbol", position.symbol || "‚Äî");
    setPositionModalText("positionModalName", position.name || "‚Äî");
    setPositionModalText("positionMint", position.mint || "‚Äî");
    setPositionModalText(
      "positionId",
      position.id !== undefined && position.id !== null
        ? String(position.id)
        : "‚Äî"
    );

    const statusInfo = getPositionStatusInfo(position);
    const statusEl = document.getElementById("positionModalStatus");
    applyStatusBadge(statusEl, statusInfo);
    setPositionModalText("positionState", statusInfo.state);

    setPositionModalText(
      "positionPositionType",
      position.position_type ? position.position_type.toUpperCase() : "‚Äî"
    );
    setPositionModalText(
      "positionLiquidityTier",
      position.liquidity_tier || "‚Äî"
    );
    setPositionModalText(
      "positionProfitTargets",
      formatProfitTargets(
        position.profit_target_min,
        position.profit_target_max
      )
    );

    const phantomLabel = position.phantom_remove ? "Remove flagged" : "No";
    const phantomConfirmations = Number(position.phantom_confirmations) || 0;
    setPositionModalText(
      "positionPhantom",
      `${phantomLabel} (${phantomConfirmations} confirmations)`
    );
    setPositionModalText(
      "positionPhantomFirstSeen",
      formatPositionTimestamp(position.phantom_first_seen)
    );
    setPositionModalText(
      "positionSynthetic",
      formatBooleanFlag(position.synthetic_exit)
    );

    setPositionModalText(
      "positionEntryPrice",
      formatPositionPrice(
        position.effective_entry_price || position.entry_price
      )
    );
    setPositionModalText(
      "positionEffectiveEntryPrice",
      formatPositionPrice(position.effective_entry_price)
    );
    setPositionModalText(
      "positionEntrySize",
      formatPositionSol(position.entry_size_sol)
    );
    setPositionModalText(
      "positionTotalSize",
      formatPositionSol(position.total_size_sol)
    );
    setPositionModalText(
      "positionPriceHigh",
      formatPositionPrice(position.price_highest)
    );
    setPositionModalText(
      "positionPriceLow",
      formatPositionPrice(position.price_lowest)
    );
    setPositionModalText(
      "positionCurrentPrice",
      formatPositionPrice(position.current_price)
    );
    setPositionModalText(
      "positionCurrentUpdated",
      formatPositionTimestamp(position.current_price_updated)
    );
    setPositionModalPnl("positionUnrealizedPnl", position.unrealized_pnl);
    setPositionModalPercent(
      "positionUnrealizedPercent",
      position.unrealized_pnl_percent
    );
    setPositionModalPnl("positionRealizedPnl", position.pnl);
    setPositionModalPercent("positionRealizedPercent", position.pnl_percent);

    setPositionModalText(
      "positionEntryTime",
      formatPositionTimestamp(position.entry_time)
    );
    setPositionModalText(
      "positionEntrySig",
      position.entry_transaction_signature
        ? truncateAddress(position.entry_transaction_signature)
        : "‚Äî"
    );
    setPositionModalText(
      "positionEntryVerified",
      formatBooleanFlag(position.transaction_entry_verified)
    );
    setPositionModalText(
      "positionEntryFee",
      formatLamportsToSol(position.entry_fee_lamports)
    );
    setPositionModalText(
      "positionTokenAmount",
      formatTokenAmount(position.token_amount)
    );

    setPositionModalText(
      "positionExitPrice",
      formatPositionPrice(position.exit_price)
    );
    setPositionModalText(
      "positionEffectiveExitPrice",
      formatPositionPrice(position.effective_exit_price)
    );
    setPositionModalText(
      "positionSolReceived",
      formatPositionSol(position.sol_received)
    );
    setPositionModalText(
      "positionExitTime",
      formatPositionTimestamp(position.exit_time)
    );
    setPositionModalText(
      "positionExitSig",
      position.exit_transaction_signature
        ? truncateAddress(position.exit_transaction_signature)
        : "‚Äî"
    );
    setPositionModalText(
      "positionExitVerified",
      formatBooleanFlag(position.transaction_exit_verified)
    );
    setPositionModalText(
      "positionExitFee",
      formatLamportsToSol(position.exit_fee_lamports)
    );
    setPositionModalText("positionClosedReason", position.closed_reason || "‚Äî");

    const exitSection = document.getElementById("positionExitSection");
    if (exitSection) {
      const shouldShowExit =
        position.transaction_exit_verified ||
        position.synthetic_exit ||
        position.exit_time !== null;
      exitSection.style.display = shouldShowExit ? "block" : "none";
    }

    renderPositionExecutions(
      Array.isArray(detail.executions) ? detail.executions : []
    );
    renderPositionTransactions(
      Array.isArray(detail.transactions) ? detail.transactions : []
    );
    renderPositionTimeline(
      Array.isArray(detail.state_history) ? detail.state_history : []
    );
  }

  function resetPositionModal() {
    POSITION_MODAL_FIELD_IDS.forEach((id) => setPositionModalText(id, "‚Äî"));
    setPositionModalPnl("positionUnrealizedPnl", null);
    setPositionModalPercent("positionUnrealizedPercent", null);
    setPositionModalPnl("positionRealizedPnl", null);
    setPositionModalPercent("positionRealizedPercent", null);
    renderPositionExecutions([]);
    renderPositionTransactions([]);
    renderPositionTimeline([]);
    const loading = document.getElementById("positionModalLoading");
    const content = document.getElementById("positionModalContent");
    if (loading) loading.classList.remove("active");
    if (content) content.classList.add("hidden");
    clearPositionModalError();
    const statusEl = document.getElementById("positionModalStatus");
    if (statusEl) {
      applyStatusBadge(statusEl, {
        label: "Open",
        className: "status-open",
        state: "Open",
      });
    }
  }

  function handlePositionModalKeyDown(event) {
    if (event.key === "Escape") {
      closePositionModal();
    }
  }

  function ensurePositionModalKeyListener() {
    if (positionModalState.keydownHandler) {
      return;
    }
    positionModalState.keydownHandler = handlePositionModalKeyDown;
    document.addEventListener("keydown", positionModalState.keydownHandler);
  }

  function removePositionModalKeyListener() {
    if (!positionModalState.keydownHandler) {
      return;
    }
    document.removeEventListener("keydown", positionModalState.keydownHandler);
    positionModalState.keydownHandler = null;
  }

  function getActiveDetail() {
    return positionModalState.detail || null;
  }

  async function openPositionDetail(key) {
    if (!key) return;
    positionModalState.currentKey = key;

    const overlay = document.getElementById("positionModal");
    if (overlay) {
      overlay.classList.add("active");
    }
    ensurePositionModalKeyListener();

    const cachedDetail =
      positionModalState.detailKey === key ? getActiveDetail() : null;
    if (cachedDetail && cachedDetail.position) {
      renderPositionModal(cachedDetail);
    } else {
      setPositionModalLoading("Loading position details...");
    }

    try {
      await loadPositionDetail(key, { silent: !!cachedDetail });
    } catch (err) {
      console.error("Failed to load position detail:", err);
      if (!cachedDetail) {
        setPositionModalError("Failed to load position details");
      }
    }
  }

  function getCurrentPosition() {
    return getPositionFromStore(positionModalState.currentKey);
  }

  function closePositionModal(event) {
    if (event && event.target && event.currentTarget) {
      if (event.target !== event.currentTarget && event.type === "click") {
        return;
      }
    }
    if (positionModalState.abortController) {
      positionModalState.abortController.abort();
      positionModalState.abortController = null;
    }
    const overlay = document.getElementById("positionModal");
    if (overlay) {
      overlay.classList.remove("active");
    }
    positionModalState.currentKey = null;
    positionModalState.detail = null;
    positionModalState.detailKey = null;
    positionModalState.lastFetchedAt = 0;
    removePositionModalKeyListener();
    resetPositionModal();
  }

  async function loadPositionDetail(key, { silent = false } = {}) {
    if (!key) return;

    if (positionModalState.abortController) {
      positionModalState.abortController.abort();
    }

    const controller = new AbortController();
    positionModalState.abortController = controller;

    if (!silent) {
      setPositionModalLoading("Loading position details...");
    }

    try {
      const response = await fetch(
        `/api/positions/${encodeURIComponent(key)}/details`,
        { signal: controller.signal }
      );

      if (!response.ok) {
        throw new Error(`Request failed with status ${response.status}`);
      }

      const detail = await response.json();
      if (controller.signal.aborted) {
        return;
      }

      positionModalState.detail = detail;
      positionModalState.detailKey = key;
      positionModalState.lastFetchedAt = Date.now();
      renderPositionModal(detail);
    } catch (err) {
      if (controller.signal.aborted) {
        return;
      }
      if (!silent) {
        setPositionModalError(err.message || "Failed to load position details");
      } else {
        console.warn("loadPositionDetail (silent) failed:", err);
      }
    } finally {
      if (positionModalState.abortController === controller) {
        positionModalState.abortController = null;
      }
    }
  }

  function mergeDetailWithStore(detailPosition, storePosition, detail) {
    if (!detailPosition || !storePosition) {
      return;
    }

    const passthroughFields = [
      "current_price",
      "current_price_updated",
      "unrealized_pnl",
      "unrealized_pnl_percent",
      "pnl",
      "pnl_percent",
      "exit_price",
      "effective_exit_price",
      "exit_time",
      "sol_received",
      "transaction_exit_verified",
      "synthetic_exit",
      "closed_reason",
      "price_highest",
      "price_lowest",
      "phantom_confirmations",
      "phantom_remove",
      "phantom_first_seen",
    ];

    passthroughFields.forEach((field) => {
      if (Object.prototype.hasOwnProperty.call(storePosition, field)) {
        detailPosition[field] = storePosition[field];
      }
    });

    if (detail && Array.isArray(detail.executions)) {
      detail.executions = detail.executions.map((execution) => {
        if (!execution || typeof execution !== "object") {
          return execution;
        }

        if ((execution.kind || "").toLowerCase() === "entry") {
          const sizeSol =
            detailPosition.entry_size_sol ?? execution.size_sol ?? null;
          const feeSol =
            detailPosition.entry_fee_lamports != null
              ? lamportsToSolNumber(detailPosition.entry_fee_lamports)
              : execution.fee_sol;

          return {
            ...execution,
            timestamp: detailPosition.entry_time ?? execution.timestamp,
            price_sol: detailPosition.entry_price ?? execution.price_sol,
            effective_price_sol:
              detailPosition.effective_entry_price ??
              execution.effective_price_sol,
            size_sol: sizeSol,
            total_size_sol:
              detailPosition.total_size_sol ?? execution.total_size_sol,
            token_amount: detailPosition.token_amount ?? execution.token_amount,
            sol_delta:
              sizeSol != null ? -Math.abs(sizeSol) : execution.sol_delta,
            verified:
              detailPosition.transaction_entry_verified ?? execution.verified,
            fee_lamports:
              detailPosition.entry_fee_lamports ?? execution.fee_lamports,
            fee_sol: feeSol ?? execution.fee_sol,
          };
        }

        if ((execution.kind || "").toLowerCase() === "exit") {
          const feeSol =
            detailPosition.exit_fee_lamports != null
              ? lamportsToSolNumber(detailPosition.exit_fee_lamports)
              : execution.fee_sol;

          return {
            ...execution,
            timestamp: detailPosition.exit_time ?? execution.timestamp,
            price_sol: detailPosition.exit_price ?? execution.price_sol,
            effective_price_sol:
              detailPosition.effective_exit_price ??
              execution.effective_price_sol,
            sol_delta:
              detailPosition.sol_received ?? execution.sol_delta ?? null,
            verified:
              detailPosition.transaction_exit_verified ?? execution.verified,
            fee_lamports:
              detailPosition.exit_fee_lamports ?? execution.fee_lamports,
            fee_sol: feeSol ?? execution.fee_sol,
          };
        }

        return execution;
      });
    }
  }

  function refreshOpenPositionModal() {
    if (!positionModalState.currentKey) {
      return;
    }

    const detail = getActiveDetail();
    const storePosition = getCurrentPosition();

    if (detail && detail.position && storePosition) {
      mergeDetailWithStore(detail.position, storePosition, detail);
      renderPositionModal(detail);
    } else if (!storePosition) {
      closePositionModal();
      return;
    }

    const now = Date.now();
    if (
      now - (positionModalState.lastFetchedAt || 0) >
      POSITION_MODAL_REFETCH_INTERVAL_MS
    ) {
      loadPositionDetail(positionModalState.currentKey, { silent: true }).catch(
        (err) => {
          console.warn("refreshOpenPositionModal fetch failed:", err);
        }
      );
    }
  }

  function renderPositionExecutions(executions) {
    const tbody = document.getElementById("positionExecutionsBody");
    if (!tbody) return;

    if (!Array.isArray(executions) || executions.length === 0) {
      tbody.innerHTML =
        '<tr><td colspan="11" class="position-empty">No execution data</td></tr>';
      return;
    }

    tbody.innerHTML = executions
      .map((execution) => {
        const kind = escapeHtml((execution.kind || "‚Äî").toUpperCase());
        const timestamp = formatPositionTimestamp(execution.timestamp);
        const price = formatPositionPrice(execution.price_sol);
        const effective = formatPositionPrice(execution.effective_price_sol);
        const sizeSol = formatPositionSol(execution.size_sol);
        const totalTokens = formatTokenAmount(execution.token_amount);
        const solDelta = formatPositionSolDelta(execution.sol_delta);
        const feeValue =
          execution.fee_sol ??
          (execution.fee_lamports != null
            ? lamportsToSolNumber(execution.fee_lamports)
            : null);
        const feeSol = formatPositionSol(feeValue, {
          decimals: 6,
          fallback: "‚Äî",
        });
        const verified = execution.verified
          ? '<span class="status-badge status-open">VERIFIED</span>'
          : '<span class="status-badge status-closed">PENDING</span>';
        const signatureCell = renderSignatureCell(execution.signature);
        const notes = execution.notes ? escapeHtml(execution.notes) : "‚Äî";

        return `
          <tr>
            <td>${kind}</td>
            <td>${escapeHtml(timestamp)}</td>
            <td>${escapeHtml(price)}</td>
            <td>${escapeHtml(effective)}</td>
            <td>${escapeHtml(sizeSol)}</td>
            <td>${escapeHtml(solDelta)}</td>
            <td>${escapeHtml(totalTokens)}</td>
            <td>${escapeHtml(feeSol)}</td>
            <td>${verified}</td>
            <td>${signatureCell}</td>
            <td>${notes}</td>
          </tr>
        `;
      })
      .join("");
  }

  function renderPositionTransactions(transactions) {
    const tbody = document.getElementById("positionTransactionsBody");
    if (!tbody) return;

    if (!Array.isArray(transactions) || transactions.length === 0) {
      tbody.innerHTML =
        '<tr><td colspan="11" class="position-empty">No transaction data</td></tr>';
      return;
    }

    tbody.innerHTML = transactions
      .map((tx) => {
        const kind = escapeHtml((tx.kind || "‚Äî").toUpperCase());
        const status = tx.status
          ? escapeHtml(tx.status)
          : tx.available
          ? "‚Äî"
          : "Unavailable";
        const success =
          tx.success === true ? "‚úÖ" : tx.success === false ? "‚ùå" : "‚Äî";
        const timestamp = formatPositionTimestamp(tx.timestamp);
        const slot = tx.slot !== null && tx.slot !== undefined ? tx.slot : "‚Äî";
        const feeValue =
          tx.fee_sol ??
          (tx.fee_lamports != null
            ? lamportsToSolNumber(tx.fee_lamports)
            : null);
        const fee = formatPositionSol(feeValue, {
          decimals: 6,
          fallback: "‚Äî",
        });
        const direction = tx.direction ? escapeHtml(tx.direction) : "‚Äî";
        const router = tx.router ? escapeHtml(tx.router) : "‚Äî";
        const solChange = formatPositionSolDelta(tx.sol_change);
        const signatureCell = renderSignatureCell(tx.signature);
        const notes = tx.notes
          ? escapeHtml(tx.notes)
          : tx.available
          ? "‚Äî"
          : "Transaction data not indexed yet";

        return `
          <tr>
            <td>${kind}</td>
            <td>${status}</td>
            <td>${success}</td>
            <td>${escapeHtml(timestamp)}</td>
            <td>${escapeHtml(slot)}</td>
            <td>${escapeHtml(fee)}</td>
            <td>${direction}</td>
            <td>${router}</td>
            <td>${escapeHtml(solChange)}</td>
            <td>${signatureCell}</td>
            <td>${notes}</td>
          </tr>
        `;
      })
      .join("");
  }

  function renderPositionTimeline(entries) {
    const list = document.getElementById("positionStateTimeline");
    if (!list) return;

    if (!Array.isArray(entries) || entries.length === 0) {
      list.innerHTML =
        '<li class="position-empty">No state history recorded</li>';
      return;
    }

    list.innerHTML = entries
      .map((entry) => {
        const state = escapeHtml(entry.state || "‚Äî");
        const timestamp = formatPositionTimestamp(entry.changed_at);
        const reason = entry.reason ? escapeHtml(entry.reason) : "";
        const reasonMarkup = reason
          ? `<div style="font-size:0.85rem;color:var(--text-secondary);">${reason}</div>`
          : "";

        return `
          <li class="position-timeline-item">
            <div>
              <strong>${state}</strong>
              ${reasonMarkup}
            </div>
            <div class="position-timeline-meta">
              <span>${escapeHtml(timestamp)}</span>
            </div>
          </li>
        `;
      })
      .join("");
  }

  function renderSignatureCell(signature) {
    if (!signature) {
      return "<span>‚Äî</span>";
    }
    const truncated = truncateAddress(signature);
    const escapedSignature = escapeHtml(signature);
    return `
      <span class="position-signature-cell">
        <span title="${escapedSignature}">${escapeHtml(truncated)}</span>
        <button
          class="position-signature-button"
          type="button"
          data-signature="${escapedSignature}"
        >
          Copy
        </button>
      </span>
    `;
  }

  function copyPositionSignature(signature) {
    if (!signature) return;

    let copyPromise = null;
    if (Utils?.copyToClipboard) {
      copyPromise = Utils.copyToClipboard(signature);
    } else if (navigator?.clipboard?.writeText) {
      copyPromise = navigator.clipboard.writeText(signature);
    }

    if (!copyPromise || typeof copyPromise.then !== "function") {
      console.warn("Clipboard copy function not available");
      return;
    }

    copyPromise
      .then(() => {
        Utils?.showToast?.("‚úÖ Signature copied", "success");
      })
      .catch((err) => {
        console.error("copyPositionSignature failed:", err);
        Utils?.showToast?.("‚ùå Failed to copy signature", "error");
      });
  }

  function getActiveMint() {
    const detail = getActiveDetail();
    if (detail?.position?.mint) return detail.position.mint;
    const storePosition = getCurrentPosition();
    return storePosition?.mint || null;
  }

  function copyPositionMint() {
    const mint = getActiveMint();
    if (!mint || !Utils?.copyMint) return;
    Utils.copyMint(mint);
  }

  function openPositionGMGN() {
    const mint = getActiveMint();
    if (!mint || !Utils?.openGMGN) return;
    Utils.openGMGN(mint);
  }

  function openPositionDexScreener() {
    const mint = getActiveMint();
    if (!mint || !Utils?.openDexScreener) return;
    Utils.openDexScreener(mint);
  }

  function openPositionSolscan() {
    const mint = getActiveMint();
    if (!mint || !Utils?.openSolscan) return;
    Utils.openSolscan(mint);
  }

  async function openPositionTokenDetail() {
    const mint = getActiveMint();
    if (!mint) {
      Utils.showToast?.("‚ùå Mint not available", "error");
      return;
    }

    try {
      if (window.Router && typeof Router.loadPage === "function") {
        await Router.loadPage("tokens");
        scheduleTokenModalOpen(mint, 0);
      } else if (typeof window.openTokenModal === "function") {
        await window.openTokenModal(mint);
      } else if (Utils?.openDexScreener) {
        Utils.openDexScreener(mint);
      }
    } catch (err) {
      console.error("openPositionTokenDetail failed:", err);
      Utils.showToast?.("‚ùå Failed to open token details", "error");
    }
  }

  function scheduleTokenModalOpen(mint, attempt) {
    if (typeof window.openTokenModal === "function") {
      window.openTokenModal(mint).catch((err) => {
        console.error("openTokenModal error:", err);
        Utils.showToast?.("‚ùå Failed to open token details", "error");
      });
      return;
    }
    if (attempt >= 20) {
      Utils.showToast?.("‚ùå Token detail module unavailable", "error");
      return;
    }
    setTimeout(() => scheduleTokenModalOpen(mint, attempt + 1), 120);
  }

  function copyPositionDebug() {
    const mint = getActiveMint();
    if (!mint || !Utils?.copyDebugInfo) return;
    Utils.copyDebugInfo(mint, "position");
  }

  function handlePositionDropdown(event) {
    if (event?.stopPropagation) {
      event.stopPropagation();
    }
    if (Utils?.toggleDropdown) {
      Utils.toggleDropdown(event);
    }
  }

  function bindPositionRowClicks() {
    const rows = document.querySelectorAll(
      "#positionsTableBody tr[data-position-key]"
    );
    rows.forEach((row) => {
      if (row.dataset.clickBound === "1") {
        return;
      }
      row.addEventListener("click", (event) => {
        if (
          event?.target?.closest &&
          event.target.closest(".dropdown-container")
        ) {
          return;
        }
        const key = row.getAttribute("data-position-key");
        if (key) {
          openPositionDetail(key);
        }
      });
      row.dataset.clickBound = "1";
    });
  }

  document.addEventListener("click", (event) => {
    const button = event?.target?.closest?.(".position-signature-button");
    if (!button) {
      return;
    }
    const signature = button.getAttribute("data-signature");
    if (signature) {
      copyPositionSignature(signature);
    }
  });

  window.openPositionDetail = openPositionDetail;
  window.closePositionModal = closePositionModal;
  window.copyPositionMint = copyPositionMint;
  window.openPositionGMGN = openPositionGMGN;
  window.openPositionDexScreener = openPositionDexScreener;
  window.openPositionSolscan = openPositionSolscan;
  window.copyPositionDebug = copyPositionDebug;
  window.handlePositionDropdown = handlePositionDropdown;
  window.copyPositionSignature = copyPositionSignature;
  window.openPositionTokenDetail = openPositionTokenDetail;

  // Truncate address
  function truncateAddress(address) {
    if (!address) return "-";
    return (
      address.substring(0, 8) + "..." + address.substring(address.length - 6)
    );
  }

  function getCurrentStatusFilter() {
    const select = document.getElementById("statusFilter");
    return select ? select.value : "all";
  }

  function getSearchTerm() {
    const input = document.getElementById("searchInput");
    return input ? input.value.toLowerCase().trim() : "";
  }

  function isDropdownOpen() {
    return Boolean(document.querySelector(".dropdown-menu.show"));
  }

  function parsePossibleTimestamp(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === "string" && value.trim() !== "") {
      const numeric = Number(value);
      if (Number.isFinite(numeric)) {
        return numeric;
      }

      const parsed = Date.parse(value);
      if (Number.isFinite(parsed)) {
        return Math.floor(parsed / 1000);
      }
    }
    return null;
  }

  function toFiniteNumber(value) {
    try {
      if (
        typeof Utils !== "undefined" &&
        Utils &&
        typeof Utils.coerceNumber === "function"
      ) {
        const coerced = Utils.coerceNumber(value);
        return Number.isFinite(coerced) ? coerced : null;
      }
    } catch (_) {}

    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function computeDerivedMetrics(position) {
    if (!position || typeof position !== "object") {
      return position;
    }

    const entrySize = toFiniteNumber(position.entry_size_sol);
    const entryPrice = toFiniteNumber(
      position.effective_entry_price ?? position.entry_price
    );
    const currentPrice = toFiniteNumber(position.current_price);
    const solReceived = toFiniteNumber(position.sol_received);
    const exitPrice = toFiniteNumber(
      position.effective_exit_price ?? position.exit_price
    );

    if (position.transaction_exit_verified) {
      let pnlValue = null;
      let pnlPercent = null;

      if (solReceived != null && entrySize != null) {
        pnlValue = solReceived - entrySize;
        if (entrySize > 0) {
          pnlPercent = (pnlValue / entrySize) * 100;
        }
      } else if (exitPrice != null && entryPrice != null && entryPrice > 0) {
        pnlPercent = ((exitPrice - entryPrice) / entryPrice) * 100;
        if (entrySize != null) {
          pnlValue = entrySize * (pnlPercent / 100);
        }
      }

      if (pnlValue != null && Number.isFinite(pnlValue)) {
        position.pnl = pnlValue;
      } else if (position.pnl === undefined) {
        position.pnl = null;
      }

      if (pnlPercent != null && Number.isFinite(pnlPercent)) {
        position.pnl_percent = pnlPercent;
      } else if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }

      if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }
      if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }
    } else {
      let unrealizedValue = null;
      let unrealizedPercent = null;

      if (
        currentPrice != null &&
        entryPrice != null &&
        entryPrice > 0 &&
        entrySize != null
      ) {
        unrealizedPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
        unrealizedValue = entrySize * (unrealizedPercent / 100);
      }

      if (unrealizedValue != null && Number.isFinite(unrealizedValue)) {
        position.unrealized_pnl = unrealizedValue;
      } else if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }

      if (unrealizedPercent != null && Number.isFinite(unrealizedPercent)) {
        position.unrealized_pnl_percent = unrealizedPercent;
      } else if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }

      if (position.pnl === undefined) {
        position.pnl = null;
      }
      if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }
    }

    return position;
  }

  function normalizePositionFromApi(raw) {
    if (!raw || typeof raw !== "object") return raw;
    const position = { ...raw };

    position.entry_time = parsePossibleTimestamp(position.entry_time);
    position.exit_time = parsePossibleTimestamp(position.exit_time);
    position.current_price_updated = parsePossibleTimestamp(
      position.current_price_updated
    );

    return computeDerivedMetrics(position);
  }

  function getPositionKey(position) {
    if (!position) return null;

    if (position.id !== undefined && position.id !== null) {
      return `id:${position.id}`;
    }

    if (position.mint) {
      return `mint:${position.mint}`;
    }

    return null;
  }

  function matchesStatusFilter(position, filterValue) {
    if (filterValue === "all") return true;
    const isOpen = !position.transaction_exit_verified;
    if (filterValue === "open") {
      return isOpen;
    }
    if (filterValue === "closed") {
      return !isOpen;
    }
    return true;
  }

  function matchesSearchFilter(position, searchTerm) {
    if (!searchTerm) return true;
    const fields = [position.symbol, position.name, position.mint];
    return fields.some(
      (field) => field && field.toLowerCase().includes(searchTerm)
    );
  }

  function renderPositionRow(pos) {
    const isOpen = !pos.transaction_exit_verified;
    const statusBadge = pos.synthetic_exit
      ? '<span class="status-badge status-synthetic">SYNTHETIC</span>'
      : isOpen
      ? '<span class="status-badge status-open">OPEN</span>'
      : '<span class="status-badge status-closed">CLOSED</span>';

    const currentOrExitPrice = isOpen
      ? pos.current_price
        ? Utils.formatNumber(pos.current_price, 8, {
            fallback: "-",
            useGrouping: false,
          })
        : "-"
      : pos.effective_exit_price || pos.exit_price
      ? Utils.formatNumber(pos.effective_exit_price || pos.exit_price, 8, {
          fallback: "-",
          useGrouping: false,
        })
      : "-";

    const pnl = isOpen ? pos.unrealized_pnl : pos.pnl;
    const pnlPercent = isOpen ? pos.unrealized_pnl_percent : pos.pnl_percent;

    return `
                <tr class="position-row" data-position-key="${
                  getPositionKey(pos) || ""
                }">
                    <td>${statusBadge}</td>
                    <td><strong>${pos.symbol}</strong></td>
                    <td style="font-size: 0.85em;">${pos.name}</td>
                    <td>${Utils.formatNumber(
                      pos.effective_entry_price || pos.entry_price,
                      8,
                      { fallback: "-", useGrouping: false }
                    )}</td>
                    <td>${currentOrExitPrice}</td>
                    <td>${Utils.formatSol(pos.entry_size_sol, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPnL(pnl, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPercent(pnlPercent, {
                      style: "pnl",
                      decimals: 2,
                      fallback: "-",
                    })}</td>
                    <td style="font-size: 0.85em;">${Utils.formatTimeFromSeconds(
                      pos.entry_time,
                      { fallback: "-" }
                    )}</td>
                    <td>
                        <div class="dropdown-container">
              <button class="dropdown-btn" onclick="handlePositionDropdown(event)" aria-label="Actions">
                                ‚ãÆ
                            </button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyDebugInfo('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üìã Copy Debug Info
                                </button>
                                <button onclick="Utils.copyMint('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìã Copy Mint
                                </button>
                                <button onclick="Utils.openGMGN('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîó Open GMGN
                                </button>
                                <button onclick="Utils.openDexScreener('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìä Open DexScreener
                                </button>
                                <button onclick="Utils.openSolscan('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîç Open Solscan
                                </button>
                                <button onclick="showDebugModal('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üêõ Debug Info
                                </button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function updatePositionCount(count) {
    const label = document.getElementById("positionCount");
    if (!label) return;
    const value = Number.isFinite(count) ? count : positionsStore.size;
    label.textContent = `${value} ${value === 1 ? "position" : "positions"}`;
  }

  function renderEmptyState(message, color = "#64748b") {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; padding: 20px; color: ${color};">
                        ${message}
                    </td>
                </tr>
            `;
  }

  function renderPositionsTable() {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;

    const table = tbody.closest("table");
    const container =
      table && table.parentElement instanceof HTMLElement
        ? table.parentElement
        : null;
    const releaseLayout =
      table &&
      typeof Utils !== "undefined" &&
      typeof Utils.freezeTableLayout === "function"
        ? Utils.freezeTableLayout(table)
        : null;
    const previousScroll =
      container instanceof HTMLElement
        ? { top: container.scrollTop, left: container.scrollLeft }
        : null;

    try {
      const controller = window.positionsController;
      const hasSnapshot = controller ? controller.hasInitialSnapshot : false;

      if (!hasSnapshot && positionsStore.size === 0) {
        renderEmptyState("Loading positions...");
        refreshOpenPositionModal();
        return;
      }

      if (
        positionsStore.size === 0 &&
        controller &&
        controller.lastErrorMessage
      ) {
        renderEmptyState(controller.lastErrorMessage, "#ef4444");
        updatePositionCount(0);
        refreshOpenPositionModal();
        return;
      }

      const statusFilter = getCurrentStatusFilter();
      const searchTerm = getSearchTerm();

      const rows = Array.from(positionsStore.values())
        .filter((pos) => matchesStatusFilter(pos, statusFilter))
        .filter((pos) => matchesSearchFilter(pos, searchTerm))
        .sort((a, b) => {
          const aTime = a.entry_time ?? 0;
          const bTime = b.entry_time ?? 0;
          return bTime - aTime;
        });

      if (rows.length === 0) {
        renderEmptyState("No positions found");
        updatePositionCount(0);
        refreshOpenPositionModal();
        return;
      }

      tbody.innerHTML = rows.map(renderPositionRow).join("");
      bindPositionRowClicks();
      refreshOpenPositionModal();
      updatePositionCount(rows.length);
    } finally {
      if (container && previousScroll) {
        if (container.scrollTop !== previousScroll.top) {
          container.scrollTop = previousScroll.top;
        }
        if (container.scrollLeft !== previousScroll.left) {
          container.scrollLeft = previousScroll.left;
        }
      }

      if (typeof releaseLayout === "function") {
        const release = releaseLayout;
        if (typeof requestAnimationFrame === "function") {
          requestAnimationFrame(release);
        } else {
          setTimeout(release, 0);
        }
      }
    }
  }

  const positionsController =
    window.positionsController ||
    (function () {
      let searchBound = false;

      const controller = {
        hasInitialSnapshot: positionsStore.size > 0,
        fetchLimit: 500,
        pollTimer: null,
        abortController: null,
        isFetching: false,
        isActive: false,
        lastErrorMessage: null,
        intervalChangeListener: null,

        activate() {
          if (this.isActive) {
            console.log(
              "[Positions] Controller already active; rendering cache"
            );
            renderPositionsTable();
            return;
          }

          this.isActive = true;
          this.bindSearchInput();
          this.lastErrorMessage = null;

          if (!this.hasInitialSnapshot || positionsStore.size === 0) {
            renderEmptyState("Loading positions...");
            updatePositionCount(0);
          } else {
            renderPositionsTable();
          }

          // Register interval change listener
          if (window.PollingManager && !this.intervalChangeListener) {
            this.intervalChangeListener = window.PollingManager.onChange(() => {
              if (this.isActive) {
                console.log(
                  "[Positions] Polling interval changed, restarting polling"
                );
                this.startPolling();
              }
            });
          }

          this.fetchPositions({
            reason: this.hasInitialSnapshot ? "resume" : "initial",
            showSpinner: !this.hasInitialSnapshot || positionsStore.size === 0,
          });
          this.startPolling();
        },

        teardown() {
          if (!this.isActive) {
            return;
          }
          console.log("[Positions] Tearing down controller");
          this.isActive = false;
          this.stopPolling();
          this.abortInFlight();
          closePositionModal();

          // Remove interval change listener
          if (this.intervalChangeListener && window.PollingManager) {
            window.PollingManager.removeListener(this.intervalChangeListener);
            this.intervalChangeListener = null;
          }
        },

        bindSearchInput() {
          if (searchBound) return;
          const searchInput = document.getElementById("searchInput");
          if (searchInput) {
            searchInput.addEventListener("input", () => {
              renderPositionsTable();
            });
            searchBound = true;
          }
        },

        startPolling() {
          if (!this.isActive) {
            return;
          }
          this.stopPolling();
          const interval = window.PollingManager.getInterval();
          const intervalId = setInterval(() => {
            this.fetchPositions({ reason: "poll" });
          }, interval);
          this.pollTimer = intervalId;
          if (window.Router && typeof Router.trackInterval === "function") {
            Router.trackInterval(intervalId);
          }
          console.log("[Positions] Started polling every", interval, "ms");
        },

        stopPolling() {
          if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
            console.log("[Positions] Stopped polling");
          }
        },

        abortInFlight() {
          if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
            console.log("[Positions] Aborted in-flight request");
          }
        },

        handleStatusChange() {
          console.log(
            "[Positions] Status changed to",
            getCurrentStatusFilter()
          );
          this.stopPolling();
          this.abortInFlight();
          this.hasInitialSnapshot = false;
          this.lastErrorMessage = null;
          closePositionModal();
          positionsStore.clear();
          renderEmptyState("Loading positions...");
          updatePositionCount(0);
          this.fetchPositions({ reason: "filter", showSpinner: false }).finally(
            () => {
              if (this.isActive) {
                this.startPolling();
              }
            }
          );
        },

        handleManualRefresh() {
          console.log("[Positions] Manual refresh requested");
          this.stopPolling();
          this.abortInFlight();
          this.hasInitialSnapshot = false;
          this.lastErrorMessage = null;
          closePositionModal();
          positionsStore.clear();
          renderEmptyState("Refreshing positions...");
          updatePositionCount(0);
          this.fetchPositions({ reason: "manual", showSpinner: false }).finally(
            () => {
              if (this.isActive) {
                this.startPolling();
              }
            }
          );
        },

        async fetchPositions({ reason = "load", showSpinner = false } = {}) {
          if (!this.isActive && reason !== "initial") {
            return;
          }

          if (this.isFetching) {
            if (reason === "poll") {
              console.log(
                "[Positions] Skipping poll; request already in flight"
              );
              return;
            }
            this.abortInFlight();
          }

          const status = getCurrentStatusFilter();
          const params = new URLSearchParams();
          if (status && status !== "all") {
            params.set("status", status);
          }
          if (this.fetchLimit > 0) {
            params.set("limit", String(this.fetchLimit));
          }
          const query = params.toString();
          const url = `/api/positions${query ? `?${query}` : ""}`;

          if (showSpinner) {
            renderEmptyState("Loading positions...");
            updatePositionCount(0);
          }

          try {
            this.isFetching = true;
            this.abortController = new AbortController();
            console.log(`[Positions] Fetching positions (${reason}) via`, url);

            const response = await fetch(url, {
              signal: this.abortController.signal,
              headers: { "X-Requested-With": "fetch" },
            });
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const payload = await response.json();
            const nextStore = new Map();
            if (Array.isArray(payload)) {
              payload.forEach((raw) => {
                const normalized = normalizePositionFromApi(raw);
                const key = getPositionKey(normalized);
                if (key) {
                  nextStore.set(key, normalized);
                }
              });
            }

            this.lastErrorMessage = null;
            positionsStore.clear();
            nextStore.forEach((value, key) => {
              positionsStore.set(key, value);
            });

            this.hasInitialSnapshot = true;
            renderPositionsTable();
            console.log(
              `[Positions] Loaded ${positionsStore.size} positions (${reason})`
            );
          } catch (error) {
            if (error.name === "AbortError") {
              console.log("[Positions] Fetch aborted");
              return;
            }
            console.error("[Positions] Failed to fetch positions:", error);
            if (!this.hasInitialSnapshot || positionsStore.size === 0) {
              this.hasInitialSnapshot = true;
              this.lastErrorMessage = `Failed to load positions: ${error.message}`;
              renderEmptyState(this.lastErrorMessage, "#ef4444");
              updatePositionCount(0);
            }
          } finally {
            this.isFetching = false;
            this.abortController = null;
          }
        },
      };

      return controller;
    })();

  window.positionsController = positionsController;

  window.onPositionsStatusChanged = function () {
    if (window.positionsController) {
      window.positionsController.handleStatusChange();
    }
  };

  window.refreshPositions = function () {
    if (window.positionsController) {
      window.positionsController.handleManualRefresh();
    }
  };

  // Global init function for Router to call during SPA navigation
  window.initPositionsPage = function () {
    console.log("[Positions] Initializing page");
    if (!window.positionsController) {
      console.error("[Positions] Controller unavailable");
      return;
    }

    window.positionsController.activate();

    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => window.positionsController.teardown());
    }
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initPositionsPage();
</script>
