<style>
  .pnl-positive {
    color: #10b981;
    font-weight: 600;
  }

  .pnl-negative {
    color: #ef4444;
    font-weight: 600;
  }

  .pnl-neutral {
    color: #6b7280;
  }

  .status-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: 600;
    display: inline-block;
  }

  .status-open {
    background: #10b98120;
    color: #10b981;
  }

  .status-closed {
    background: #64748b20;
    color: #64748b;
  }

  .status-synthetic {
    background: #f59e0b20;
    color: #f59e0b;
  }
</style>
<div class="page-table">
  <div class="toolbar">
    <span style="font-weight: 600">üí∞ Positions</span>
    <select
      id="statusFilter"
      onchange="onPositionsStatusChanged()"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="all">All</option>
      <option value="open" selected>Open</option>
      <option value="closed">Closed</option>
    </select>
    <input
      type="text"
      id="searchInput"
      placeholder="Search symbol, name, or mint"
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <div class="spacer"></div>
    <span
      id="positionCount"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button onclick="refreshPositions()" class="btn btn-primary">
      üîÑ Refresh
    </button>
  </div>
  <div class="table-wrap">
    <table class="table" id="positionsTable">
      <thead>
        <tr>
          <th style="min-width: 80px">Status</th>
          <th style="min-width: 100px">Symbol</th>
          <th style="min-width: 150px">Name</th>
          <th style="min-width: 120px">Entry Price</th>
          <th style="min-width: 120px">Current/Exit</th>
          <th style="min-width: 100px">Size (SOL)</th>
          <th style="min-width: 120px">P&L</th>
          <th style="min-width: 120px">P&L %</th>
          <th style="min-width: 150px">Entry Time</th>
          <th style="min-width: 100px">Actions</th>
        </tr>
      </thead>
      <tbody id="positionsTableBody">
        <tr>
          <td
            colspan="10"
            style="text-align: center; padding: 20px; color: #64748b"
          >
            Loading positions...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
  var positionsStore = window.positionsStore || new Map();
  var positionsInitialized = false;
  var positionsInSnapshot = false;
  var lastPositionsSnapshotMeta = null;
  var POSITIONS_SNAPSHOT_TIMEOUT_MS = 15000;
  const POSITIONS_SNAPSHOT_LIMIT = 1000;

  var positionsSnapshotState = {
    inProgress: false,
    started: false,
    requestId: null,
    context: null,
    expected: 0,
    received: 0,
    totalAvailable: 0,
    timeoutHandle: null,
    lastTimerReason: null,
  };

  // Truncate address
  function truncateAddress(address) {
    if (!address) return "-";
    return (
      address.substring(0, 8) + "..." + address.substring(address.length - 6)
    );
  }

  function clearPositionsSnapshotTimer() {
    if (positionsSnapshotState.timeoutHandle) {
      clearTimeout(positionsSnapshotState.timeoutHandle);
      positionsSnapshotState.timeoutHandle = null;
    }
    positionsSnapshotState.lastTimerReason = null;
  }

  function schedulePositionsSnapshotTimer(reason) {
    clearPositionsSnapshotTimer();

    if (
      !Number.isFinite(POSITIONS_SNAPSHOT_TIMEOUT_MS) ||
      POSITIONS_SNAPSHOT_TIMEOUT_MS <= 0
    ) {
      return;
    }

    positionsSnapshotState.lastTimerReason = reason || null;
    positionsSnapshotState.timeoutHandle = setTimeout(() => {
      positionsSnapshotState.timeoutHandle = null;
      if (!positionsSnapshotState.inProgress) {
        return;
      }

      console.warn(
        `[Positions] Snapshot timeout (${
          positionsSnapshotState.lastTimerReason || "unknown"
        })`
      );

      if (positionsSnapshotState.received > 0 || positionsStore.size > 0) {
        handlePositionsSnapshotEnd({
          topic: "positions.update",
          sent: positionsSnapshotState.received,
          request_id: positionsSnapshotState.requestId,
          context: Object.assign(
            {
              request_id: positionsSnapshotState.requestId,
              total_selected: positionsSnapshotState.received,
              total_available: Math.max(
                positionsSnapshotState.totalAvailable,
                positionsStore.size
              ),
            },
            positionsSnapshotState.context || {}
          ),
        });
      } else {
        renderEmptyState("Snapshot timed out ‚Äî retrying...", "#f97316");
        requestPositionsSnapshot("timeout-retry");
      }
    }, POSITIONS_SNAPSHOT_TIMEOUT_MS);
  }

  function getCurrentStatusFilter() {
    const select = document.getElementById("statusFilter");
    return select ? select.value : "all";
  }

  function getSearchTerm() {
    const input = document.getElementById("searchInput");
    return input ? input.value.toLowerCase().trim() : "";
  }

  function isDropdownOpen() {
    return Boolean(document.querySelector(".dropdown-menu.show"));
  }

  function parsePossibleTimestamp(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === "string" && value.trim() !== "") {
      const numeric = Number(value);
      if (Number.isFinite(numeric)) {
        return numeric;
      }

      const parsed = Date.parse(value);
      if (Number.isFinite(parsed)) {
        return Math.floor(parsed / 1000);
      }
    }
    return null;
  }

  function toFiniteNumber(value) {
    try {
      if (
        typeof Utils !== "undefined" &&
        Utils &&
        typeof Utils.coerceNumber === "function"
      ) {
        const coerced = Utils.coerceNumber(value);
        return Number.isFinite(coerced) ? coerced : null;
      }
    } catch (_) {}

    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function computeDerivedMetrics(position) {
    if (!position || typeof position !== "object") {
      return position;
    }

    const entrySize = toFiniteNumber(position.entry_size_sol);
    const entryPrice = toFiniteNumber(
      position.effective_entry_price ?? position.entry_price
    );
    const currentPrice = toFiniteNumber(position.current_price);
    const solReceived = toFiniteNumber(position.sol_received);
    const exitPrice = toFiniteNumber(
      position.effective_exit_price ?? position.exit_price
    );

    if (position.transaction_exit_verified) {
      let pnlValue = null;
      let pnlPercent = null;

      if (solReceived != null && entrySize != null) {
        pnlValue = solReceived - entrySize;
        if (entrySize > 0) {
          pnlPercent = (pnlValue / entrySize) * 100;
        }
      } else if (exitPrice != null && entryPrice != null && entryPrice > 0) {
        pnlPercent = ((exitPrice - entryPrice) / entryPrice) * 100;
        if (entrySize != null) {
          pnlValue = entrySize * (pnlPercent / 100);
        }
      }

      if (pnlValue != null && Number.isFinite(pnlValue)) {
        position.pnl = pnlValue;
      } else if (position.pnl === undefined) {
        position.pnl = null;
      }

      if (pnlPercent != null && Number.isFinite(pnlPercent)) {
        position.pnl_percent = pnlPercent;
      } else if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }

      if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }
      if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }
    } else {
      let unrealizedValue = null;
      let unrealizedPercent = null;

      if (
        currentPrice != null &&
        entryPrice != null &&
        entryPrice > 0 &&
        entrySize != null
      ) {
        unrealizedPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
        unrealizedValue = entrySize * (unrealizedPercent / 100);
      }

      if (unrealizedValue != null && Number.isFinite(unrealizedValue)) {
        position.unrealized_pnl = unrealizedValue;
      } else if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }

      if (unrealizedPercent != null && Number.isFinite(unrealizedPercent)) {
        position.unrealized_pnl_percent = unrealizedPercent;
      } else if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }

      if (position.pnl === undefined) {
        position.pnl = null;
      }
      if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }
    }

    return position;
  }

  function normalizePositionFromApi(raw) {
    if (!raw || typeof raw !== "object") return raw;
    const position = { ...raw };

    position.entry_time = parsePossibleTimestamp(position.entry_time);
    position.exit_time = parsePossibleTimestamp(position.exit_time);
    position.current_price_updated = parsePossibleTimestamp(
      position.current_price_updated
    );

    return computeDerivedMetrics(position);
  }

  function getPositionKey(position) {
    if (!position) return null;

    if (position.id !== undefined && position.id !== null) {
      return `id:${position.id}`;
    }

    if (position.mint) {
      const entry = position.entry_time ?? position.created_at ?? "";
      return `mint:${position.mint}:${entry}`;
    }

    return null;
  }

  function matchesStatusFilter(position, filterValue) {
    if (filterValue === "all") return true;
    const isOpen = !position.transaction_exit_verified;
    if (filterValue === "open") {
      return isOpen;
    }
    if (filterValue === "closed") {
      return !isOpen;
    }
    return true;
  }

  function matchesSearchFilter(position, searchTerm) {
    if (!searchTerm) return true;
    const fields = [position.symbol, position.name, position.mint];
    return fields.some(
      (field) => field && field.toLowerCase().includes(searchTerm)
    );
  }

  function shouldIncludeInCurrentFilter(position) {
    return matchesStatusFilter(position, getCurrentStatusFilter());
  }

  function renderPositionRow(pos) {
    const isOpen = !pos.transaction_exit_verified;
    const statusBadge = pos.synthetic_exit
      ? '<span class="status-badge status-synthetic">SYNTHETIC</span>'
      : isOpen
      ? '<span class="status-badge status-open">OPEN</span>'
      : '<span class="status-badge status-closed">CLOSED</span>';

    const currentOrExitPrice = isOpen
      ? pos.current_price
        ? Utils.formatNumber(pos.current_price, 8, {
            fallback: "-",
            useGrouping: false,
          })
        : "-"
      : pos.effective_exit_price || pos.exit_price
      ? Utils.formatNumber(pos.effective_exit_price || pos.exit_price, 8, {
          fallback: "-",
          useGrouping: false,
        })
      : "-";

    const pnl = isOpen ? pos.unrealized_pnl : pos.pnl;
    const pnlPercent = isOpen ? pos.unrealized_pnl_percent : pos.pnl_percent;

    return `
                <tr data-position-key="${getPositionKey(pos) || ""}">
                    <td>${statusBadge}</td>
                    <td><strong>${pos.symbol}</strong></td>
                    <td style="font-size: 0.85em;">${pos.name}</td>
                    <td>${Utils.formatNumber(
                      pos.effective_entry_price || pos.entry_price,
                      8,
                      { fallback: "-", useGrouping: false }
                    )}</td>
                    <td>${currentOrExitPrice}</td>
                    <td>${Utils.formatSol(pos.entry_size_sol, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPnL(pnl, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPercent(pnlPercent, {
                      style: "pnl",
                      decimals: 2,
                      fallback: "-",
                    })}</td>
                    <td style="font-size: 0.85em;">${Utils.formatTimeFromSeconds(
                      pos.entry_time,
                      { fallback: "-" }
                    )}</td>
                    <td>
                        <div class="dropdown-container">
                            <button class="dropdown-btn" onclick="Utils.toggleDropdown(event)" aria-label="Actions">
                                ‚ãÆ
                            </button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyDebugInfo('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üìã Copy Debug Info
                                </button>
                                <button onclick="Utils.copyMint('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìã Copy Mint
                                </button>
                                <button onclick="Utils.openGMGN('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîó Open GMGN
                                </button>
                                <button onclick="Utils.openDexScreener('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìä Open DexScreener
                                </button>
                                <button onclick="Utils.openSolscan('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîç Open Solscan
                                </button>
                                <button onclick="showDebugModal('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üêõ Debug Info
                                </button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function updatePositionCount(count) {
    const label = document.getElementById("positionCount");
    if (!label) return;
    const value = Number.isFinite(count) ? count : positionsStore.size;
    label.textContent = `${value} ${value === 1 ? "position" : "positions"}`;
  }

  function renderEmptyState(message, color = "#64748b") {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; padding: 20px; color: ${color};">
                        ${message}
                    </td>
                </tr>
            `;
  }

  function renderPositionsTable() {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;

    if (!positionsInitialized && positionsStore.size === 0) {
      renderEmptyState(
        positionsSnapshotState.inProgress
          ? "Loading positions..."
          : "Waiting for realtime snapshot..."
      );
      return;
    }

    const statusFilter = getCurrentStatusFilter();
    const searchTerm = getSearchTerm();

    const rows = Array.from(positionsStore.values())
      .filter((pos) => matchesStatusFilter(pos, statusFilter))
      .filter((pos) => matchesSearchFilter(pos, searchTerm))
      .sort((a, b) => {
        const aTime = a.entry_time ?? 0;
        const bTime = b.entry_time ?? 0;
        return bTime - aTime;
      });

    if (rows.length === 0) {
      renderEmptyState("No positions found");
      updatePositionCount(0);
      return;
    }

    tbody.innerHTML = rows.map(renderPositionRow).join("");
    updatePositionCount(rows.length);
    positionsSnapshotState.totalAvailable = Math.max(
      positionsSnapshotState.totalAvailable,
      rows.length
    );
  }

  function handlePositionsSnapshotBegin(payload) {
    if (!payload || payload.topic !== "positions.update") return;

    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;

    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds["positions.update"] ||
          realtime.lastSnapshotRequestIds["positions"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      positionsSnapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Positions] Ignoring stale snapshot_begin", {
          requestId,
          latestRequestId,
          stateRequestId: positionsSnapshotState.requestId,
        });
      }
      return;
    }

    positionsSnapshotState.inProgress = true;
    positionsSnapshotState.started = true;
    positionsSnapshotState.requestId =
      requestId || positionsSnapshotState.requestId;
    positionsSnapshotState.context = context || null;
    positionsSnapshotState.expected =
      Number(context.total_selected ?? context.total ?? payload?.total) || 0;
    positionsSnapshotState.received = 0;
    positionsSnapshotState.totalAvailable = Number(
      context.total_available ?? positionsSnapshotState.expected
    );
    positionsSnapshotState.totalAvailable = Number.isFinite(
      positionsSnapshotState.totalAvailable
    )
      ? positionsSnapshotState.totalAvailable
      : 0;

    positionsInSnapshot = true;
    positionsInitialized = false;
    lastPositionsSnapshotMeta = payload;
    positionsStore.clear();
    renderEmptyState("Loading positions...");
    updatePositionCount(0);
    schedulePositionsSnapshotTimer("begin");
  }

  function handlePositionsSnapshotEnd(payload) {
    if (!payload || payload.topic !== "positions.update") return;

    clearPositionsSnapshotTimer();

    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;

    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds["positions.update"] ||
          realtime.lastSnapshotRequestIds["positions"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      positionsSnapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Positions] Ignoring stale snapshot_end", {
          requestId,
          latestRequestId,
          stateRequestId: positionsSnapshotState.requestId,
        });
      }
      return;
    }

    if (
      requestId &&
      positionsSnapshotState.requestId &&
      requestId !== positionsSnapshotState.requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Positions] snapshot_end request mismatch", {
          requestId,
          stateRequestId: positionsSnapshotState.requestId,
        });
      }
      return;
    }

    if (requestId) {
      positionsSnapshotState.requestId = requestId;
    }

    if (context && Object.keys(context).length > 0) {
      positionsSnapshotState.context = context;
    }

    const sent = Number(
      context.total_selected ??
        context.total ??
        payload?.sent ??
        positionsSnapshotState.received
    );
    if (Number.isFinite(sent)) {
      positionsSnapshotState.received = sent;
    }

    const available = Number(
      context.total_available ?? positionsSnapshotState.totalAvailable ?? sent
    );
    if (Number.isFinite(available)) {
      positionsSnapshotState.totalAvailable = Math.max(
        positionsSnapshotState.totalAvailable,
        available,
        positionsStore.size
      );
    }

    positionsSnapshotState.inProgress = false;
    positionsSnapshotState.started = false;
    positionsInSnapshot = false;
    positionsInitialized = true;
    lastPositionsSnapshotMeta = payload;
    renderPositionsTable();
  }

  function handlePositionBroadcast(update, envelope) {
    if (!update || typeof update !== "object") return;

    if (update.type === "balance_changed") {
      return;
    }

    if (!update.position) {
      console.warn("[Positions] Update missing position payload", {
        type: update?.type,
        keys: Object.keys(update || {}),
      });
      return;
    }

    const meta = envelope?.meta || {};
    const isSnapshotMessage =
      meta.snapshot === true || update.type === "snapshot";
    if (isSnapshotMessage) {
      const chunkRequestId =
        meta?.extra?.request_id ||
        meta?.extra?.requestId ||
        meta?.request_id ||
        meta?.requestId ||
        null;
      if (
        positionsSnapshotState.requestId &&
        chunkRequestId &&
        chunkRequestId !== positionsSnapshotState.requestId
      ) {
        if (window.__DEBUG_REALTIME) {
          console.warn("[Positions] Ignoring stale snapshot chunk", {
            chunkRequestId,
            stateRequestId: positionsSnapshotState.requestId,
          });
        }
        return;
      }
      if (!positionsSnapshotState.started) {
        if (window.__DEBUG_REALTIME) {
          console.warn("[Positions] Snapshot chunk before begin", { meta });
        }
        return;
      }
    }

    const normalized = normalizePositionFromApi(update.position);
    const key = getPositionKey(normalized);
    if (!key) {
      console.warn("[Positions] Unable to derive key for update", {
        type: update?.type,
        hasId: Boolean(update?.position?.id),
        hasMint: Boolean(update?.position?.mint),
      });
      return;
    }

    if (shouldIncludeInCurrentFilter(normalized)) {
      positionsStore.set(key, normalized);
    } else {
      positionsStore.delete(key);
    }

    if (isSnapshotMessage) {
      positionsSnapshotState.received += 1;
      const totalMeta =
        meta?.extra?.total_selected || meta?.extra?.total || meta?.total;
      if (Number.isFinite(totalMeta)) {
        positionsSnapshotState.totalAvailable = Math.max(
          positionsSnapshotState.totalAvailable,
          Number(totalMeta),
          positionsStore.size
        );
      } else {
        positionsSnapshotState.totalAvailable = Math.max(
          positionsSnapshotState.totalAvailable,
          positionsStore.size
        );
      }
      schedulePositionsSnapshotTimer("chunk");
    } else {
      positionsSnapshotState.totalAvailable = Math.max(
        positionsSnapshotState.totalAvailable,
        positionsStore.size
      );
    }

    if (!positionsInSnapshot) {
      positionsInitialized = true;
      renderPositionsTable();
    }
  }

  function handlePositionsWarning(message) {
    if (!message) return;
    const channel = message.alias || message.channel || message.topic;
    if (channel !== "positions" && channel !== "positions.update") return;
    console.warn("[Positions] WebSocket warning received", {
      code: message?.code,
      text: message?.message,
    });
    if (!positionsInitialized) {
      renderEmptyState("Realtime warning ‚Äì waiting for data...");
    }
  }

  function handlePositionsDisconnect() {
    console.warn("[Positions] WebSocket disconnected");
    if (!positionsInitialized && positionsStore.size === 0) {
      renderEmptyState("Realtime connection lost");
      updatePositionCount(0);
    }
  }

  function handlePositionsReconnect() {
    console.info("[Positions] WebSocket reconnected ‚Äì requesting snapshot");
    requestPositionsSnapshot("ws-reconnect");
  }

  function requestPositionsSnapshot(reason = "manual") {
    if (
      !window.Realtime ||
      (typeof Realtime.requestSnapshotForAliases !== "function" &&
        typeof Realtime.updateFilters !== "function")
    ) {
      console.warn(
        "[Positions] Realtime helper not available; cannot request snapshot"
      );
      return;
    }

    positionsSnapshotState.inProgress = true;
    positionsSnapshotState.started = false;
    positionsSnapshotState.requestId = null;
    positionsSnapshotState.context = null;
    positionsSnapshotState.expected = 0;
    positionsSnapshotState.received = 0;
    positionsSnapshotState.totalAvailable = 0;
    positionsInSnapshot = true;
    schedulePositionsSnapshotTimer("request");

    if (
      window.Realtime &&
      typeof Realtime.requestSnapshotForAliases === "function"
    ) {
      console.log("[Positions] Requesting snapshot", { reason });
      const result = Realtime.requestSnapshotForAliases(["positions"]) || {};
      const requestId =
        result["positions.update"] || result["positions"] || null;
      if (requestId) {
        positionsSnapshotState.requestId = requestId;
      }
    } else if (
      window.Realtime &&
      typeof Realtime.updateFilters === "function"
    ) {
      console.log("[Positions] Requesting snapshot via update", { reason });
      const result =
        Realtime.updateFilters({
          snapshotTopics: ["positions.update", "positions"],
        }) || {};
      const requestId =
        result["positions.update"] || result["positions"] || null;
      if (requestId) {
        positionsSnapshotState.requestId = requestId;
      }
    }
  }

  window.onPositionsStatusChanged = function () {
    positionsStore.clear();
    positionsInitialized = false;
    positionsSnapshotState.inProgress = true;
    positionsSnapshotState.started = false;
    positionsSnapshotState.requestId = null;
    positionsSnapshotState.context = null;
    positionsSnapshotState.expected = 0;
    positionsSnapshotState.received = 0;
    positionsSnapshotState.totalAvailable = 0;
    schedulePositionsSnapshotTimer("status-filter");
    renderEmptyState("Loading positions...");
    updatePositionCount(0);
    requestPositionsSnapshot("status-filter");
  };

  window.refreshPositions = function () {
    console.log("[Positions] Manual refresh requested");
    positionsInitialized = false;
    positionsSnapshotState.inProgress = true;
    positionsSnapshotState.started = false;
    positionsSnapshotState.requestId = null;
    positionsSnapshotState.context = null;
    positionsSnapshotState.expected = 0;
    positionsSnapshotState.received = 0;
    positionsSnapshotState.totalAvailable = 0;
    schedulePositionsSnapshotTimer("manual-refresh");
    renderEmptyState("Refreshing positions...");
    updatePositionCount(0);
    requestPositionsSnapshot("manual-refresh");
  };

  function handlePositionsWarningOrDisconnect(message) {
    clearPositionsSnapshotTimer();
    positionsSnapshotState.inProgress = false;
    positionsSnapshotState.started = false;
    if (message) {
      console.warn("[Positions] Realtime disruption", {
        code: message?.code,
        text: message?.message,
      });
    } else {
      console.warn("[Positions] Realtime disruption detected");
    }
    if (!positionsInitialized && positionsStore.size === 0) {
      renderEmptyState("Realtime unavailable");
      updatePositionCount(0);
    }
  }

  // Global init function for Router to call during SPA navigation
  window.initPositionsPage = function () {
    console.log("[Positions] Initializing page");

    const searchInput = document.getElementById("searchInput");
    if (searchInput && !searchInput.__positionsBound) {
      searchInput.addEventListener("input", () => {
        renderPositionsTable();
      });
      searchInput.__positionsBound = true;
    }

    if (!positionsInitialized && positionsStore.size === 0) {
      renderEmptyState("Loading positions...");
      updatePositionCount(0);
    } else {
      renderPositionsTable();
    }
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  window.PageRealtime = window.PageRealtime || {};
  window.PageRealtime.positions = {
    topics: ["positions"],
    getFilters() {
      const status = getCurrentStatusFilter();
      const search = getSearchTerm();
      const filter = { limit: POSITIONS_SNAPSHOT_LIMIT };
      if (status && status !== "all") {
        filter.status = [status];
      }
      if (search) {
        filter.search = search;
      }
      return { positions: filter };
    },
    channels: {
      positions: handlePositionBroadcast,
      "snapshot_begin:positions.update": handlePositionsSnapshotBegin,
      "snapshot_end:positions.update": handlePositionsSnapshotEnd,
      _warning: handlePositionsWarning,
      _disconnected: handlePositionsWarningOrDisconnect,
      _failed: handlePositionsWarningOrDisconnect,
      _connected: handlePositionsReconnect,
    },
    onInitial() {
      if (!positionsInitialized && positionsStore.size === 0) {
        renderEmptyState("Loading positions...");
        updatePositionCount(0);
      }
    },
    onEnter() {
      if (!positionsInitialized && positionsStore.size === 0) {
        renderEmptyState("Loading positions...");
        updatePositionCount(0);
      }
    },
    onUnavailable() {
      console.warn("[Positions] Realtime unavailable");
      handlePositionsWarningOrDisconnect({});
    },
    onExit() {
      positionsInSnapshot = false;
    },
  };

  initPositionsPage();
</script>
