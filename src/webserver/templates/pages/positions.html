<style>
  .pnl-positive {
    color: #10b981;
    font-weight: 600;
  }
  .pnl-negative {
    color: #ef4444;
    font-weight: 600;
  }
  .pnl-neutral {
    color: #6b7280;
  }
  .status-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: 600;
    display: inline-block;
  }
  .status-open {
    background: #10b98120;
    color: #10b981;
  }
  .status-closed {
    background: #64748b20;
    color: #64748b;
  }
  .status-synthetic {
    background: #f59e0b20;
    color: #f59e0b;
  }
</style>
<div class="page-section">
  <div class="toolbar">
    <span style="font-weight: 600">üí∞ Positions</span>
    <select
      id="statusFilter"
      onchange="loadPositions({ reason: 'filter-change', force: true })"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="all">All</option>
      <option value="open" selected>Open</option>
      <option value="closed">Closed</option>
    </select>
    <input
      type="text"
      id="searchInput"
      placeholder="Search symbol, name, or mint"
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <div class="spacer"></div>
    <span
      id="positionCount"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button
      onclick="loadPositions({ reason: 'manual-refresh', force: true })"
      class="btn btn-primary"
    >
      üîÑ Refresh
    </button>
  </div>
  <div class="table-scroll">
    <table class="table" id="positionsTable">
      <thead>
        <tr>
          <th style="min-width: 80px">Status</th>
          <th style="min-width: 100px">Symbol</th>
          <th style="min-width: 150px">Name</th>
          <th style="min-width: 120px">Entry Price</th>
          <th style="min-width: 120px">Current/Exit</th>
          <th style="min-width: 100px">Size (SOL)</th>
          <th style="min-width: 120px">P&L</th>
          <th style="min-width: 120px">P&L %</th>
          <th style="min-width: 150px">Entry Time</th>
          <th style="min-width: 100px">Actions</th>
        </tr>
      </thead>
      <tbody id="positionsTableBody">
        <tr>
          <td
            colspan="10"
            style="text-align: center; padding: 20px; color: #64748b"
          >
            Loading positions...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
  var positionsStore = window.positionsStore || new Map();
  var positionsLoading = false;
  var positionsInitialized = false;
  var positionsFallbackInterval = null;
  var positionsRequestController = null;

  // Truncate address
  function truncateAddress(address) {
    if (!address) return "-";
    return (
      address.substring(0, 8) + "..." + address.substring(address.length - 6)
    );
  }

  function getCurrentStatusFilter() {
    const select = document.getElementById("statusFilter");
    return select ? select.value : "all";
  }

  function getSearchTerm() {
    const input = document.getElementById("searchInput");
    return input ? input.value.toLowerCase().trim() : "";
  }

  function isDropdownOpen() {
    return Boolean(document.querySelector(".dropdown-menu.show"));
  }

  function parsePossibleTimestamp(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === "string" && value.trim() !== "") {
      const numeric = Number(value);
      if (Number.isFinite(numeric)) {
        return numeric;
      }

      const parsed = Date.parse(value);
      if (Number.isFinite(parsed)) {
        return Math.floor(parsed / 1000);
      }
    }
    return null;
  }

  function normalizePositionFromApi(raw) {
    if (!raw || typeof raw !== "object") return raw;
    const position = { ...raw };

    position.entry_time = parsePossibleTimestamp(position.entry_time);
    position.exit_time = parsePossibleTimestamp(position.exit_time);
    position.current_price_updated = parsePossibleTimestamp(
      position.current_price_updated
    );

    return position;
  }

  function getPositionKey(position) {
    if (!position) return null;

    if (position.id !== undefined && position.id !== null) {
      return `id:${position.id}`;
    }

    if (position.mint) {
      const entry = position.entry_time ?? position.created_at ?? "";
      return `mint:${position.mint}:${entry}`;
    }

    return null;
  }

  function matchesStatusFilter(position, filterValue) {
    if (filterValue === "all") return true;
    const isOpen = !position.transaction_exit_verified;
    if (filterValue === "open") {
      return isOpen;
    }
    if (filterValue === "closed") {
      return !isOpen;
    }
    return true;
  }

  function matchesSearchFilter(position, searchTerm) {
    if (!searchTerm) return true;
    const fields = [position.symbol, position.name, position.mint];
    return fields.some(
      (field) => field && field.toLowerCase().includes(searchTerm)
    );
  }

  function shouldIncludeInCurrentFilter(position) {
    return matchesStatusFilter(position, getCurrentStatusFilter());
  }

  function renderPositionRow(pos) {
    const isOpen = !pos.transaction_exit_verified;
    const statusBadge = pos.synthetic_exit
      ? '<span class="status-badge status-synthetic">SYNTHETIC</span>'
      : isOpen
      ? '<span class="status-badge status-open">OPEN</span>'
      : '<span class="status-badge status-closed">CLOSED</span>';

    const currentOrExitPrice = isOpen
      ? pos.current_price
        ? Utils.formatNumber(pos.current_price, 8, {
            fallback: "-",
            useGrouping: false,
          })
        : "-"
      : pos.effective_exit_price || pos.exit_price
      ? Utils.formatNumber(pos.effective_exit_price || pos.exit_price, 8, {
          fallback: "-",
          useGrouping: false,
        })
      : "-";

    const pnl = isOpen ? pos.unrealized_pnl : pos.pnl;
    const pnlPercent = isOpen ? pos.unrealized_pnl_percent : pos.pnl_percent;

    return `
                <tr data-position-key="${getPositionKey(pos) || ""}">
                    <td>${statusBadge}</td>
                    <td><strong>${pos.symbol}</strong></td>
                    <td style="font-size: 0.85em;">${pos.name}</td>
                    <td>${Utils.formatNumber(
                      pos.effective_entry_price || pos.entry_price,
                      8,
                      { fallback: "-", useGrouping: false }
                    )}</td>
                    <td>${currentOrExitPrice}</td>
                    <td>${Utils.formatSol(pos.entry_size_sol, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPnL(pnl, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPercent(pnlPercent, {
                      style: "pnl",
                      decimals: 2,
                      fallback: "-",
                    })}</td>
                    <td style="font-size: 0.85em;">${Utils.formatTimeFromSeconds(
                      pos.entry_time,
                      { fallback: "-" }
                    )}</td>
                    <td>
                        <div class="dropdown-container">
                            <button class="dropdown-btn" onclick="Utils.toggleDropdown(event)" aria-label="Actions">
                                ‚ãÆ
                            </button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyDebugInfo('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üìã Copy Debug Info
                                </button>
                                <button onclick="Utils.copyMint('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìã Copy Mint
                                </button>
                                <button onclick="Utils.openGMGN('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîó Open GMGN
                                </button>
                                <button onclick="Utils.openDexScreener('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìä Open DexScreener
                                </button>
                                <button onclick="Utils.openSolscan('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîç Open Solscan
                                </button>
                                <button onclick="showDebugModal('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üêõ Debug Info
                                </button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function updatePositionCount(count) {
    const label = document.getElementById("positionCount");
    if (!label) return;
    const value = Number.isFinite(count) ? count : positionsStore.size;
    label.textContent = `${value} ${value === 1 ? "position" : "positions"}`;
  }

  function renderEmptyState(message, color = "#64748b") {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; padding: 20px; color: ${color};">
                        ${message}
                    </td>
                </tr>
            `;
  }

  function startPositionsFallback(intervalMs = 3000) {
    if (positionsFallbackInterval) return;
    positionsFallbackInterval = setInterval(() => {
      loadPositions({ reason: "fallback" });
    }, intervalMs);

    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => {
        if (positionsFallbackInterval) {
          clearInterval(positionsFallbackInterval);
          positionsFallbackInterval = null;
        }
      });
    }
  }

  function stopPositionsFallback() {
    if (!positionsFallbackInterval) return;
    clearInterval(positionsFallbackInterval);
    positionsFallbackInterval = null;
  }

  function renderPositionsTable() {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;

    if (!positionsInitialized && positionsStore.size === 0) {
      renderEmptyState("Loading positions...");
      return;
    }

    const statusFilter = getCurrentStatusFilter();
    const searchTerm = getSearchTerm();

    const rows = Array.from(positionsStore.values())
      .filter((pos) => matchesStatusFilter(pos, statusFilter))
      .filter((pos) => matchesSearchFilter(pos, searchTerm))
      .sort((a, b) => {
        const aTime = a.entry_time ?? 0;
        const bTime = b.entry_time ?? 0;
        return bTime - aTime;
      });

    if (rows.length === 0) {
      renderEmptyState("No positions found");
      updatePositionCount(0);
      return;
    }

    tbody.innerHTML = rows.map(renderPositionRow).join("");
    updatePositionCount(rows.length);
  }

  function syncPositionsStore(positions) {
    positionsStore.clear();
    positions.forEach((pos) => {
      const normalized = normalizePositionFromApi(pos);
      const key = getPositionKey(normalized);
      if (key) {
        positionsStore.set(key, normalized);
      }
    });
  }

  function handlePositionBroadcast(update) {
    if (!update || typeof update !== "object") return;

    // Receiving live updates means WebSocket is active
    stopPositionsFallback();

    if (update.type === "balance_changed") {
      return;
    }

    if (!update.position) {
      console.warn("[Positions] Update missing position payload:", update);
      return;
    }

    const normalized = normalizePositionFromApi(update.position);
    const key = getPositionKey(normalized);
    if (!key) {
      console.warn("[Positions] Unable to derive key for update:", update);
      return;
    }

    if (shouldIncludeInCurrentFilter(normalized)) {
      positionsStore.set(key, normalized);
    } else {
      positionsStore.delete(key);
    }

    positionsInitialized = true;
    renderPositionsTable();
  }

  function handlePositionsWarning(message) {
    if (!message || message.channel !== "positions") return;
    console.warn("[Positions] WebSocket warning received:", message);
    startPositionsFallback();
    loadPositions({ reason: "ws-warning", force: true });
  }

  function handlePositionsDisconnect() {
    startPositionsFallback();
  }

  function handlePositionsReconnect() {
    stopPositionsFallback();
    loadPositions({ reason: "ws-reconnect", force: true });
  }

  async function loadPositions(options = {}) {
    const { reason = "manual", force = false } = options;

    if (!force && isDropdownOpen()) {
      return;
    }

    if (positionsLoading && !force) {
      return;
    }

    const statusFilter = getCurrentStatusFilter();

    if (positionsStore.size === 0 && !positionsInitialized) {
      renderEmptyState("Loading positions...");
    }

    positionsLoading = true;

    if (positionsRequestController) {
      positionsRequestController.abort();
    }

    positionsRequestController = new AbortController();

    try {
      const response = await fetch(
        `/api/positions?status=${statusFilter}&limit=1000`,
        {
          signal: positionsRequestController.signal,
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const positions = await response.json();
      const array = Array.isArray(positions) ? positions : [];

      syncPositionsStore(array);
      positionsInitialized = true;
      renderPositionsTable();
    } catch (error) {
      if (error.name === "AbortError") {
        return;
      }
      console.error("Failed to load positions:", error);
      if (!positionsInitialized || positionsStore.size === 0) {
        renderEmptyState("‚ö†Ô∏è Failed to load positions", "#ef4444");
        updatePositionCount(0);
      }
    } finally {
      positionsRequestController = null;
      positionsLoading = false;
    }
  }

  // Global init function for Router to call during SPA navigation
  window.initPositionsPage = function () {
    console.log("[Positions] Initializing page");

    const searchInput = document.getElementById("searchInput");
    if (searchInput) {
      searchInput.addEventListener("input", () => {
        renderPositionsTable();
      });
    }
    loadPositions({ reason: "initial", force: true });
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  window.PageRealtime = window.PageRealtime || {};
  window.PageRealtime.positions = {
    channels: {
      positions: handlePositionBroadcast,
      _warning: handlePositionsWarning,
      _disconnected: handlePositionsDisconnect,
      _failed: handlePositionsDisconnect,
      _connected: handlePositionsReconnect,
    },
    onInitial(status) {
      if (status !== "connected") {
        startPositionsFallback();
      }
    },
    onEnter(status) {
      if (status === "connected") {
        stopPositionsFallback();
      }
    },
    onUnavailable() {
      console.warn(
        "[Positions] WebSocket unavailable, enabling HTTP polling fallback."
      );
      startPositionsFallback();
    },
    onExit() {
      stopPositionsFallback();
    },
  };

  initPositionsPage();
</script>
