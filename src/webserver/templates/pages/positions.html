<style>
  .pnl-positive {
    color: #10b981;
    font-weight: 600;
  }

  .pnl-negative {
    color: #ef4444;
    font-weight: 600;
  }

  .pnl-neutral {
    color: #6b7280;
  }

  .status-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
    font-weight: 600;
    display: inline-block;
  }

  .status-open {
    background: #10b98120;
    color: #10b981;
  }

  .status-closed {
    background: #64748b20;
    color: #64748b;
  }

  .status-synthetic {
    background: #f59e0b20;
    color: #f59e0b;
  }

  .position-row {
    cursor: pointer;
    transition: background-color 0.25s ease;
  }

  .position-row:hover {
    background-color: rgba(59, 130, 246, 0.08);
  }

  .position-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.72);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 24px;
    z-index: 900;
  }

  .position-modal-overlay.active {
    display: flex;
  }

  .position-modal {
    width: min(960px, 95vw);
    max-height: 90vh;
    background: var(--bg-primary);
    border-radius: 16px;
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .position-modal-header {
    padding: 20px 24px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
  }

  .position-modal-header-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .position-modal-header h2 {
    margin: 0;
    font-size: 1.25rem;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .position-modal-body {
    padding: 20px 24px 28px;
    overflow-y: auto;
    display: grid;
    gap: 18px;
  }

  .position-section {
    background: var(--bg-secondary);
    border-radius: 12px;
    padding: 16px 18px;
    border: 1px solid rgba(148, 163, 184, 0.16);
  }

  .position-section h3 {
    margin: 0 0 12px 0;
    font-size: 1rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .position-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px 18px;
  }

  .position-metric {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .position-metric-label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-muted);
  }

  .position-metric-value {
    font-size: 1rem;
    font-weight: 600;
  }

  .position-modal-close {
    background: transparent;
    border: none;
    color: var(--text-muted);
    font-size: 1.75rem;
    cursor: pointer;
    line-height: 1;
  }

  .position-modal-header .status-badge {
    font-size: 0.75rem;
  }

  @media (max-width: 720px) {
    .position-modal-body {
      padding: 18px;
      gap: 14px;
    }

    .position-modal-header {
      padding: 18px;
    }

    .position-modal {
      width: 100%;
      max-height: 92vh;
    }
  }
</style>
<div class="page-table">
  <div class="toolbar">
    <span style="font-weight: 600">üí∞ Positions</span>
    <select
      id="statusFilter"
      onchange="onPositionsStatusChanged()"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="all">All</option>
      <option value="open" selected>Open</option>
      <option value="closed">Closed</option>
    </select>
    <input
      type="text"
      id="searchInput"
      placeholder="Search symbol, name, or mint"
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.9em;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <div class="spacer"></div>
    <span
      id="positionCount"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button onclick="refreshPositions()" class="btn btn-primary">
      üîÑ Refresh
    </button>
  </div>
  <div class="table-wrap">
    <table class="table" id="positionsTable">
      <thead>
        <tr>
          <th style="min-width: 80px">Status</th>
          <th style="min-width: 100px">Symbol</th>
          <th style="min-width: 150px">Name</th>
          <th style="min-width: 120px">Entry Price</th>
          <th style="min-width: 120px">Current/Exit</th>
          <th style="min-width: 100px">Size (SOL)</th>
          <th style="min-width: 120px">P&L</th>
          <th style="min-width: 120px">P&L %</th>
          <th style="min-width: 150px">Entry Time</th>
          <th style="min-width: 100px">Actions</th>
        </tr>
      </thead>
      <tbody id="positionsTableBody">
        <tr>
          <td
            colspan="10"
            style="text-align: center; padding: 20px; color: #64748b"
          >
            Loading positions...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div
  class="position-modal-overlay"
  id="positionModal"
  onclick="closePositionModal(event)"
>
  <div
    class="position-modal"
    role="dialog"
    aria-modal="true"
    aria-labelledby="positionModalTitle"
    onclick="event.stopPropagation()"
  >
    <div class="position-modal-header">
      <h2 id="positionModalTitle">
        <span id="positionModalSymbol">‚Äî</span>
        <span
          id="positionModalName"
          style="font-size: 0.85rem; color: var(--text-secondary)"
        >
          ‚Äî
        </span>
      </h2>
      <div class="position-modal-header-right">
        <span class="status-badge" id="positionModalStatus">OPEN</span>
        <button
          class="position-modal-close"
          type="button"
          aria-label="Close"
          onclick="closePositionModal()"
        >
          √ó
        </button>
      </div>
    </div>
    <div class="position-modal-body">
      <div class="position-section">
        <h3>Overview</h3>
        <div class="position-grid">
          <div class="position-metric">
            <span class="position-metric-label">Mint</span>
            <span class="position-metric-value" id="positionMint">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Position Id</span>
            <span class="position-metric-value" id="positionId">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Current State</span>
            <span class="position-metric-value" id="positionState">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Strategy</span>
            <span class="position-metric-value" id="positionStrategy">‚Äî</span>
          </div>
        </div>
      </div>
      <div class="position-section">
        <h3>Entry</h3>
        <div class="position-grid">
          <div class="position-metric">
            <span class="position-metric-label">Entry Price (SOL)</span>
            <span class="position-metric-value" id="positionEntryPrice">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Entry Size (SOL)</span>
            <span class="position-metric-value" id="positionEntrySize">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Entry Timestamp</span>
            <span class="position-metric-value" id="positionEntryTime">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Entry Signature</span>
            <span class="position-metric-value" id="positionEntrySig">‚Äî</span>
          </div>
        </div>
      </div>
      <div class="position-section" id="positionCurrentSection">
        <h3>Current</h3>
        <div class="position-grid">
          <div class="position-metric">
            <span class="position-metric-label">Current Price (SOL)</span>
            <span class="position-metric-value" id="positionCurrentPrice"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Updated</span>
            <span class="position-metric-value" id="positionCurrentUpdated"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Unrealized P&L</span>
            <span class="position-metric-value" id="positionUnrealizedPnl"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Unrealized P&L %</span>
            <span class="position-metric-value" id="positionUnrealizedPercent"
              >‚Äî</span
            >
          </div>
        </div>
      </div>
      <div class="position-section" id="positionExitSection">
        <h3>Exit</h3>
        <div class="position-grid">
          <div class="position-metric">
            <span class="position-metric-label">Exit Price (SOL)</span>
            <span class="position-metric-value" id="positionExitPrice">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">SOL Received</span>
            <span class="position-metric-value" id="positionSolReceived"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Realized P&L</span>
            <span class="position-metric-value" id="positionRealizedPnl"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Realized P&L %</span>
            <span class="position-metric-value" id="positionRealizedPercent"
              >‚Äî</span
            >
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Exit Timestamp</span>
            <span class="position-metric-value" id="positionExitTime">‚Äî</span>
          </div>
          <div class="position-metric">
            <span class="position-metric-label">Exit Signature</span>
            <span class="position-metric-value" id="positionExitSig">‚Äî</span>
          </div>
        </div>
      </div>
      <div class="position-section">
        <h3>Links</h3>
        <div class="position-grid" style="gap: 10px 12px">
          <button
            class="btn btn-secondary"
            type="button"
            onclick="copyPositionMint()"
          >
            üìã Copy Mint
          </button>
          <button
            class="btn btn-secondary"
            type="button"
            onclick="openPositionGMGN()"
          >
            üîó Open GMGN
          </button>
          <button
            class="btn btn-secondary"
            type="button"
            onclick="openPositionDexScreener()"
          >
            üìä Open DexScreener
          </button>
          <button
            class="btn btn-secondary"
            type="button"
            onclick="openPositionSolscan()"
          >
            üîç Open Solscan
          </button>
          <button
            class="btn btn-secondary"
            type="button"
            onclick="copyPositionDebug()"
          >
            üêõ Copy Debug Info
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var positionsStore =
    window.positionsStore instanceof Map ? window.positionsStore : new Map();
  window.positionsStore = positionsStore;

  var positionModalState = window.positionModalState || {
    currentKey: null,
    keydownHandler: null,
  };
  window.positionModalState = positionModalState;

  function getPositionFromStore(key) {
    if (!key) {
      return null;
    }
    try {
      return positionsStore.get(key) || null;
    } catch (_) {
      return null;
    }
  }

  function setPositionModalText(id, value) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = value;
  }

  function formatPositionTimestamp(value) {
    if (typeof Utils !== "undefined" && Utils?.formatTimeFromSeconds) {
      return Utils.formatTimeFromSeconds(value, { fallback: "‚Äî" });
    }
    if (!Number.isFinite(value)) return "‚Äî";
    const date = new Date(value * 1000);
    if (Number.isNaN(date.getTime())) {
      return "‚Äî";
    }
    return date.toLocaleString();
  }

  function formatPositionPrice(value) {
    if (typeof Utils !== "undefined" && Utils?.formatPriceSol) {
      return Utils.formatPriceSol(value, { fallback: "‚Äî" });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    return num.toFixed(12);
  }

  function formatPositionSol(value) {
    if (typeof Utils !== "undefined" && Utils?.formatSol) {
      return Utils.formatSol(value, { decimals: 4, fallback: "‚Äî" });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    return `${num.toFixed(4)} SOL`;
  }

  function formatPositionPnL(value) {
    if (typeof Utils !== "undefined" && Utils?.formatPnL) {
      return Utils.formatPnL(value, { decimals: 4, fallback: "‚Äî" });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    return `${num >= 0 ? "+" : ""}${num.toFixed(4)} SOL`;
  }

  function formatPositionPercent(value) {
    if (typeof Utils !== "undefined" && Utils?.formatPercent) {
      return Utils.formatPercent(value, {
        style: "pnl",
        decimals: 2,
        fallback: "‚Äî",
      });
    }
    const num = Number(value);
    if (!Number.isFinite(num)) return "‚Äî";
    return `${num.toFixed(2)}%`;
  }

  function getPositionStatusInfo(position) {
    if (!position) {
      return {
        label: "Unknown",
        className: "status-closed",
        state: "Unknown",
      };
    }
    if (position.synthetic_exit) {
      return {
        label: "Synthetic",
        className: "status-synthetic",
        state: "Synthetic Exit",
      };
    }
    if (position.transaction_exit_verified) {
      return {
        label: "Closed",
        className: "status-closed",
        state: "Closed",
      };
    }
    return {
      label: "Open",
      className: "status-open",
      state: "Open",
    };
  }

  function applyStatusBadge(element, info) {
    if (!element || !info) return;
    element.classList.remove(
      "status-open",
      "status-closed",
      "status-synthetic"
    );
    element.classList.add(info.className);
    element.textContent = info.label.toUpperCase();
  }

  function populatePositionModal(position) {
    if (!position) {
      resetPositionModal();
      return;
    }

    setPositionModalText("positionModalSymbol", position.symbol || "‚Äî");
    setPositionModalText("positionModalName", position.name || "‚Äî");
    setPositionModalText("positionMint", position.mint || "‚Äî");
    setPositionModalText(
      "positionId",
      position.id !== undefined && position.id !== null
        ? String(position.id)
        : "‚Äî"
    );
    const statusInfo = getPositionStatusInfo(position);
    const statusEl = document.getElementById("positionModalStatus");
    applyStatusBadge(statusEl, statusInfo);
    setPositionModalText("positionState", statusInfo.state);
    setPositionModalText(
      "positionStrategy",
      position.strategy || position.strategy_id || "‚Äî"
    );

    setPositionModalText(
      "positionEntryPrice",
      formatPositionPrice(
        position.effective_entry_price || position.entry_price
      )
    );
    setPositionModalText(
      "positionEntrySize",
      formatPositionSol(position.entry_size_sol)
    );
    setPositionModalText(
      "positionEntryTime",
      formatPositionTimestamp(position.entry_time)
    );
    setPositionModalText(
      "positionEntrySig",
      position.entry_signature ? truncateAddress(position.entry_signature) : "‚Äî"
    );

    setPositionModalText(
      "positionCurrentPrice",
      formatPositionPrice(position.current_price)
    );
    setPositionModalText(
      "positionCurrentUpdated",
      formatPositionTimestamp(position.current_price_updated)
    );
    setPositionModalText(
      "positionUnrealizedPnl",
      formatPositionPnL(position.unrealized_pnl)
    );
    setPositionModalText(
      "positionUnrealizedPercent",
      formatPositionPercent(position.unrealized_pnl_percent)
    );

    setPositionModalText(
      "positionExitPrice",
      formatPositionPrice(position.effective_exit_price || position.exit_price)
    );
    setPositionModalText(
      "positionSolReceived",
      formatPositionSol(position.sol_received)
    );
    setPositionModalText(
      "positionRealizedPnl",
      formatPositionPnL(position.pnl)
    );
    setPositionModalText(
      "positionRealizedPercent",
      formatPositionPercent(position.pnl_percent)
    );
    setPositionModalText(
      "positionExitTime",
      formatPositionTimestamp(position.exit_time)
    );
    setPositionModalText(
      "positionExitSig",
      position.exit_signature ? truncateAddress(position.exit_signature) : "‚Äî"
    );

    const currentSection = document.getElementById("positionCurrentSection");
    const exitSection = document.getElementById("positionExitSection");
    if (currentSection) {
      currentSection.style.display = position.transaction_exit_verified
        ? "none"
        : "block";
    }
    if (exitSection) {
      exitSection.style.display = position.transaction_exit_verified
        ? "block"
        : "none";
    }
  }

  function resetPositionModal() {
    [
      "positionModalSymbol",
      "positionModalName",
      "positionMint",
      "positionId",
      "positionState",
      "positionStrategy",
      "positionEntryPrice",
      "positionEntrySize",
      "positionEntryTime",
      "positionEntrySig",
      "positionCurrentPrice",
      "positionCurrentUpdated",
      "positionUnrealizedPnl",
      "positionUnrealizedPercent",
      "positionExitPrice",
      "positionSolReceived",
      "positionRealizedPnl",
      "positionRealizedPercent",
      "positionExitTime",
      "positionExitSig",
    ].forEach((id) => setPositionModalText(id, "‚Äî"));

    const statusEl = document.getElementById("positionModalStatus");
    if (statusEl) {
      applyStatusBadge(statusEl, {
        label: "Open",
        className: "status-open",
        state: "Open",
      });
    }
    const currentSection = document.getElementById("positionCurrentSection");
    const exitSection = document.getElementById("positionExitSection");
    if (currentSection) currentSection.style.display = "block";
    if (exitSection) exitSection.style.display = "block";
  }

  function handlePositionModalKeyDown(event) {
    if (event.key === "Escape") {
      closePositionModal();
    }
  }

  function ensurePositionModalKeyListener() {
    if (positionModalState.keydownHandler) {
      return;
    }
    positionModalState.keydownHandler = handlePositionModalKeyDown;
    document.addEventListener("keydown", positionModalState.keydownHandler);
  }

  function removePositionModalKeyListener() {
    if (!positionModalState.keydownHandler) {
      return;
    }
    document.removeEventListener("keydown", positionModalState.keydownHandler);
    positionModalState.keydownHandler = null;
  }

  function openPositionDetail(key) {
    const position = getPositionFromStore(key);
    if (!position) {
      return;
    }
    positionModalState.currentKey = key;
    populatePositionModal(position);
    const overlay = document.getElementById("positionModal");
    if (overlay) {
      overlay.classList.add("active");
    }
    ensurePositionModalKeyListener();
  }

  function getCurrentPosition() {
    return getPositionFromStore(positionModalState.currentKey);
  }

  function closePositionModal(event) {
    if (event && event.target && event.currentTarget) {
      if (event.target !== event.currentTarget && event.type === "click") {
        return;
      }
    }
    const overlay = document.getElementById("positionModal");
    if (overlay) {
      overlay.classList.remove("active");
    }
    positionModalState.currentKey = null;
    removePositionModalKeyListener();
    resetPositionModal();
  }

  function refreshOpenPositionModal() {
    if (!positionModalState.currentKey) {
      return;
    }
    const position = getCurrentPosition();
    if (!position) {
      closePositionModal();
      return;
    }
    populatePositionModal(position);
  }

  function copyPositionMint() {
    const position = getCurrentPosition();
    if (!position || !position.mint || !Utils?.copyMint) return;
    Utils.copyMint(position.mint);
  }

  function openPositionGMGN() {
    const position = getCurrentPosition();
    if (!position || !position.mint || !Utils?.openGMGN) return;
    Utils.openGMGN(position.mint);
  }

  function openPositionDexScreener() {
    const position = getCurrentPosition();
    if (!position || !position.mint || !Utils?.openDexScreener) return;
    Utils.openDexScreener(position.mint);
  }

  function openPositionSolscan() {
    const position = getCurrentPosition();
    if (!position || !position.mint || !Utils?.openSolscan) return;
    Utils.openSolscan(position.mint);
  }

  function copyPositionDebug() {
    const position = getCurrentPosition();
    if (!position || !position.mint || !Utils?.copyDebugInfo) return;
    Utils.copyDebugInfo(position.mint, "position");
  }

  function handlePositionDropdown(event) {
    if (event?.stopPropagation) {
      event.stopPropagation();
    }
    if (Utils?.toggleDropdown) {
      Utils.toggleDropdown(event);
    }
  }

  function bindPositionRowClicks() {
    const rows = document.querySelectorAll(
      "#positionsTableBody tr[data-position-key]"
    );
    rows.forEach((row) => {
      if (row.dataset.clickBound === "1") {
        return;
      }
      row.addEventListener("click", (event) => {
        if (
          event?.target?.closest &&
          event.target.closest(".dropdown-container")
        ) {
          return;
        }
        const key = row.getAttribute("data-position-key");
        if (key) {
          openPositionDetail(key);
        }
      });
      row.dataset.clickBound = "1";
    });
  }

  window.openPositionDetail = openPositionDetail;
  window.closePositionModal = closePositionModal;
  window.copyPositionMint = copyPositionMint;
  window.openPositionGMGN = openPositionGMGN;
  window.openPositionDexScreener = openPositionDexScreener;
  window.openPositionSolscan = openPositionSolscan;
  window.copyPositionDebug = copyPositionDebug;
  window.handlePositionDropdown = handlePositionDropdown;

  // Truncate address
  function truncateAddress(address) {
    if (!address) return "-";
    return (
      address.substring(0, 8) + "..." + address.substring(address.length - 6)
    );
  }

  function getCurrentStatusFilter() {
    const select = document.getElementById("statusFilter");
    return select ? select.value : "all";
  }

  function getSearchTerm() {
    const input = document.getElementById("searchInput");
    return input ? input.value.toLowerCase().trim() : "";
  }

  function isDropdownOpen() {
    return Boolean(document.querySelector(".dropdown-menu.show"));
  }

  function parsePossibleTimestamp(value) {
    if (value === null || value === undefined) return null;
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (typeof value === "string" && value.trim() !== "") {
      const numeric = Number(value);
      if (Number.isFinite(numeric)) {
        return numeric;
      }

      const parsed = Date.parse(value);
      if (Number.isFinite(parsed)) {
        return Math.floor(parsed / 1000);
      }
    }
    return null;
  }

  function toFiniteNumber(value) {
    try {
      if (
        typeof Utils !== "undefined" &&
        Utils &&
        typeof Utils.coerceNumber === "function"
      ) {
        const coerced = Utils.coerceNumber(value);
        return Number.isFinite(coerced) ? coerced : null;
      }
    } catch (_) {}

    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  }

  function computeDerivedMetrics(position) {
    if (!position || typeof position !== "object") {
      return position;
    }

    const entrySize = toFiniteNumber(position.entry_size_sol);
    const entryPrice = toFiniteNumber(
      position.effective_entry_price ?? position.entry_price
    );
    const currentPrice = toFiniteNumber(position.current_price);
    const solReceived = toFiniteNumber(position.sol_received);
    const exitPrice = toFiniteNumber(
      position.effective_exit_price ?? position.exit_price
    );

    if (position.transaction_exit_verified) {
      let pnlValue = null;
      let pnlPercent = null;

      if (solReceived != null && entrySize != null) {
        pnlValue = solReceived - entrySize;
        if (entrySize > 0) {
          pnlPercent = (pnlValue / entrySize) * 100;
        }
      } else if (exitPrice != null && entryPrice != null && entryPrice > 0) {
        pnlPercent = ((exitPrice - entryPrice) / entryPrice) * 100;
        if (entrySize != null) {
          pnlValue = entrySize * (pnlPercent / 100);
        }
      }

      if (pnlValue != null && Number.isFinite(pnlValue)) {
        position.pnl = pnlValue;
      } else if (position.pnl === undefined) {
        position.pnl = null;
      }

      if (pnlPercent != null && Number.isFinite(pnlPercent)) {
        position.pnl_percent = pnlPercent;
      } else if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }

      if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }
      if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }
    } else {
      let unrealizedValue = null;
      let unrealizedPercent = null;

      if (
        currentPrice != null &&
        entryPrice != null &&
        entryPrice > 0 &&
        entrySize != null
      ) {
        unrealizedPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
        unrealizedValue = entrySize * (unrealizedPercent / 100);
      }

      if (unrealizedValue != null && Number.isFinite(unrealizedValue)) {
        position.unrealized_pnl = unrealizedValue;
      } else if (position.unrealized_pnl === undefined) {
        position.unrealized_pnl = null;
      }

      if (unrealizedPercent != null && Number.isFinite(unrealizedPercent)) {
        position.unrealized_pnl_percent = unrealizedPercent;
      } else if (position.unrealized_pnl_percent === undefined) {
        position.unrealized_pnl_percent = null;
      }

      if (position.pnl === undefined) {
        position.pnl = null;
      }
      if (position.pnl_percent === undefined) {
        position.pnl_percent = null;
      }
    }

    return position;
  }

  function normalizePositionFromApi(raw) {
    if (!raw || typeof raw !== "object") return raw;
    const position = { ...raw };

    position.entry_time = parsePossibleTimestamp(position.entry_time);
    position.exit_time = parsePossibleTimestamp(position.exit_time);
    position.current_price_updated = parsePossibleTimestamp(
      position.current_price_updated
    );

    return computeDerivedMetrics(position);
  }

  function getPositionKey(position) {
    if (!position) return null;

    if (position.id !== undefined && position.id !== null) {
      return `id:${position.id}`;
    }

    if (position.mint) {
      const entry = position.entry_time ?? position.created_at ?? "";
      return `mint:${position.mint}:${entry}`;
    }

    return null;
  }

  function matchesStatusFilter(position, filterValue) {
    if (filterValue === "all") return true;
    const isOpen = !position.transaction_exit_verified;
    if (filterValue === "open") {
      return isOpen;
    }
    if (filterValue === "closed") {
      return !isOpen;
    }
    return true;
  }

  function matchesSearchFilter(position, searchTerm) {
    if (!searchTerm) return true;
    const fields = [position.symbol, position.name, position.mint];
    return fields.some(
      (field) => field && field.toLowerCase().includes(searchTerm)
    );
  }

  function renderPositionRow(pos) {
    const isOpen = !pos.transaction_exit_verified;
    const statusBadge = pos.synthetic_exit
      ? '<span class="status-badge status-synthetic">SYNTHETIC</span>'
      : isOpen
      ? '<span class="status-badge status-open">OPEN</span>'
      : '<span class="status-badge status-closed">CLOSED</span>';

    const currentOrExitPrice = isOpen
      ? pos.current_price
        ? Utils.formatNumber(pos.current_price, 8, {
            fallback: "-",
            useGrouping: false,
          })
        : "-"
      : pos.effective_exit_price || pos.exit_price
      ? Utils.formatNumber(pos.effective_exit_price || pos.exit_price, 8, {
          fallback: "-",
          useGrouping: false,
        })
      : "-";

    const pnl = isOpen ? pos.unrealized_pnl : pos.pnl;
    const pnlPercent = isOpen ? pos.unrealized_pnl_percent : pos.pnl_percent;

    return `
                <tr class="position-row" data-position-key="${
                  getPositionKey(pos) || ""
                }">
                    <td>${statusBadge}</td>
                    <td><strong>${pos.symbol}</strong></td>
                    <td style="font-size: 0.85em;">${pos.name}</td>
                    <td>${Utils.formatNumber(
                      pos.effective_entry_price || pos.entry_price,
                      8,
                      { fallback: "-", useGrouping: false }
                    )}</td>
                    <td>${currentOrExitPrice}</td>
                    <td>${Utils.formatSol(pos.entry_size_sol, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPnL(pnl, {
                      decimals: 4,
                      fallback: "-",
                    })}</td>
                    <td>${Utils.formatPercent(pnlPercent, {
                      style: "pnl",
                      decimals: 2,
                      fallback: "-",
                    })}</td>
                    <td style="font-size: 0.85em;">${Utils.formatTimeFromSeconds(
                      pos.entry_time,
                      { fallback: "-" }
                    )}</td>
                    <td>
                        <div class="dropdown-container">
              <button class="dropdown-btn" onclick="handlePositionDropdown(event)" aria-label="Actions">
                                ‚ãÆ
                            </button>
                            <div class="dropdown-menu">
                                <button onclick="Utils.copyDebugInfo('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üìã Copy Debug Info
                                </button>
                                <button onclick="Utils.copyMint('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìã Copy Mint
                                </button>
                                <button onclick="Utils.openGMGN('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîó Open GMGN
                                </button>
                                <button onclick="Utils.openDexScreener('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üìä Open DexScreener
                                </button>
                                <button onclick="Utils.openSolscan('${
                                  pos.mint
                                }')" class="dropdown-item">
                                    üîç Open Solscan
                                </button>
                                <button onclick="showDebugModal('${
                                  pos.mint
                                }', 'position')" class="dropdown-item">
                                    üêõ Debug Info
                                </button>
                            </div>
                        </div>
                    </td>
                </tr>
            `;
  }

  function updatePositionCount(count) {
    const label = document.getElementById("positionCount");
    if (!label) return;
    const value = Number.isFinite(count) ? count : positionsStore.size;
    label.textContent = `${value} ${value === 1 ? "position" : "positions"}`;
  }

  function renderEmptyState(message, color = "#64748b") {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; padding: 20px; color: ${color};">
                        ${message}
                    </td>
                </tr>
            `;
  }

  function renderPositionsTable() {
    const tbody = document.getElementById("positionsTableBody");
    if (!tbody) return;

    const controller = window.positionsController;
    const hasSnapshot = controller ? controller.hasInitialSnapshot : false;

    if (!hasSnapshot && positionsStore.size === 0) {
      renderEmptyState("Loading positions...");
      refreshOpenPositionModal();
      return;
    }

    if (
      positionsStore.size === 0 &&
      controller &&
      controller.lastErrorMessage
    ) {
      renderEmptyState(controller.lastErrorMessage, "#ef4444");
      updatePositionCount(0);
      refreshOpenPositionModal();
      return;
    }

    const statusFilter = getCurrentStatusFilter();
    const searchTerm = getSearchTerm();

    const rows = Array.from(positionsStore.values())
      .filter((pos) => matchesStatusFilter(pos, statusFilter))
      .filter((pos) => matchesSearchFilter(pos, searchTerm))
      .sort((a, b) => {
        const aTime = a.entry_time ?? 0;
        const bTime = b.entry_time ?? 0;
        return bTime - aTime;
      });

    if (rows.length === 0) {
      renderEmptyState("No positions found");
      updatePositionCount(0);
      refreshOpenPositionModal();
      return;
    }

    tbody.innerHTML = rows.map(renderPositionRow).join("");
    bindPositionRowClicks();
    refreshOpenPositionModal();
    updatePositionCount(rows.length);
  }

  const positionsController =
    window.positionsController ||
    (function () {
      let searchBound = false;

      const controller = {
        hasInitialSnapshot: positionsStore.size > 0,
        fetchLimit: 500,
        pollTimer: null,
        abortController: null,
        isFetching: false,
        isActive: false,
        lastErrorMessage: null,
        intervalChangeListener: null,

        activate() {
          if (this.isActive) {
            console.log(
              "[Positions] Controller already active; rendering cache"
            );
            renderPositionsTable();
            return;
          }

          this.isActive = true;
          this.bindSearchInput();
          this.lastErrorMessage = null;

          if (!this.hasInitialSnapshot || positionsStore.size === 0) {
            renderEmptyState("Loading positions...");
            updatePositionCount(0);
          } else {
            renderPositionsTable();
          }

          // Register interval change listener
          if (window.PollingManager && !this.intervalChangeListener) {
            this.intervalChangeListener = window.PollingManager.onChange(() => {
              if (this.isActive) {
                console.log(
                  "[Positions] Polling interval changed, restarting polling"
                );
                this.startPolling();
              }
            });
          }

          this.fetchPositions({
            reason: this.hasInitialSnapshot ? "resume" : "initial",
            showSpinner: !this.hasInitialSnapshot || positionsStore.size === 0,
          });
          this.startPolling();
        },

        teardown() {
          if (!this.isActive) {
            return;
          }
          console.log("[Positions] Tearing down controller");
          this.isActive = false;
          this.stopPolling();
          this.abortInFlight();
          closePositionModal();

          // Remove interval change listener
          if (this.intervalChangeListener && window.PollingManager) {
            window.PollingManager.removeListener(this.intervalChangeListener);
            this.intervalChangeListener = null;
          }
        },

        bindSearchInput() {
          if (searchBound) return;
          const searchInput = document.getElementById("searchInput");
          if (searchInput) {
            searchInput.addEventListener("input", () => {
              renderPositionsTable();
            });
            searchBound = true;
          }
        },

        startPolling() {
          if (!this.isActive) {
            return;
          }
          this.stopPolling();
          const interval = window.PollingManager.getInterval();
          const intervalId = setInterval(() => {
            this.fetchPositions({ reason: "poll" });
          }, interval);
          this.pollTimer = intervalId;
          if (window.Router && typeof Router.trackInterval === "function") {
            Router.trackInterval(intervalId);
          }
          console.log("[Positions] Started polling every", interval, "ms");
        },

        stopPolling() {
          if (this.pollTimer) {
            clearInterval(this.pollTimer);
            this.pollTimer = null;
            console.log("[Positions] Stopped polling");
          }
        },

        abortInFlight() {
          if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
            console.log("[Positions] Aborted in-flight request");
          }
        },

        handleStatusChange() {
          console.log(
            "[Positions] Status changed to",
            getCurrentStatusFilter()
          );
          this.stopPolling();
          this.abortInFlight();
          this.hasInitialSnapshot = false;
          this.lastErrorMessage = null;
          closePositionModal();
          positionsStore.clear();
          renderEmptyState("Loading positions...");
          updatePositionCount(0);
          this.fetchPositions({ reason: "filter", showSpinner: false }).finally(
            () => {
              if (this.isActive) {
                this.startPolling();
              }
            }
          );
        },

        handleManualRefresh() {
          console.log("[Positions] Manual refresh requested");
          this.stopPolling();
          this.abortInFlight();
          this.hasInitialSnapshot = false;
          this.lastErrorMessage = null;
          closePositionModal();
          positionsStore.clear();
          renderEmptyState("Refreshing positions...");
          updatePositionCount(0);
          this.fetchPositions({ reason: "manual", showSpinner: false }).finally(
            () => {
              if (this.isActive) {
                this.startPolling();
              }
            }
          );
        },

        async fetchPositions({ reason = "load", showSpinner = false } = {}) {
          if (!this.isActive && reason !== "initial") {
            return;
          }

          if (this.isFetching) {
            if (reason === "poll") {
              console.log(
                "[Positions] Skipping poll; request already in flight"
              );
              return;
            }
            this.abortInFlight();
          }

          const status = getCurrentStatusFilter();
          const params = new URLSearchParams();
          if (status && status !== "all") {
            params.set("status", status);
          }
          if (this.fetchLimit > 0) {
            params.set("limit", String(this.fetchLimit));
          }
          const query = params.toString();
          const url = `/api/positions${query ? `?${query}` : ""}`;

          if (showSpinner) {
            renderEmptyState("Loading positions...");
            updatePositionCount(0);
          }

          try {
            this.isFetching = true;
            this.abortController = new AbortController();
            console.log(`[Positions] Fetching positions (${reason}) via`, url);

            const response = await fetch(url, {
              signal: this.abortController.signal,
              headers: { "X-Requested-With": "fetch" },
            });
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const payload = await response.json();
            const nextStore = new Map();
            if (Array.isArray(payload)) {
              payload.forEach((raw) => {
                const normalized = normalizePositionFromApi(raw);
                const key = getPositionKey(normalized);
                if (key) {
                  nextStore.set(key, normalized);
                }
              });
            }

            this.lastErrorMessage = null;
            positionsStore.clear();
            nextStore.forEach((value, key) => {
              positionsStore.set(key, value);
            });

            this.hasInitialSnapshot = true;
            renderPositionsTable();
            console.log(
              `[Positions] Loaded ${positionsStore.size} positions (${reason})`
            );
          } catch (error) {
            if (error.name === "AbortError") {
              console.log("[Positions] Fetch aborted");
              return;
            }
            console.error("[Positions] Failed to fetch positions:", error);
            if (!this.hasInitialSnapshot || positionsStore.size === 0) {
              this.hasInitialSnapshot = true;
              this.lastErrorMessage = `Failed to load positions: ${error.message}`;
              renderEmptyState(this.lastErrorMessage, "#ef4444");
              updatePositionCount(0);
            }
          } finally {
            this.isFetching = false;
            this.abortController = null;
          }
        },
      };

      return controller;
    })();

  window.positionsController = positionsController;

  window.onPositionsStatusChanged = function () {
    if (window.positionsController) {
      window.positionsController.handleStatusChange();
    }
  };

  window.refreshPositions = function () {
    if (window.positionsController) {
      window.positionsController.handleManualRefresh();
    }
  };

  // Global init function for Router to call during SPA navigation
  window.initPositionsPage = function () {
    console.log("[Positions] Initializing page");
    if (!window.positionsController) {
      console.error("[Positions] Controller unavailable");
      return;
    }

    window.positionsController.activate();

    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => window.positionsController.teardown());
    }
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initPositionsPage();
</script>
