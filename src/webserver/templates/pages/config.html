<style>
  /* COMPACT PROFESSIONAL CONFIG UI */
  .config-toolbar {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    flex-wrap: wrap;
    align-items: center;
  }

  .search-box {
    flex: 1;
    min-width: 200px;
    position: relative;
  }

  .search-box input {
    width: 100%;
    padding: 6px 12px 6px 32px;
    background: rgba(20, 20, 35, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 6px;
    color: white;
    font-size: 13px;
  }

  .search-box::before {
    content: "üîç";
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0.6;
  }

  .toolbar-btn {
    padding: 6px 14px;
    background: rgba(30, 30, 50, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 6px;
    color: white;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .toolbar-btn:hover {
    background: rgba(40, 40, 60, 0.9);
    border-color: rgba(255, 255, 255, 0.3);
  }

  .toolbar-btn.primary {
    background: linear-gradient(135deg, #1565c0 0%, #0f4c81 100%);
    border: none;
  }

  .toolbar-btn.success {
    background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    border: none;
  }

  .toolbar-btn.danger {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    border: none;
  }

  .filter-chips {
    display: flex;
    gap: 6px;
  }

  .chip {
    padding: 4px 10px;
    background: rgba(20, 20, 35, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .chip.active {
    background: rgba(21, 101, 192, 0.3);
    border-color: #1565c0;
  }

  .config-card {
    background: rgba(30, 30, 50, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    margin-bottom: 12px;
    overflow: hidden;
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px;
    background: rgba(20, 20, 35, 0.4);
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    cursor: pointer;
    user-select: none;
  }

  .card-header h3 {
    margin: 0;
    font-size: 15px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .field-count {
    font-size: 11px;
    opacity: 0.6;
    font-weight: 400;
  }

  .expand-icon {
    font-size: 12px;
    transition: transform 0.2s;
  }

  .expand-icon.expanded {
    transform: rotate(180deg);
  }

  .card-body {
    display: none;
    padding: 8px;
  }

  .card-body.expanded {
    display: block;
  }

  .category {
    background: rgba(20, 20, 35, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    margin-bottom: 8px;
  }

  .category-header {
    padding: 8px 12px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .category-header:hover {
    background: rgba(255, 255, 255, 0.02);
  }

  .category-body {
    /* Vertical stacked layout for all fields */
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 8px;
  }

  .category-body.collapsed {
    display: none;
  }

  .field {
    background: rgba(15, 15, 25, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 5px;
    padding: 10px;
    transition: border-color 0.15s ease, background 0.15s ease;
  }

  .field:hover {
    background: rgba(20, 20, 35, 0.7);
    border-color: rgba(255, 255, 255, 0.14);
  }

  .field-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
  }

  .field-header label {
    font-size: 12px;
    font-weight: 500;
    color: #ddd;
  }

  .impact {
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 9px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .impact.critical {
    background: #f5576c;
    color: white;
  }

  .impact.high {
    background: #ffaa00;
    color: white;
  }

  .impact.medium {
    background: #4facfe;
    color: white;
  }

  .impact.low {
    background: #888;
    color: white;
  }

  .field input,
  .field select,
  .field textarea {
    width: 100%;
    padding: 5px 8px;
    background: rgba(10, 10, 20, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 4px;
    color: white;
    font-size: 13px;
    font-family: monospace;
  }

  .field textarea {
    min-height: 64px;
  }

  .field input:focus,
  .field select:focus,
  .field textarea:focus {
    outline: none;
    border-color: #1565c0;
    background: rgba(15, 15, 25, 0.9);
  }

  .field input.valid {
    border-color: #38ef7d;
  }

  .field input.invalid {
    border-color: #ef4444;
    background: rgba(239, 68, 68, 0.08);
  }

  .field-hint {
    font-size: 10px;
    color: #888;
    margin-top: 3px;
    line-height: 1.3;
  }

  .field-error {
    display: none;
    font-size: 10px;
    color: #f5576c;
    margin-top: 3px;
    font-weight: 500;
  }

  .field-error.visible {
    display: block;
  }

  .card-actions {
    display: flex;
    gap: 8px;
    padding: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.08);
  }

  .save-btn {
    flex: 1;
    padding: 8px 16px;
    background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    border: none;
    border-radius: 5px;
    color: white;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .save-btn:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 3px 10px rgba(56, 239, 125, 0.3);
  }

  .save-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .reset-btn {
    padding: 8px 16px;
    background: rgba(30, 30, 50, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 5px;
    color: white;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }

  .reset-btn:hover {
    background: rgba(40, 40, 60, 0.9);
  }

  .spinner {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .status {
    padding: 6px 10px;
    border-radius: 5px;
    font-size: 11px;
    margin-top: 8px;
    display: none;
  }

  .status.success {
    background: rgba(56, 239, 125, 0.15);
    border: 1px solid rgba(56, 239, 125, 0.4);
    color: #38ef7d;
  }

  .status.error {
    background: rgba(245, 87, 108, 0.15);
    border: 1px solid rgba(245, 87, 108, 0.4);
    color: #f5576c;
  }

  .status.visible {
    display: block;
  }

  /* Modal styles */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }

  .modal.visible {
    display: flex;
  }

  .modal-content {
    background: #1a1a2e;
    border-radius: 10px;
    max-width: 90%;
    max-height: 85%;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: rgba(30, 30, 50, 0.8);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .modal-header h3 {
    margin: 0;
    font-size: 16px;
  }

  .modal-close {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal-body {
    padding: 16px;
    overflow-y: auto;
  }

  .diff-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
  }

  .diff-table th {
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    text-align: left;
    font-weight: 600;
    font-size: 11px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .diff-table td {
    padding: 6px 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    font-family: monospace;
  }

  .diff-table .new-value {
    background: rgba(56, 239, 125, 0.1);
    color: #38ef7d;
  }

  .diff-table .old-value {
    background: rgba(245, 87, 108, 0.1);
    color: #f5576c;
  }
</style>

<!-- DYNAMIC CONFIG UI -->
<div class="config-toolbar">
  <div class="search-box">
    <input
      type="text"
      id="searchInput"
      placeholder="Search configurations..."
      oninput="filterConfigs(this.value)"
    />
  </div>
  <button class="toolbar-btn success" onclick="exportConfig()">
    üì• Export
  </button>
  <button
    class="toolbar-btn primary"
    onclick="document.getElementById('importFile').click()"
  >
    üì§ Import
  </button>
  <input
    type="file"
    id="importFile"
    style="display: none"
    accept=".json"
    onchange="importConfig(this.files[0])"
  />
  <button class="toolbar-btn primary" onclick="reloadConfig()">
    üîÑ Reload
  </button>
  <button class="toolbar-btn danger" onclick="resetConfig()">‚ö†Ô∏è Reset</button>
  <button class="toolbar-btn" onclick="viewDiff()">üìã Diff</button>
</div>

<div class="filter-chips">
  <div class="chip active" onclick="filterByImpact('all', this)">All</div>
  <div class="chip" onclick="filterByImpact('critical', this)">Critical</div>
  <div class="chip" onclick="filterByImpact('high', this)">High</div>
  <div class="chip" onclick="filterByImpact('medium', this)">Medium</div>
</div>

<div id="globalStatus" class="status"></div>
<div id="configContainer"></div>

<!-- Diff Modal -->
<div id="diffModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Configuration Differences</h3>
      <button class="modal-close" onclick="closeDiffModal()">√ó</button>
    </div>
    <div class="modal-body" id="diffModalBody">
      <p style="text-align: center; opacity: 0.6">Loading...</p>
    </div>
  </div>
</div>

<script>
  // COMPLETE DYNAMIC CONFIG UI IMPLEMENTATION - ALL 155 FIELDS
  // =============================================================================
  // CONFIGURATION METADATA - Single source of truth for all 155 fields
  // =============================================================================
  // CONFIGURATION METADATA - Loaded dynamically from backend
  let CONFIG_METADATA = {};
  let diffModalListenerAttached = false;

  const SECTION_ORDER = [
    "trader",
    "positions",
    "filtering",
    "swaps",
    "tokens",
    "rpc",
    "sol_price",
    "summary",
    "events",
    "webserver",
    "services",
    "monitoring",
    "ohlcv",
  ];

  const SECTION_ICON_MAP = {
    trader: "ü§ñ",
    positions: "ÔøΩ",
    filtering: "üîç",
    swaps: "üîÑ",
    tokens: "ü™ô",
    rpc: "üåê",
    sol_price: "üí≤",
    summary: "üìä",
    events: "üìù",
    webserver: "üñ•Ô∏è",
    services: "üõ†Ô∏è",
    monitoring: "üìà",
    ohlcv: "üïí",
  };

  const SECTION_TITLE_MAP = {
    rpc: "RPC",
    sol_price: "SOL Price",
    ohlcv: "OHLCV",
  };

  let SECTION_STATE = {};

  function formatSectionTitle(sectionName) {
    if (SECTION_TITLE_MAP[sectionName]) {
      return SECTION_TITLE_MAP[sectionName];
    }
    return sectionName
      .split("_")
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join(" ");
  }

  function isIntegerField(sectionName, fieldKey) {
    const fieldMeta = CONFIG_METADATA[sectionName]?.[fieldKey];
    return fieldMeta?.type === "integer";
  }

  async function fetchConfigMetadata() {
    try {
      const response = await fetch("/api/config/metadata");
      const result = await response.json();

      if (!response.ok) {
        throw new Error(
          result.error?.message || "Failed to load config metadata"
        );
      }

      CONFIG_METADATA = result.data || {};

      const sectionNames = Object.keys(CONFIG_METADATA).sort((a, b) => {
        const indexA = SECTION_ORDER.indexOf(a);
        const indexB = SECTION_ORDER.indexOf(b);
        const safeA = indexA === -1 ? Number.POSITIVE_INFINITY : indexA;
        const safeB = indexB === -1 ? Number.POSITIVE_INFINITY : indexB;
        if (safeA === safeB) {
          return a.localeCompare(b);
        }
        return safeA - safeB;
      });

      SECTION_STATE = {};
      sectionNames.forEach((sectionName) => {
        SECTION_STATE[sectionName] = {
          icon: SECTION_ICON_MAP[sectionName] || "‚öôÔ∏è",
          title: formatSectionTitle(sectionName),
          fields: Object.keys(CONFIG_METADATA[sectionName] || {}).length,
        };
      });
    } catch (error) {
      console.error("[Config] Metadata fetch failed", error);
      showStatus(
        document.getElementById("globalStatus"),
        "error",
        error.message || "Failed to load metadata"
      );
      throw error;
    }
  }

  // =============================================================================
  // DYNAMIC RENDERING ENGINE
  // =============================================================================

  function renderAllSections() {
    const container = document.getElementById("configContainer");
    container.innerHTML = "";

    for (const [sectionName, sectionInfo] of Object.entries(SECTION_STATE)) {
      container.innerHTML += renderSection(sectionName, sectionInfo);
    }
  }

  function renderSection(sectionName, sectionInfo) {
    const metadata = CONFIG_METADATA[sectionName];
    if (!metadata) return "";
    const fieldCount = sectionInfo.fields;

    // Group fields by category
    const categories = {};
    for (const [fieldKey, fieldMeta] of Object.entries(metadata)) {
      const cat = fieldMeta.category || "General";
      if (!categories[cat]) categories[cat] = [];
      categories[cat].push({ key: fieldKey, ...fieldMeta });
    }

    let html = `
        <div class="config-card" data-section="${sectionName}">
            <div class="card-header" onclick="toggleSection('${sectionName}')">
                <h3>
                    <span>${sectionInfo.icon}</span>
                    <span>${sectionInfo.title}</span>
          <span class="field-count">(${fieldCount} fields)</span>
                </h3>
                <span class="expand-icon" id="${sectionName}-icon">‚ñº</span>
            </div>
            <div class="card-body" id="${sectionName}-body">
    `;

    // Render categories
    for (const [catName, fields] of Object.entries(categories)) {
      html += renderCategory(sectionName, catName, fields);
    }

    // Card actions
    html += `
                <div class="card-actions">
                    <button class="save-btn" onclick="saveSection('${sectionName}')">üíæ Save</button>
                    <button class="reset-btn" onclick="resetSection('${sectionName}')">üîô Reset</button>
                </div>
                <div class="status" id="${sectionName}-status"></div>
            </div>
        </div>
    `;

    return html;
  }

  function renderCategory(sectionName, catName, fields) {
    const isAdvanced =
      catName.includes("Timeout") ||
      catName.includes("Delay") ||
      catName.includes("Advanced");
    const collapsedClass = isAdvanced ? " collapsed" : "";

    let html = `
        <div class="category">
            <div class="category-header" onclick="toggleCategory(this)">
                ${catName} (${fields.length})
                <span class="category-toggle">‚ñº</span>
            </div>
            <div class="category-body${collapsedClass}">
    `;

    fields.forEach((field) => {
      html += renderField(sectionName, field);
    });

    html += `
            </div>
        </div>
    `;

    return html;
  }

  function renderField(sectionName, field) {
    const fieldId = `${sectionName}_${field.key}`;
    const requiresInteger = isIntegerField(sectionName, field.key);
    let inputHTML = "";

    if (field.type === "boolean") {
      inputHTML = `
            <select id="${fieldId}" onchange="validateField(this)">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
            </select>
        `;
    } else if (field.type === "array") {
      inputHTML = `
            <textarea id="${fieldId}" rows="2" placeholder="Comma-separated values" oninput="validateField(this)"></textarea>
        `;
    } else if (field.type === "string") {
      inputHTML = `
            <input type="text" id="${fieldId}" oninput="validateField(this)">
        `;
    } else {
      // number
      const integerAttr = requiresInteger ? ' data-integer="true"' : "";
      const stepValue =
        field.step !== undefined ? field.step : requiresInteger ? 1 : undefined;
      inputHTML = `
            <input type="number" id="${fieldId}"
                ${field.min !== undefined ? `min="${field.min}"` : ""}
                ${field.max !== undefined ? `max="${field.max}"` : ""}
                ${stepValue !== undefined ? `step="${stepValue}"` : ""}
                oninput="validateField(this)"${integerAttr}>
        `;
    }

    return `
        <div class="field" data-impact="${field.impact}" data-field-key="${
      field.key
    }">
            <div class="field-header">
                <label>${field.label}${
      field.unit ? ` (${field.unit})` : ""
    }</label>
                <span class="impact ${field.impact}">${field.impact}</span>
            </div>
            ${inputHTML}
            <div class="field-hint">${field.hint}</div>
            <div class="field-error"></div>
        </div>
    `;
  }

  // =============================================================================
  // LOAD & SAVE FUNCTIONS
  // =============================================================================

  async function loadAllConfigs() {
    for (const sectionName of Object.keys(SECTION_STATE)) {
      await loadSection(sectionName);
    }
  }

  async function loadSection(sectionName) {
    try {
      const response = await fetch(`/api/config/${sectionName}`);
      const result = await response.json();

      if (result.data) {
        // Populate fields
        for (const [key, value] of Object.entries(result.data)) {
          const fieldId = `${sectionName}_${key}`;
          const input = document.getElementById(fieldId);
          if (input) {
            if (input.tagName === "SELECT") {
              input.value = value.toString();
            } else if (input.tagName === "TEXTAREA") {
              // Handle arrays
              input.value = Array.isArray(value) ? value.join(", ") : value;
            } else {
              input.value = value;
            }
            validateField(input);
          }
        }
      }
    } catch (error) {
      console.error(`Failed to load ${sectionName} config:`, error);
    }
  }

  async function saveSection(sectionName) {
    const btn = event.target;
    const statusDiv = document.getElementById(`${sectionName}-status`);

    // Validate first
    const body = document.getElementById(`${sectionName}-body`);
    const inputs = body.querySelectorAll("input, select, textarea");
    let hasErrors = false;

    inputs.forEach((input) => {
      if (!validateField(input)) hasErrors = true;
    });

    if (hasErrors) {
      showStatus(statusDiv, "error", "Fix validation errors first");
      return;
    }

    // Loading state
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner"></span> Saving...';

    try {
      // Collect data
      const updates = {};
      inputs.forEach((input) => {
        const key = input.id.replace(`${sectionName}_`, "");
        let value = input.value;
        const requiresInteger = input.dataset.integer === "true";

        if (input.type === "number") {
          value = requiresInteger ? parseInt(value, 10) : parseFloat(value);
        } else if (input.tagName === "SELECT") {
          value = value === "true";
        } else if (input.tagName === "TEXTAREA") {
          // Handle arrays
          value = value
            .split(",")
            .map((v) => v.trim())
            .filter((v) => v);
          // Try to convert to numbers if possible
          const numValue = value.map((v) => parseFloat(v));
          if (numValue.every((v) => !isNaN(v))) {
            value = numValue;
          }
        }

        updates[key] = value;
      });

      // Save
      const response = await fetch(`/api/config/${sectionName}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });

      const result = await response.json();

      if (response.ok) {
        showStatus(
          statusDiv,
          "success",
          result.message || "Saved successfully"
        );
        btn.innerHTML = "‚úÖ Saved";
        setTimeout(() => {
          btn.innerHTML = "üíæ Save";
        }, 2000);
      } else {
        throw new Error(result.error?.message || "Save failed");
      }
    } catch (error) {
      showStatus(statusDiv, "error", error.message);
      btn.innerHTML = "‚ùå Failed";
      setTimeout(() => {
        btn.innerHTML = "üíæ Save";
      }, 2000);
    } finally {
      btn.disabled = false;
    }
  }

  async function resetSection(sectionName) {
    if (
      !confirm(
        `Reset ${SECTION_STATE[sectionName].title} to last saved values?`
      )
    )
      return;
    await loadSection(sectionName);
    showStatus(
      document.getElementById(`${sectionName}-status`),
      "success",
      "Reset to saved values"
    );
  }

  // =============================================================================
  // VALIDATION
  // =============================================================================

  function validateField(input) {
    const [sectionName, ...keyParts] = input.id.split("_");
    const fieldKey = keyParts.join("_");
    const metadata = CONFIG_METADATA[sectionName]?.[fieldKey];

    if (!metadata) return true;

    const errorEl = input.parentElement.querySelector(".field-error");
    const errors = [];
    const requiresInteger = input.dataset.integer === "true";
    const isNumericField =
      metadata.type === "number" || metadata.type === "integer";

    if (isNumericField) {
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        errors.push("Must be a number");
      } else {
        if (metadata.min !== undefined && value < metadata.min) {
          errors.push(`Min: ${metadata.min}`);
        }
        if (metadata.max !== undefined && value > metadata.max) {
          errors.push(`Max: ${metadata.max}`);
        }
        if (
          (metadata.type === "integer" || requiresInteger) &&
          !Number.isInteger(value)
        ) {
          errors.push("Must be an integer");
        }
      }
    }

    if (errors.length > 0) {
      input.classList.add("invalid");
      input.classList.remove("valid");
      errorEl.textContent = errors.join(", ");
      errorEl.classList.add("visible");
      return false;
    } else {
      input.classList.remove("invalid");
      input.classList.add("valid");
      errorEl.classList.remove("visible");
      return true;
    }
  }

  // =============================================================================
  // SEARCH & FILTER
  // =============================================================================

  let currentImpactFilter = "all";

  function filterConfigs(query) {
    query = query.toLowerCase();

    document.querySelectorAll(".field").forEach((field) => {
      const label = field.querySelector("label").textContent.toLowerCase();
      const hint = field.querySelector(".field-hint").textContent.toLowerCase();
      const impactMatch =
        currentImpactFilter === "all" ||
        field.dataset.impact === currentImpactFilter;
      const textMatch = !query || label.includes(query) || hint.includes(query);

      field.style.display = impactMatch && textMatch ? "block" : "none";
    });

    // Hide empty categories
    document.querySelectorAll(".category").forEach((cat) => {
      const visibleFields = cat.querySelectorAll(
        '.field[style*="block"]'
      ).length;
      cat.style.display = visibleFields > 0 ? "block" : "none";
    });

    // Hide empty sections
    document.querySelectorAll(".config-card").forEach((card) => {
      const visibleCategories = card.querySelectorAll(
        '.category[style*="block"]'
      ).length;
      card.style.display = visibleCategories > 0 ? "block" : "none";
    });
  }

  function filterByImpact(level, el) {
    currentImpactFilter = level;

    const chips = document.querySelectorAll(".chip");
    chips.forEach((chip) => {
      chip.classList.remove("active");
    });

    if (el) {
      el.classList.add("active");
    }

    // Reapply filter
    const searchQuery = document.getElementById("searchInput").value;
    filterConfigs(searchQuery);
  }

  // =============================================================================
  // UTILITY FUNCTIONS
  // =============================================================================

  async function exportConfig() {
    try {
      const response = await fetch("/api/config");
      const config = await response.json();

      const blob = new Blob([JSON.stringify(config, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `screenerbot-config-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      showStatus(
        document.getElementById("globalStatus"),
        "error",
        "Export failed"
      );
    }
  }

  async function importConfig(file) {
    if (!file) return;

    try {
      const text = await file.text();
      const config = JSON.parse(text);

      if (
        !confirm(
          `Import configuration from ${file.name}? This will update ALL settings.`
        )
      ) {
        return;
      }

      const skippedKeys = ["timestamp"];

      // Update each section
      for (const [section, data] of Object.entries(config)) {
        if (
          skippedKeys.includes(section) ||
          typeof data !== "object" ||
          data === null
        ) {
          continue;
        }

        try {
          await fetch(`/api/config/${section}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });
        } catch (sectionError) {
          console.error(`Failed to import section ${section}:`, sectionError);
        }
      }

      showStatus(
        document.getElementById("globalStatus"),
        "success",
        "Config imported"
      );
      await loadAllConfigs();
    } catch (error) {
      showStatus(
        document.getElementById("globalStatus"),
        "error",
        `Import failed: ${error.message}`
      );
    }
  }

  async function reloadConfig() {
    if (
      !confirm("Reload configuration from disk? Unsaved changes will be lost.")
    )
      return;

    try {
      const response = await fetch("/api/config/reload", { method: "POST" });
      const result = await response.json();

      if (response.ok) {
        showStatus(
          document.getElementById("globalStatus"),
          "success",
          "Reloaded from disk"
        );
        await loadAllConfigs();
      } else {
        throw new Error(result.error?.message || "Reload failed");
      }
    } catch (error) {
      showStatus(
        document.getElementById("globalStatus"),
        "error",
        error.message
      );
    }
  }

  async function resetConfig() {
    if (
      !confirm("‚ö†Ô∏è Reset ALL configuration to defaults? This CANNOT be undone!")
    )
      return;

    try {
      const response = await fetch("/api/config/reset", { method: "POST" });
      const result = await response.json();

      if (response.ok) {
        showStatus(
          document.getElementById("globalStatus"),
          "success",
          "Reset to defaults"
        );
        await loadAllConfigs();
      } else {
        throw new Error(result.error?.message || "Reset failed");
      }
    } catch (error) {
      showStatus(
        document.getElementById("globalStatus"),
        "error",
        error.message
      );
    }
  }

  async function viewDiff() {
    const modal = document.getElementById("diffModal");
    const body = document.getElementById("diffModalBody");

    modal.classList.add("visible");
    body.innerHTML = '<p style="text-align:center;opacity:0.6;">Loading...</p>';

    try {
      const response = await fetch("/api/config/diff");
      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error?.message || "Failed to fetch diff");
      }

      if (!result.has_changes) {
        body.innerHTML =
          '<p style="text-align:center;">No changes detected - memory and disk configs match</p>';
        return;
      }

      if (!result.memory || !result.disk) {
        body.innerHTML =
          '<p style="color:#f5576c;text-align:center;">Diff data unavailable</p>';
        return;
      }

      // Build diff table
      let diffRows = "";

      for (const [section, memData] of Object.entries(result.memory)) {
        if (!memData || typeof memData !== "object") continue;
        const diskData = result.disk[section] || {};
        const fieldKeys = new Set([
          ...Object.keys(memData),
          ...Object.keys(diskData),
        ]);

        fieldKeys.forEach((key) => {
          const memValue = memData[key];
          const diskValue = diskData[key];
          if (JSON.stringify(memValue) !== JSON.stringify(diskValue)) {
            diffRows += `
                        <tr>
                            <td>${section}</td>
                            <td>${key}</td>
                            <td class="new-value">${JSON.stringify(
                              memValue
                            )}</td>
                            <td class="old-value">${JSON.stringify(
                              diskValue
                            )}</td>
                        </tr>
                    `;
          }
        });
      }

      if (!diffRows) {
        body.innerHTML =
          '<p style="text-align:center;">Changes detected but could not be itemized.</p>';
        return;
      }

      body.innerHTML = `
            <table class="diff-table sticky-table">
                <thead>
                    <tr>
                        <th>Section</th>
                        <th>Field</th>
                        <th>Memory</th>
                        <th>Disk</th>
                    </tr>
                </thead>
                <tbody>
                    ${diffRows}
                </tbody>
            </table>
        `;
    } catch (error) {
      body.innerHTML = `<p style="color:#f5576c;text-align:center;">Error: ${error.message}</p>`;
    }
  }

  function closeDiffModal() {
    document.getElementById("diffModal").classList.remove("visible");
  }

  function toggleSection(sectionName) {
    const body = document.getElementById(`${sectionName}-body`);
    const icon = document.getElementById(`${sectionName}-icon`);

    body.classList.toggle("expanded");
    icon.classList.toggle("expanded");

    // Load when expanding
    if (body.classList.contains("expanded")) {
      loadSection(sectionName);
    }
  }

  function toggleCategory(header) {
    const body = header.nextElementSibling;
    const toggle = header.querySelector(".category-toggle");

    body.classList.toggle("collapsed");
    toggle.textContent = body.classList.contains("collapsed") ? "‚ñ∂" : "‚ñº";
  }

  function showStatus(element, type, message) {
    element.className = `status ${type} visible`;
    element.textContent = message;

    setTimeout(() => {
      element.classList.remove("visible");
    }, 5000);
  }

  // =============================================================================
  // INITIALIZATION
  // =============================================================================

  // Global init function for Router to call during SPA navigation
  window.initConfigPage = async function () {
    console.log("[Config] Initializing page");

    try {
      await fetchConfigMetadata();
    } catch (error) {
      return;
    }

    renderAllSections();

    // Close modal when clicking outside
    if (!diffModalListenerAttached) {
      document.addEventListener("click", (e) => {
        if (e.target.id === "diffModal") {
          closeDiffModal();
        }
      });
      diffModalListenerAttached = true;
    }
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initConfigPage();
</script>
