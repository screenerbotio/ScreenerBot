<div class="page-table">
  <div class="toolbar">
    <div class="toolbar-row toolbar-primary">
      <span class="toolbar-title">üì° Events</span>
      <div class="toolbar-field">
        <input
          type="text"
          id="eventSearch"
          placeholder="üîç Search events..."
          class="toolbar-input"
        />
      </div>
      <div class="toolbar-field">
        <select id="categoryFilter" class="toolbar-select">
          <option value="">All Categories</option>
          <option value="swap">Swap</option>
          <option value="transaction">Transaction</option>
          <option value="pool">Pool</option>
          <option value="token">Token</option>
          <option value="position">Position</option>
          <option value="security">Security</option>
          <option value="entry">Entry</option>
          <option value="system">System</option>
        </select>
      </div>
      <div class="toolbar-field">
        <select id="severityFilter" class="toolbar-select">
          <option value="">All Severity</option>
          <option value="info">Info</option>
          <option value="warn">Warning</option>
          <option value="error">Error</option>
          <option value="debug">Debug</option>
        </select>
      </div>
      <div class="toolbar-actions">
        <span id="eventsCountText" class="events-count">Loading...</span>
        <span id="eventsLastUpdated" class="events-last-updated"
          >Last update ‚Äî</span
        >
        <button id="toggleEventsPause" class="btn">‚è∏Ô∏è Pause</button>
        <button id="clearFilters" class="btn btn-secondary">üßπ Clear</button>
        <button id="refreshEvents" class="btn btn-primary">üîÑ Refresh</button>
      </div>
    </div>
    <div class="toolbar-row toolbar-secondary">
      <div class="quick-group">
        <span class="quick-label">Severity:</span>
        <button class="filter-chip active" data-severity-chip="">All</button>
        <button class="filter-chip" data-severity-chip="error">Errors</button>
        <button class="filter-chip" data-severity-chip="warn">Warnings</button>
        <button class="filter-chip" data-severity-chip="info">Info</button>
      </div>
      <div class="quick-group">
        <span class="quick-label">Category:</span>
        <button class="filter-chip active" data-category-chip="">All</button>
        <button class="filter-chip" data-category-chip="ohlcv">OHLCV</button>
        <button class="filter-chip" data-category-chip="security">
          Security
        </button>
        <button class="filter-chip" data-category-chip="pool">Pool</button>
      </div>
      <div class="quick-group">
        <span class="quick-label">Time:</span>
        <button class="filter-chip active" data-time-window="">All</button>
        <button class="filter-chip" data-time-window="5">Last 5m</button>
        <button class="filter-chip" data-time-window="30">30m</button>
        <button class="filter-chip" data-time-window="120">2h</button>
      </div>
    </div>
  </div>
  <style>
    .toolbar {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
    }

    .toolbar-primary {
      justify-content: flex-start;
      gap: 12px 16px;
    }

    .toolbar-secondary {
      justify-content: flex-start;
      gap: 16px;
    }

    .toolbar-title {
      font-weight: 600;
      color: var(--text-primary);
      min-width: 100px;
    }

    .toolbar-field {
      display: flex;
      flex: 1 1 180px;
      min-width: 160px;
    }

    .toolbar-input,
    .toolbar-select {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .toolbar-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-left: auto;
    }

    .events-count {
      color: var(--text-secondary);
      font-size: 0.9em;
    }

    .events-last-updated {
      color: var(--text-muted);
      font-size: 0.85em;
    }

    .quick-group {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .quick-label {
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .filter-chip {
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      color: var(--text-secondary);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.75em;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .filter-chip:hover,
    .filter-chip:focus {
      border-color: var(--link-color);
      color: var(--link-color);
      outline: none;
    }

    .filter-chip.active {
      background: var(--link-color);
      border-color: var(--link-color);
      color: #fff;
    }

    .event-ref-cell,
    .event-mint-cell {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: monospace;
    }

    .event-ref,
    .event-mint {
      color: var(--text-primary);
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .event-ref-copy,
    .event-mint-copy {
      background: none;
      border: none;
      color: var(--link-color);
      cursor: pointer;
      font-size: 0.8em;
      padding: 2px 4px;
      border-radius: 4px;
      transition: color 0.2s ease;
    }

    .event-ref-copy:hover,
    .event-ref-copy:focus,
    .event-mint-copy:hover,
    .event-mint-copy:focus {
      color: var(--link-hover);
      outline: none;
    }

    .event-message-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .event-message-text {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .event-detail-btn {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.75em;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .event-detail-btn:hover,
    .event-detail-btn:focus {
      color: var(--link-color);
      border-color: var(--link-color);
      outline: none;
    }

    .event-detail-modal {
      max-width: 720px;
      width: calc(100% - 48px);
    }

    .event-detail-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .event-detail-meta .meta-label {
      display: block;
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .event-detail-meta .meta-value {
      display: block;
      font-size: 0.9em;
      color: var(--text-primary);
      word-break: break-all;
      margin-top: 2px;
    }

    .meta-value-inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .meta-copy-btn {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.75em;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .meta-copy-btn:hover,
    .meta-copy-btn:focus {
      color: var(--link-color);
      border-color: var(--link-color);
      outline: none;
    }

    .severity-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 64px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.8em;
      font-weight: 600;
      text-transform: uppercase;
      color: #fff;
      background: #6b7280;
    }

    .event-detail-message {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .event-detail-message-text {
      flex: 1;
      min-width: 0;
      font-size: 0.95em;
      color: var(--text-primary);
      word-break: break-word;
    }

    .event-detail-summary {
      margin-bottom: 16px;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px 12px;
    }

    .summary-item {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .summary-key {
      font-size: 0.7em;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .summary-value {
      font-size: 0.9em;
      color: var(--text-primary);
      word-break: break-word;
    }

    .summary-empty {
      color: var(--text-muted);
      font-size: 0.9em;
    }

    .event-detail-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .event-detail-json-wrapper {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      max-height: 320px;
      overflow: auto;
    }

    .event-detail-json {
      margin: 0;
      padding: 12px;
      font-size: 0.85em;
      line-height: 1.4;
      color: var(--text-primary);
      white-space: pre;
    }
  </style>
  <div class="table-wrap">
    <table class="table" id="eventsTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Category</th>
          <th>Subtype</th>
          <th>Severity</th>
          <th>Mint</th>
          <th>Message</th>
          <th>Reference</th>
        </tr>
      </thead>
      <tbody id="eventsTableBody">
        <tr>
          <td
            colspan="7"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading events...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <div id="eventDetailModal" class="modal-overlay">
    <div class="modal-content event-detail-modal">
      <div class="modal-header">
        <span class="modal-title" id="eventDetailTitle">Event Details</span>
        <button
          id="eventDetailClose"
          class="modal-close"
          type="button"
          aria-label="Close"
        >
          √ó
        </button>
      </div>
      <div class="modal-body">
        <div class="event-detail-meta">
          <div>
            <span class="meta-label">Event ID</span>
            <span class="meta-value meta-value-inline">
              <span id="eventDetailId">-</span>
              <button
                class="meta-copy-btn"
                type="button"
                data-copy-target="id"
                title="Copy event ID"
              >
                üìã
              </button>
            </span>
          </div>
          <div>
            <span class="meta-label">Category</span>
            <span class="meta-value" id="eventDetailCategory">-</span>
          </div>
          <div>
            <span class="meta-label">Severity</span>
            <span class="meta-value">
              <span class="severity-pill" id="eventDetailSeverity">-</span>
            </span>
          </div>
          <div>
            <span class="meta-label">Subtype</span>
            <span class="meta-value" id="eventDetailSubtype">-</span>
          </div>
          <div>
            <span class="meta-label">Event Time</span>
            <span class="meta-value" id="eventDetailTime">-</span>
          </div>
          <div>
            <span class="meta-label">Created At</span>
            <span class="meta-value" id="eventDetailCreated">-</span>
          </div>
          <div>
            <span class="meta-label">Age</span>
            <span class="meta-value" id="eventDetailRelative">-</span>
          </div>
          <div>
            <span class="meta-label">Latency</span>
            <span class="meta-value" id="eventDetailLatency">-</span>
          </div>
          <div>
            <span class="meta-label">Reference</span>
            <span class="meta-value meta-value-inline">
              <span id="eventDetailReference">-</span>
              <button
                class="meta-copy-btn"
                type="button"
                data-copy-target="reference"
                title="Copy reference"
              >
                üìã
              </button>
            </span>
          </div>
          <div>
            <span class="meta-label">Mint</span>
            <span class="meta-value meta-value-inline">
              <span id="eventDetailMint">-</span>
              <button
                class="meta-copy-btn"
                type="button"
                data-copy-target="mint"
                title="Copy mint"
              >
                üìã
              </button>
            </span>
          </div>
        </div>
        <div class="event-detail-message">
          <span class="meta-label">Message</span>
          <div class="event-detail-message-text" id="eventDetailMessage">-</div>
          <button
            class="meta-copy-btn"
            type="button"
            data-copy-target="message"
            title="Copy message"
          >
            üìã
          </button>
        </div>
        <div class="event-detail-summary" id="eventDetailSummary"></div>
        <div class="event-detail-actions" id="eventDetailActions">
          <button
            class="btn btn-secondary"
            type="button"
            data-detail-action="copy-payload"
          >
            üìÑ Copy JSON
          </button>
          <button
            class="btn btn-secondary"
            type="button"
            data-detail-action="toggle-payload"
            id="eventDetailPayloadToggle"
          >
            ‚û°Ô∏è Compact JSON
          </button>
          <button
            class="btn"
            type="button"
            data-detail-action="filter-category"
          >
            üîç Filter Category
          </button>
          <button
            class="btn"
            type="button"
            data-detail-action="filter-reference"
          >
            üéØ Filter Reference
          </button>
          <button class="btn" type="button" data-detail-action="filter-mint">
            üß¨ Filter Mint
          </button>
        </div>
        <div class="event-detail-json-wrapper">
          <pre id="eventDetailPayload" class="event-detail-json">
Loading...</pre
          >
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var allEventsData = [];
  var maxEventId = 0;
  var connectionStatus = "connecting"; // 'connecting', 'connected', 'disconnected', 'error'
  var eventsStore = window.eventsStore || new Map();
  window.eventsStore = eventsStore;
  var EVENTS_BROWSER_LIMIT = 5000; // hard ceiling for historical records kept client-side
  var EVENT_MAX_RECORDS = EVENTS_BROWSER_LIMIT; // keep store aligned with browser ceiling
  var EVENTS_SCROLL_PAGE_SIZE = 200;
  var EVENTS_HEAD_LIMIT = 500; // initial snapshot size
  var EVENTS_SINCE_LIMIT = 250; // incremental refresh size
  var EVENTS_MIN_POLL_INTERVAL_MS = 2000;
  var searchDebounceHandle = null;
  var eventsPauseState = {
    paused: false,
    pending: false,
  };
  var eventsScrollState = {
    observer: null,
    loading: false,
    endReached: false,
    limitReached: false,
    pageSize: EVENTS_SCROLL_PAGE_SIZE,
    filteredEnd: false,
  };
  var eventsRenderState = {
    renderedIds: [],
    rowsById: new Map(),
    dirtyIds: new Set(),
    pending: false,
    rafId: null,
    forceFull: false,
    lastSearchTerm: "",
  };
  var eventsSnapshotState = {
    inProgress: false,
    totalAvailable: 0,
    received: 0,
    lastUpdatedAt: null,
  };
  var eventsFetchState = {
    headAbortController: null,
    sinceAbortController: null,
    headInFlight: false,
    sinceInFlight: false,
    pollIntervalId: null,
  };
  var eventsLifecycleState = {
    cleanupRegistered: false,
    intervalListener: null,
    statusIntervalId: null,
  };

  const eventsActiveFilters = {
    timeWindowMinutes: null,
  };

  const CATEGORY_LABELS = {
    swap: "Swap",
    transaction: "Transaction",
    pool: "Pool",
    learner: "Learner",
    token: "Token",
    system: "System",
    position: "Position",
    wallet: "Wallet",
    entry: "Entry",
    rpc: "RPC",
    security: "Security",
    ohlcv: "OHLCV",
    other: "Other",
  };

  const categoryOptionsCache = new Set();

  function formatCategoryLabel(category) {
    if (!category) return "Unknown";
    const normalized = String(category).toLowerCase();
    if (CATEGORY_LABELS[normalized]) {
      return CATEGORY_LABELS[normalized];
    }
    return String(category)
      .replace(/[_-]/g, " ")
      .replace(/\b\w/g, (ch) => ch.toUpperCase());
  }

  function hydrateCategoryOptionsCache() {
    const select = document.getElementById("categoryFilter");
    if (!select) return;
    Array.from(select.options).forEach((opt) => {
      if (typeof opt.value === "string" && opt.value.length) {
        categoryOptionsCache.add(opt.value.toLowerCase());
      }
    });
  }

  function ensureCategoryOption(category, label) {
    if (!category) return;
    const select = document.getElementById("categoryFilter");
    if (!select) return;
    const normalized = String(category).toLowerCase();
    if (categoryOptionsCache.has(normalized)) {
      return;
    }
    const option = document.createElement("option");
    option.value = normalized;
    option.textContent = label || formatCategoryLabel(category);
    select.appendChild(option);
    categoryOptionsCache.add(normalized);
  }

  hydrateCategoryOptionsCache();

  function parseDate(value) {
    if (!value) return null;
    const date = value instanceof Date ? value : new Date(value);
    return Number.isNaN(date.getTime()) ? null : date;
  }

  function formatLatencyMs(latencyMs) {
    if (!Number.isFinite(latencyMs) || latencyMs < 0) {
      return "‚Äî";
    }
    if (latencyMs < 1_000) {
      return `${Math.round(latencyMs)} ms`;
    }
    const seconds = latencyMs / 1_000;
    if (seconds < 60) {
      return `${seconds.toFixed(seconds < 10 ? 2 : 1)} s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remaining = Math.floor(seconds % 60);
    return `${minutes}m ${remaining}s`;
  }

  function hasActiveTimeWindow() {
    return eventsActiveFilters.timeWindowMinutes !== null;
  }

  function updateEventsLastUpdatedLabel() {
    const label = document.getElementById("eventsLastUpdated");
    if (!label) return;
    const timestamp = eventsSnapshotState.lastUpdatedAt;
    if (!timestamp) {
      label.textContent = "Last update ‚Äî";
      label.title = "";
      return;
    }
    const date = new Date(timestamp);
    const relative = Utils.formatTimeAgo(date, { fallback: "just now" });
    label.textContent = `Last update ${relative}`;
    label.title = Utils.formatTimestamp(date, { includeSeconds: true });
  }

  function updateTimeWindowChips() {
    const active = eventsActiveFilters.timeWindowMinutes;
    document.querySelectorAll("[data-time-window]").forEach((chip) => {
      const valueAttr = chip.getAttribute("data-time-window") || "";
      const numeric = valueAttr === "" ? null : Number(valueAttr);
      const isActive = numeric === null ? active === null : active === numeric;
      chip.classList.toggle("active", isActive);
    });
  }

  function syncSeverityChips() {
    const severity = document.getElementById("severityFilter")?.value || "";
    document.querySelectorAll("[data-severity-chip]").forEach((chip) => {
      const value = chip.getAttribute("data-severity-chip") || "";
      chip.classList.toggle("active", value === severity);
    });
  }

  function syncCategoryChips() {
    const category = document.getElementById("categoryFilter")?.value || "";
    document.querySelectorAll("[data-category-chip]").forEach((chip) => {
      const value = chip.getAttribute("data-category-chip") || "";
      chip.classList.toggle("active", value === category);
    });
  }

  function setTimeWindow(windowValue, options) {
    const opts = Object.assign({ save: true, silent: false }, options || {});
    let minutes = null;
    if (windowValue !== null && windowValue !== "") {
      const parsed = Number(windowValue);
      if (Number.isFinite(parsed) && parsed > 0) {
        minutes = parsed;
      }
    }

    if (eventsActiveFilters.timeWindowMinutes === minutes) {
      updateTimeWindowChips();
      return;
    }

    eventsActiveFilters.timeWindowMinutes = minutes;
    if (opts.save) {
      AppState.save(
        "events_time_window",
        minutes === null ? "" : String(minutes)
      );
    }

    eventsScrollState.filteredEnd = false;
    eventsScrollState.endReached = false;
    eventsScrollState.limitReached = false;
    updateTimeWindowChips();

    if (!opts.silent) {
      scheduleEventsRender({ forceFull: true });
    }
  }

  function resetEventsRenderState() {
    eventsRenderState.renderedIds = [];
    eventsRenderState.rowsById.clear();
    eventsRenderState.dirtyIds.clear();
    eventsRenderState.pending = false;
    if (eventsRenderState.rafId) {
      cancelAnimationFrame(eventsRenderState.rafId);
      eventsRenderState.rafId = null;
    }
    eventsRenderState.forceFull = false;
    eventsRenderState.lastSearchTerm = "";
  }

  function markEventDirty(eventId) {
    const idNum = Number(eventId);
    if (Number.isFinite(idNum)) {
      eventsRenderState.dirtyIds.add(idNum);
    }
  }

  function resetEventsScrollState() {
    if (eventsScrollState.observer) {
      eventsScrollState.observer.disconnect();
      eventsScrollState.observer = null;
    }
    eventsScrollState.loading = false;
    eventsScrollState.endReached = false;
    eventsScrollState.limitReached = false;
    eventsScrollState.filteredEnd = false;
  }

  function isEventsPaused() {
    return eventsPauseState.paused;
  }

  function updatePauseButtonUI() {
    const btn = document.getElementById("toggleEventsPause");
    if (!btn) return;
    const { paused, pending } = eventsPauseState;
    btn.disabled = pending;
    btn.classList.remove("btn-secondary");

    if (pending) {
      btn.textContent = paused ? "‚è≥ Resuming..." : "‚è≥ Pausing...";
      return;
    }

    if (paused) {
      btn.textContent = "‚ñ∂Ô∏è Resume";
      btn.classList.add("btn-secondary");
    } else {
      btn.textContent = "‚è∏Ô∏è Pause";
    }
  }

  function applyEventsPauseState(targetPaused, options) {
    const opts = Object.assign(
      {
        sendCommand: true,
        refreshSnapshot: !targetPaused,
        silent: false,
        force: false,
        message: null,
      },
      options || {}
    );

    if (eventsPauseState.pending) {
      return false;
    }

    if (!opts.force && eventsPauseState.paused === targetPaused) {
      if (opts.message) {
        const statusKey = targetPaused ? "paused" : "connected";
        updateConnectionStatus(statusKey, opts.message);
      }
      return true;
    }

    eventsPauseState.paused = targetPaused;
    AppState.save("events_paused", targetPaused ? "1" : "");
    updatePauseButtonUI();

    const statusMessage =
      opts.message ||
      (targetPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`);

    updateConnectionStatus(
      targetPaused ? "paused" : "connected",
      statusMessage
    );

    if (targetPaused) {
      if (eventsFetchState.sinceAbortController) {
        eventsFetchState.sinceAbortController.abort();
        eventsFetchState.sinceAbortController = null;
      }
      eventsFetchState.sinceInFlight = false;
      stopEventsPolling();
    } else {
      startEventsPolling();
      fetchEventsSince({ reason: "resume" });
    }

    return true;
  }

  // Update connection status indicator
  function updateConnectionStatus(status, message) {
    connectionStatus = status;
    const indicator = document.getElementById("eventsCountText");
    if (!indicator) return;
    const colors = {
      connecting: "var(--text-secondary)",
      connected: "var(--badge-online)",
      disconnected: "var(--badge-loading)",
      error: "var(--badge-error)",
      paused: "var(--badge-loading)",
    };
    const icons = {
      connecting: "‚è≥",
      connected: "‚úÖ",
      disconnected: "‚ö†Ô∏è",
      error: "‚ùå",
      paused: "‚è∏Ô∏è",
    };
    const defaults = {
      connecting: "Connecting‚Ä¶",
      connected: "Connected",
      disconnected: "Disconnected",
      error: "Error",
      paused: "Paused",
    };
    const icon = icons[status] || "‚ÑπÔ∏è";
    const text = message || defaults[status] || "Status unavailable";
    indicator.style.color = colors[status] || "var(--text-secondary)";
    indicator.textContent = `${icon} ${text}`;
    indicator.dataset.status = status;
    indicator.title = text;
  }

  function clearEventsCache() {
    resetEventsScrollState();
    resetEventsRenderState();
    eventsStore.clear();
    allEventsData = [];
    maxEventId = 0;
    eventsSnapshotState.totalAvailable = 0;
    eventsSnapshotState.received = 0;
    eventsSnapshotState.lastUpdatedAt = null;
    updateEventsLastUpdatedLabel();
    updateEventsScrollControls(false);
    eventsScrollState.filteredEnd = false;
    scheduleEventsRender({ forceFull: true, immediate: true });
  }

  function normalizeEvent(raw) {
    if (!raw || typeof raw !== "object") return null;
    const payload =
      raw.payload && typeof raw.payload === "object" ? raw.payload : {};
    const severity =
      typeof raw.severity === "string" ? raw.severity.toLowerCase() : "";
    const categoryRaw = typeof raw.category === "string" ? raw.category : "";
    const category = categoryRaw.toLowerCase();
    const categoryLabel = formatCategoryLabel(categoryRaw || category);
    const payloadMessage =
      typeof payload.message === "string" && payload.message.trim() !== ""
        ? payload.message
        : typeof payload.message_short === "string" &&
          payload.message_short.trim() !== ""
        ? payload.message_short
        : null;
    const rawMessage =
      typeof raw.message === "string" && raw.message.trim() !== ""
        ? raw.message
        : null;
    const message = rawMessage || payloadMessage || "No message";
    const mintCandidate =
      typeof raw.mint === "string" && raw.mint.trim() !== ""
        ? raw.mint
        : typeof payload.mint === "string" && payload.mint.trim() !== ""
        ? payload.mint
        : null;
    const referenceCandidate =
      typeof raw.reference_id === "string" && raw.reference_id.trim() !== ""
        ? raw.reference_id
        : typeof payload.reference_id === "string" &&
          payload.reference_id.trim() !== ""
        ? payload.reference_id
        : typeof payload.signature === "string" &&
          payload.signature.trim() !== ""
        ? payload.signature
        : null;
    const eventTimeIso =
      typeof raw.event_time === "string" ? raw.event_time : null;
    const createdAtIso =
      typeof raw.created_at === "string" ? raw.created_at : null;
    const eventTimeDate = parseDate(eventTimeIso);
    const createdAtDate = parseDate(createdAtIso);
    const latencyMs =
      eventTimeDate && createdAtDate
        ? Math.max(0, createdAtDate.getTime() - eventTimeDate.getTime())
        : null;
    const severityLabel = severity ? severity.toUpperCase() : "";
    return {
      ...raw,
      category,
      categoryLabel,
      severity,
      severityLabel,
      message,
      payload,
      mint: mintCandidate,
      reference_id: referenceCandidate,
      eventTimeIso,
      createdAtIso,
      eventTimeDate,
      createdAtDate,
      latencyMs,
    };
  }

  function hasEventChanged(existing, next) {
    if (!existing) return true;
    return (
      existing.message !== next.message ||
      existing.severity !== next.severity ||
      existing.category !== next.category ||
      existing.subtype !== next.subtype ||
      existing.reference_id !== next.reference_id ||
      existing.event_time !== next.event_time ||
      existing.mint !== next.mint ||
      JSON.stringify(existing.payload) !== JSON.stringify(next.payload)
    );
  }

  function matchesActiveFilters(event) {
    const category = document.getElementById("categoryFilter")?.value || "";
    const severity = document.getElementById("severityFilter")?.value || "";
    if (category && event.category !== category) return false;
    if (severity && event.severity !== severity) return false;
    if (eventsActiveFilters.timeWindowMinutes !== null) {
      const eventDate = event.eventTimeDate;
      if (!eventDate) return false;
      const cutoff =
        Date.now() - eventsActiveFilters.timeWindowMinutes * 60 * 1000;
      if (eventDate.getTime() < cutoff) return false;
    }
    return true;
  }

  function mergeEvents(events) {
    if (!Array.isArray(events) || events.length === 0) {
      return false;
    }

    let updated = false;
    for (const raw of events) {
      const event = normalizeEvent(raw);
      if (!event || typeof event.id !== "number") continue;
      ensureCategoryOption(event.category, event.categoryLabel);
      if (!matchesActiveFilters(event)) continue;
      const eventId = Number(event.id);
      const existing = eventsStore.get(eventId);
      if (hasEventChanged(existing, event)) {
        eventsStore.set(eventId, event);
        markEventDirty(eventId);
        updated = true;
      }
    }

    if (!updated) {
      return false;
    }

    const orderedIds = Array.from(eventsStore.keys()).sort((a, b) => b - a);
    if (orderedIds.length > EVENT_MAX_RECORDS) {
      for (let i = EVENT_MAX_RECORDS; i < orderedIds.length; i++) {
        eventsStore.delete(orderedIds[i]);
      }
      orderedIds.length = EVENT_MAX_RECORDS;
    }

    allEventsData = orderedIds.map((id) => eventsStore.get(id));
    eventsScrollState.limitReached =
      allEventsData.length >= EVENTS_BROWSER_LIMIT;
    if (!eventsScrollState.limitReached) {
      eventsScrollState.endReached = false;
    }
    eventsScrollState.filteredEnd = false;
    scheduleEventsRender();
    return true;
  }

  function buildEventsQueryParams(limit) {
    const params = new URLSearchParams();
    if (Number.isFinite(limit) && limit > 0) {
      params.set("limit", String(limit));
    }
    const category = document.getElementById("categoryFilter")?.value;
    const severity = document.getElementById("severityFilter")?.value;
    if (category) params.set("category", category);
    if (severity) params.set("severity", severity);
    return params;
  }

  function stopEventsPolling() {
    if (eventsFetchState.pollIntervalId) {
      clearInterval(eventsFetchState.pollIntervalId);
      eventsFetchState.pollIntervalId = null;
      console.log("[Events] Stopped polling");
    }
  }

  function startEventsPolling() {
    stopEventsPolling();
    if (isEventsPaused()) {
      return;
    }
    if (!Number.isFinite(maxEventId) || maxEventId <= 0) {
      return;
    }
    const baseInterval = window.PollingManager
      ? Math.max(
          window.PollingManager.getInterval(),
          EVENTS_MIN_POLL_INTERVAL_MS
        )
      : 5000;
    const intervalId = setInterval(() => {
      fetchEventsSince({ reason: "poll" });
    }, baseInterval);
    eventsFetchState.pollIntervalId = intervalId;
    if (window.Router && typeof Router.trackInterval === "function") {
      Router.trackInterval(intervalId);
    }
    console.log("[Events] Started polling every", baseInterval, "ms");
  }

  function ensureEventsLifecycle() {
    if (
      window.Router &&
      typeof Router.registerCleanup === "function" &&
      !eventsLifecycleState.cleanupRegistered
    ) {
      Router.registerCleanup(() => {
        teardownEventsPage();
      });
      eventsLifecycleState.cleanupRegistered = true;
    }

    if (
      window.PollingManager &&
      !eventsLifecycleState.intervalListener &&
      typeof window.PollingManager.onChange === "function"
    ) {
      eventsLifecycleState.intervalListener = window.PollingManager.onChange(
        () => {
          if (!isEventsPaused()) {
            startEventsPolling();
          }
        }
      );
    }

    if (!eventsLifecycleState.statusIntervalId) {
      const intervalId = setInterval(updateEventsLastUpdatedLabel, 30_000);
      eventsLifecycleState.statusIntervalId = intervalId;
      if (window.Router && typeof Router.trackInterval === "function") {
        Router.trackInterval(intervalId);
      }
    }
  }

  function teardownEventsPage() {
    stopEventsPolling();
    if (eventsFetchState.headAbortController) {
      eventsFetchState.headAbortController.abort();
      eventsFetchState.headAbortController = null;
    }
    if (eventsFetchState.sinceAbortController) {
      eventsFetchState.sinceAbortController.abort();
      eventsFetchState.sinceAbortController = null;
    }
    eventsFetchState.headInFlight = false;
    eventsFetchState.sinceInFlight = false;
    if (
      eventsLifecycleState.intervalListener &&
      window.PollingManager &&
      typeof window.PollingManager.removeListener === "function"
    ) {
      window.PollingManager.removeListener(
        eventsLifecycleState.intervalListener
      );
      eventsLifecycleState.intervalListener = null;
    }
    eventsLifecycleState.cleanupRegistered = false;

    if (eventsLifecycleState.statusIntervalId) {
      clearInterval(eventsLifecycleState.statusIntervalId);
      eventsLifecycleState.statusIntervalId = null;
    }
  }

  async function fetchEventsHead(options) {
    const opts = Object.assign(
      { message: null, limit: EVENTS_HEAD_LIMIT },
      options || {}
    );
    if (eventsFetchState.headInFlight && eventsFetchState.headAbortController) {
      eventsFetchState.headAbortController.abort();
    }

    const limit = Math.min(
      Number(opts.limit) || EVENTS_HEAD_LIMIT,
      EVENTS_BROWSER_LIMIT
    );
    const params = buildEventsQueryParams(limit);
    params.set("limit", String(limit));

    eventsFetchState.headAbortController = new AbortController();
    eventsFetchState.headInFlight = true;
    const statusMessage = opts.message || "Loading latest events...";
    updateConnectionStatus("connecting", statusMessage);

    let success = false;

    try {
      const res = await fetch(`/api/events/head?${params.toString()}`, {
        signal: eventsFetchState.headAbortController.signal,
        headers: { "X-Requested-With": "fetch" },
      });
      if (!res.ok) {
        throw new Error(`Failed to load events snapshot (${res.status})`);
      }

      const payload = await res.json();
      const rows = Array.isArray(payload?.events) ? payload.events : [];

      if (!rows.length) {
        eventsSnapshotState.totalAvailable = Number(payload?.count) || 0;
        eventsSnapshotState.received = 0;
        eventsSnapshotState.lastUpdatedAt = Date.now();
        updateEventsLastUpdatedLabel();
        updateConnectionStatus(
          isEventsPaused() ? "paused" : "connected",
          rows.length
            ? `Realtime ‚Ä¢ ${formatEventCountLabel(rows.length)}`
            : "No events found yet"
        );
        scheduleEventsRender({ forceFull: true, immediate: true });
        success = true;
      } else {
        mergeEvents(rows);

        const responseMaxId = Number(payload?.max_id);
        if (Number.isFinite(responseMaxId) && responseMaxId > 0) {
          maxEventId = responseMaxId;
        } else {
          const highestFromRows = rows.reduce((acc, row) => {
            const id = Number(row?.id);
            return Number.isFinite(id) && id > acc ? id : acc;
          }, 0);
          if (highestFromRows > 0) {
            maxEventId = highestFromRows;
          }
        }

        eventsSnapshotState.totalAvailable = Math.max(
          Number(payload?.count) || rows.length,
          allEventsData.length
        );
        eventsSnapshotState.received = allEventsData.length;
        eventsSnapshotState.lastUpdatedAt = Date.now();
        updateEventsLastUpdatedLabel();

        const activeStatus = isEventsPaused() ? "paused" : "connected";
        updateConnectionStatus(
          activeStatus,
          activeStatus === "paused"
            ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
            : `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        );

        scheduleEventsRender({ forceFull: true, immediate: true });
        success = true;
      }
    } catch (err) {
      if (err.name === "AbortError") {
        console.log("[Events] Snapshot fetch aborted");
      } else {
        console.error("[Events] Failed to fetch events snapshot", err);
        updateConnectionStatus("error", "Failed to load events snapshot");
        if (window.Utils && typeof Utils.showToast === "function") {
          Utils.showToast("‚ùå Failed to load events snapshot", "error");
        }
      }
    } finally {
      eventsSnapshotState.inProgress = false;
      eventsFetchState.headInFlight = false;
      eventsFetchState.headAbortController = null;
    }

    return success;
  }

  async function fetchEventsSince(options) {
    const opts = Object.assign({ reason: "poll" }, options || {});
    if (eventsFetchState.sinceInFlight) {
      return;
    }
    if (!Number.isFinite(maxEventId) || maxEventId <= 0) {
      return;
    }
    if (isEventsPaused()) {
      return;
    }

    const params = buildEventsQueryParams(EVENTS_SINCE_LIMIT);
    params.set("after_id", String(maxEventId));

    eventsFetchState.sinceAbortController = new AbortController();
    eventsFetchState.sinceInFlight = true;

    try {
      const res = await fetch(`/api/events/since?${params.toString()}`, {
        signal: eventsFetchState.sinceAbortController.signal,
        headers: { "X-Requested-With": "fetch" },
      });
      if (!res.ok) {
        throw new Error(`Failed to load incremental events (${res.status})`);
      }

      const payload = await res.json();
      const rows = Array.isArray(payload?.events) ? payload.events : [];
      if (!rows.length) {
        return;
      }

      const merged = mergeEvents(rows);
      if (!merged) {
        return;
      }

      const responseMaxId = Number(payload?.max_id);
      if (Number.isFinite(responseMaxId) && responseMaxId > maxEventId) {
        maxEventId = responseMaxId;
      } else {
        const highestFromRows = rows.reduce((acc, row) => {
          const id = Number(row?.id);
          return Number.isFinite(id) && id > acc ? id : acc;
        }, maxEventId);
        if (highestFromRows > maxEventId) {
          maxEventId = highestFromRows;
        }
      }

      eventsSnapshotState.totalAvailable = Math.max(
        Number(payload?.count) || rows.length,
        eventsSnapshotState.totalAvailable || 0,
        allEventsData.length
      );
      eventsSnapshotState.received = allEventsData.length;
      eventsSnapshotState.lastUpdatedAt = Date.now();
      updateEventsLastUpdatedLabel();

      updateConnectionStatus(
        "connected",
        `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
      );
      scheduleEventsRender({ forceFull: true });
    } catch (err) {
      if (err.name === "AbortError") {
        console.log("[Events] Incremental fetch aborted");
        return;
      }
      console.error("[Events] Failed to load incremental events", err);
      updateConnectionStatus("error", "Failed to refresh events");
      if (window.Utils && typeof Utils.showToast === "function") {
        Utils.showToast("‚ö†Ô∏è Failed to refresh events", "warning");
      }
    } finally {
      eventsFetchState.sinceInFlight = false;
      eventsFetchState.sinceAbortController = null;
    }
  }

  async function requestEventsSnapshot(message) {
    if (eventsFetchState.headInFlight && eventsFetchState.headAbortController) {
      eventsFetchState.headAbortController.abort();
    }

    if (eventsFetchState.sinceAbortController) {
      eventsFetchState.sinceAbortController.abort();
      eventsFetchState.sinceAbortController = null;
      eventsFetchState.sinceInFlight = false;
    }

    stopEventsPolling();

    eventsSnapshotState.inProgress = true;
    clearEventsCache();
    updateConnectionStatus("connecting", message || "Loading latest events...");

    const success = await fetchEventsHead({ message });

    if (!success) {
      eventsSnapshotState.inProgress = false;
      return;
    }

    eventsSnapshotState.inProgress = false;

    if (isEventsPaused()) {
      stopEventsPolling();
      return;
    }

    await fetchEventsSince({ reason: "snapshot" });
    startEventsPolling();
  }

  // Render events in table
  function getSearchTerm() {
    return (document.getElementById("eventSearch")?.value || "").toLowerCase();
  }

  function matchesSearch(event, searchTerm) {
    if (!searchTerm) return true;
    const haystacks = [
      event.category,
      event.subtype,
      event.message,
      event.reference_id,
      event.mint,
    ];
    return haystacks.some(
      (value) =>
        typeof value === "string" && value.toLowerCase().includes(searchTerm)
    );
  }

  function formatEventCountLabel(count) {
    const safe = Number.isFinite(count) ? count : 0;
    const plural = safe === 1 ? "event" : "events";
    return `${safe.toLocaleString()} ${plural}`;
  }

  function formatReferenceSnippet(value) {
    if (typeof value !== "string") return "";
    if (value.length <= 12) return value;
    return `${value.slice(0, 6)}‚Ä¶${value.slice(-6)}`;
  }

  function formatSummaryKey(key) {
    if (!key) return "Field";
    return String(key)
      .replace(/[_-]/g, " ")
      .replace(/\b\w/g, (ch) => ch.toUpperCase());
  }

  function renderEventDetailSummary(payload) {
    const container = document.getElementById("eventDetailSummary");
    if (!container) return;

    if (!payload || typeof payload !== "object" || Array.isArray(payload)) {
      container.innerHTML =
        '<div class="summary-empty">Payload has nested data. Inspect JSON below.</div>';
      return;
    }

    const entries = [];
    Object.entries(payload).forEach(([key, value]) => {
      if (value === null || value === undefined || typeof value === "object") {
        return;
      }

      entries.push({
        label: formatSummaryKey(key),
        value: String(value),
      });
    });

    if (!entries.length) {
      container.innerHTML =
        '<div class="summary-empty">Payload has nested data. Inspect JSON below.</div>';
      return;
    }

    const limited = entries.slice(0, 12);
    const html = limited
      .map(
        ({ label, value }) => `
          <div class="summary-item">
            <span class="summary-key">${Utils.escapeHtml(label)}</span>
            <span class="summary-value">${Utils.escapeHtml(value)}</span>
          </div>
        `
      )
      .join("");

    container.innerHTML = `<div class="summary-grid">${html}</div>`;
  }

  function ensureEventsScrollGuard(hasRows) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;
    let guard = document.getElementById("events-scroll-guard");

    if (!hasRows) {
      if (guard && guard.parentElement === tbody) {
        tbody.removeChild(guard);
      }
      return;
    }

    if (!guard) {
      guard = document.createElement("tr");
      guard.id = "events-scroll-guard";
      guard.className = "scroll-guard-row";
      const cell = document.createElement("td");
      cell.colSpan = 7;
      cell.className = "scroll-guard-cell";
      guard.appendChild(cell);
    }

    if (!guard.parentElement || guard.parentElement !== tbody) {
      if (guard.parentElement) {
        guard.parentElement.removeChild(guard);
      }
      tbody.appendChild(guard);
    } else if (tbody.lastElementChild !== guard) {
      tbody.appendChild(guard);
    }
  }

  function setEventsScrollGuardState(state) {
    const cell = document.querySelector(
      "#events-scroll-guard .scroll-guard-cell"
    );
    if (!cell) return;
    cell.dataset.state = state || "idle";
    cell.classList.toggle("loading", state === "loading");
    if (state === "loading") {
      cell.textContent = "Loading more events‚Ä¶";
    } else if (state === "limit") {
      cell.textContent = `Loaded browser limit (${EVENTS_BROWSER_LIMIT.toLocaleString()} events)`;
    } else if (state === "end") {
      cell.textContent = allEventsData.length ? "No more results" : "";
    } else if (state === "filtered") {
      cell.textContent =
        "No more results match the current search. Clear filters to load older events.";
    } else {
      cell.textContent = "";
    }
  }

  function setupEventsScrollObserver() {
    if (eventsScrollState.observer) {
      eventsScrollState.observer.disconnect();
      eventsScrollState.observer = null;
    }

    if (eventsScrollState.loading || eventsScrollState.endReached) {
      return;
    }

    const guard = document.getElementById("events-scroll-guard");
    const container = document.querySelector(".table-wrap");
    if (!guard || !container || !guard.parentElement) {
      return;
    }

    eventsScrollState.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadOlderEvents();
          }
        });
      },
      { root: container, rootMargin: "320px 0px 0px 0px", threshold: 0 }
    );

    eventsScrollState.observer.observe(guard);
  }

  async function refreshCategoryOptions() {
    const select = document.getElementById("categoryFilter");
    if (!select) return;

    hydrateCategoryOptionsCache();

    try {
      const response = await fetch("/api/events/categories");
      if (!response.ok) {
        return;
      }

      const payload = await response.json();
      const categories = Object.keys(payload?.categories || {})
        .filter(Boolean)
        .sort((a, b) => a.localeCompare(b));

      categories.forEach((category) => {
        ensureCategoryOption(category, formatCategoryLabel(category));
      });
    } catch (err) {
      console.warn("[Events] Failed to refresh categories", err);
    }
  }

  function getOldestEventId() {
    if (!allEventsData || allEventsData.length === 0) return null;
    const last = allEventsData[allEventsData.length - 1];
    const id = Number(last?.id ?? last?.event_id ?? last?.eventId);
    return Number.isFinite(id) ? id : null;
  }

  function updateEventsScrollControls(hasRows) {
    ensureEventsScrollGuard(hasRows);

    if (!hasRows) {
      setEventsScrollGuardState("idle");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.filteredEnd) {
      setEventsScrollGuardState("filtered");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.limitReached) {
      setEventsScrollGuardState("limit");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.endReached) {
      setEventsScrollGuardState("end");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.loading) {
      setEventsScrollGuardState("loading");
    } else {
      setEventsScrollGuardState("idle");
    }

    setupEventsScrollObserver();
  }

  function applyCategoryFilterValue(category) {
    const select = document.getElementById("categoryFilter");
    if (!select) return;
    const normalized = category ? String(category).toLowerCase() : "";
    if (normalized) {
      ensureCategoryOption(normalized, formatCategoryLabel(normalized));
    }
    select.value = normalized;
    select.dispatchEvent(new Event("change"));
  }

  function applySearchShortcut(value) {
    const searchInput = document.getElementById("eventSearch");
    if (!searchInput) return;
    const nextValue = value || "";
    searchInput.value = nextValue;
    AppState.save("events_search", nextValue.toLowerCase());
    eventsScrollState.filteredEnd = false;
    eventsScrollState.endReached = false;
    eventsScrollState.limitReached = false;
    searchInput.dispatchEvent(new Event("input", { bubbles: true }));
  }

  function clearAllFilters() {
    const searchInput = document.getElementById("eventSearch");
    if (searchInput) {
      if (searchInput.value !== "") {
        searchInput.value = "";
        AppState.save("events_search", "");
        searchInput.dispatchEvent(new Event("input", { bubbles: true }));
      }
    }

    const categoryFilter = document.getElementById("categoryFilter");
    if (categoryFilter) {
      if (categoryFilter.value) {
        applyCategoryFilterValue("");
      } else {
        syncCategoryChips();
      }
    }

    const severityFilter = document.getElementById("severityFilter");
    if (severityFilter) {
      if (severityFilter.value) {
        severityFilter.value = "";
        severityFilter.dispatchEvent(new Event("change"));
      } else {
        syncSeverityChips();
      }
    }

    setTimeWindow(null);

    if (window.Utils && typeof Utils.showToast === "function") {
      Utils.showToast("‚úÖ Filters cleared");
    }
  }

  async function loadOlderEvents() {
    if (
      eventsScrollState.loading ||
      eventsScrollState.endReached ||
      eventsScrollState.limitReached
    ) {
      return;
    }

    const searchTerm = getSearchTerm();
    if (searchTerm) {
      eventsScrollState.filteredEnd = true;
      eventsScrollState.endReached = true;
      updateEventsScrollControls(allEventsData.length > 0);
      return;
    }

    if (hasActiveTimeWindow()) {
      eventsScrollState.filteredEnd = true;
      eventsScrollState.endReached = true;
      updateEventsScrollControls(allEventsData.length > 0);
      return;
    }

    eventsScrollState.filteredEnd = false;

    if (allEventsData.length >= EVENTS_BROWSER_LIMIT) {
      eventsScrollState.limitReached = true;
      updateEventsScrollControls(true);
      return;
    }

    const oldestId = getOldestEventId();
    if (!Number.isFinite(oldestId)) {
      eventsScrollState.endReached = true;
      updateEventsScrollControls(allEventsData.length > 0);
      return;
    }

    const remainingBeforeRequest = Math.max(
      0,
      EVENTS_BROWSER_LIMIT - allEventsData.length
    );
    if (remainingBeforeRequest <= 0) {
      eventsScrollState.limitReached = true;
      updateEventsScrollControls(true);
      return;
    }

    eventsScrollState.loading = true;
    updateEventsScrollControls(allEventsData.length > 0);

    const params = new URLSearchParams();
    params.set("before_id", oldestId.toString());
    params.set(
      "limit",
      Math.min(eventsScrollState.pageSize, remainingBeforeRequest).toString()
    );
    const category = document.getElementById("categoryFilter")?.value;
    const severity = document.getElementById("severityFilter")?.value;
    if (category) params.set("category", category);
    if (severity) params.set("severity", severity);

    try {
      const res = await fetch(`/api/events/before?${params.toString()}`);
      if (!res.ok) {
        throw new Error(`Failed to load older events (${res.status})`);
      }

      const payload = await res.json();
      const rows = Array.isArray(payload?.events) ? payload.events : [];
      if (!rows.length) {
        eventsScrollState.endReached = true;
        updateEventsScrollControls(allEventsData.length > 0);
        return;
      }

      const normalizedRows = rows
        .map((raw) => normalizeEvent(raw))
        .filter((ev) => ev && typeof ev.id === "number")
        .sort((a, b) => b.id - a.id);

      if (!normalizedRows.length) {
        eventsScrollState.endReached = true;
        updateEventsScrollControls(allEventsData.length > 0);
        return;
      }

      const remainingCapacity = Math.max(
        0,
        EVENTS_BROWSER_LIMIT - allEventsData.length
      );
      if (remainingCapacity <= 0) {
        eventsScrollState.limitReached = true;
        updateEventsScrollControls(true);
        return;
      }

      const toAppend = normalizedRows.slice(0, remainingCapacity);
      const uniqueToAppend = [];
      toAppend.forEach((event) => {
        const id = Number(event.id);
        if (!Number.isFinite(id)) {
          return;
        }
        if (!eventsStore.has(id)) {
          uniqueToAppend.push(event);
        }
        eventsStore.set(id, event);
        markEventDirty(id);
      });

      if (uniqueToAppend.length) {
        allEventsData = allEventsData.concat(uniqueToAppend);
      }

      if (toAppend.length < normalizedRows.length) {
        eventsScrollState.limitReached = true;
      }

      eventsScrollState.endReached = false;

      const fetchedCount = Array.isArray(payload?.events)
        ? payload.events.length
        : Number(payload?.count) || 0;
      eventsSnapshotState.totalAvailable = Math.max(
        eventsSnapshotState.totalAvailable || 0,
        fetchedCount,
        allEventsData.length
      );
      eventsSnapshotState.received = allEventsData.length;
      eventsSnapshotState.lastUpdatedAt = Date.now();
      updateEventsLastUpdatedLabel();

      scheduleEventsRender({ forceFull: true });
    } catch (err) {
      console.error("[Events] Failed to load older events", err);
      Utils.showToast("‚ö†Ô∏è Failed to load more events", "warn");
    } finally {
      eventsScrollState.loading = false;
      updateEventsScrollControls(allEventsData.length > 0);
    }
  }

  function areIdArraysEqual(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i += 1) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  function createEventRow(event) {
    const row = document.createElement("tr");
    row.className = "event-row";
    row.style.borderBottom = "1px solid var(--border-color)";
    row.dataset.eventId = String(event.id);
    updateEventRow(row, event);
    return row;
  }

  function updateEventRow(row, event) {
    if (!row) return;
    const eventTimeValue = event.event_time || event.eventTimeIso;
    const timeDate = event.eventTimeDate || parseDate(eventTimeValue);
    const timeRelative = timeDate
      ? Utils.formatTimeAgo(timeDate, { fallback: "-" })
      : "-";
    const timeAbsolute = eventTimeValue
      ? Utils.formatTimestamp(eventTimeValue, { includeSeconds: true })
      : "-";
    const severityColor = getSeverityColor(event.severity);
    const severityLabel =
      event.severityLabel ||
      (event.severity ? String(event.severity).toUpperCase() : "-");
    let referenceCell = "-";
    if (event.reference_id) {
      const snippet = Utils.escapeHtml(
        formatReferenceSnippet(event.reference_id)
      );
      const full = Utils.escapeHtml(event.reference_id);
      const encoded = encodeURIComponent(event.reference_id);
      referenceCell = `
        <span class="event-ref" title="${full}">${snippet}</span>
        <button class="event-ref-copy" type="button" data-ref="${encoded}" title="Copy reference">üìã</button>
      `;
    }
    let mintCell = "‚Äî";
    if (event.mint) {
      const mintSnippet = Utils.escapeHtml(formatReferenceSnippet(event.mint));
      const mintFull = Utils.escapeHtml(event.mint);
      const encodedMint = encodeURIComponent(event.mint);
      mintCell = `
        <span class="event-mint" title="${mintFull}">${mintSnippet}</span>
        <button class="event-mint-copy" type="button" data-mint="${encodedMint}" title="Copy mint">üìã</button>
      `;
    }
    const messageText = Utils.escapeHtml(event.message);
    const categoryLabel = Utils.escapeHtml(
      event.categoryLabel || formatCategoryLabel(event.category) || "-"
    );
    const subtypeLabel = Utils.escapeHtml(event.subtype || "-");
    const severityTitle = `${severityLabel}`;

    row.dataset.eventId = String(event.id);
    row.innerHTML = `
      <td style="padding: 10px; white-space: nowrap;" title="${Utils.escapeHtml(
        timeAbsolute
      )}">${timeRelative}</td>
      <td style="padding: 10px;">
        <span style="background: var(--badge-loading); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
          ${categoryLabel}
        </span>
      </td>
      <td style="padding: 10px; font-size: 0.9em;">${subtypeLabel}</td>
      <td style="padding: 10px;">
        <span class="severity-pill" style="background: ${severityColor};" title="${Utils.escapeHtml(
      severityTitle
    )}">
          ${severityLabel}
        </span>
      </td>
      <td style="padding: 10px; font-size: 0.85em;">
        <span class="event-mint-cell">${mintCell}</span>
      </td>
      <td style="padding: 10px; max-width: 420px;">
        <div class="event-message-cell">
          <span class="event-message-text" title="${messageText}">${messageText}</span>
          <button class="event-detail-btn" type="button" data-event-id="${
            event.id
          }" title="View full event">Details</button>
        </div>
      </td>
      <td style="padding: 10px; font-size: 0.85em;">
        <span class="event-ref-cell">${referenceCell}</span>
      </td>
    `;
  }

  function collectFilteredEvents() {
    const searchTerm = getSearchTerm();
    const filtered = [];
    const ids = [];
    for (const event of allEventsData) {
      if (!event) continue;
      if (!matchesSearch(event, searchTerm)) continue;
      const idNum = Number(event.id ?? event.event_id ?? event.eventId);
      if (!Number.isFinite(idNum)) continue;
      filtered.push(event);
      ids.push(idNum);
    }
    return { events: filtered, ids, searchTerm };
  }

  function setEventsEmptyState(message) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
      <tr>
  <td colspan="7" style="text-align: center; padding: 40px; color: var(--text-muted);">
          ${message}
        </td>
      </tr>
    `;
  }

  function scheduleEventsRender(options) {
    const opts = Object.assign(
      { forceFull: false, immediate: false },
      options || {}
    );
    if (opts.forceFull) {
      eventsRenderState.forceFull = true;
    }

    if (opts.immediate) {
      if (eventsRenderState.rafId) {
        cancelAnimationFrame(eventsRenderState.rafId);
        eventsRenderState.rafId = null;
      }
      eventsRenderState.pending = false;
      applyScheduledEventsRender();
      return;
    }

    if (eventsRenderState.pending) {
      return;
    }

    eventsRenderState.pending = true;
    eventsRenderState.rafId = window.requestAnimationFrame(() => {
      eventsRenderState.rafId = null;
      eventsRenderState.pending = false;
      applyScheduledEventsRender();
    });
  }

  function applyScheduledEventsRender() {
    const forceFull = eventsRenderState.forceFull;
    eventsRenderState.forceFull = false;
    performEventsRender(forceFull);
  }

  function performEventsRender(forceFull) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;

    const {
      events: filtered,
      ids: filteredIds,
      searchTerm,
    } = collectFilteredEvents();

    if (!filtered || filtered.length === 0) {
      eventsRenderState.renderedIds = [];
      eventsRenderState.rowsById.clear();
      eventsRenderState.dirtyIds.clear();
      eventsRenderState.lastSearchTerm = searchTerm;

      const message = eventsSnapshotState.inProgress
        ? "üì¶ Fetching events..."
        : connectionStatus === "error"
        ? "‚ö†Ô∏è Error loading events. Please check server status."
        : connectionStatus === "connecting"
        ? "üîÑ Connecting to server..."
        : connectionStatus === "paused"
        ? "‚è∏Ô∏è Events paused. Resume to receive new activity."
        : connectionStatus === "disconnected"
        ? "üì¥ Realtime connection lost. Waiting to resync..."
        : "üìã No events found. Events will appear here as they occur.";

      setEventsEmptyState(message);
      updateEventsScrollControls(false);
      return;
    }

    const sameIds = areIdArraysEqual(
      filteredIds,
      eventsRenderState.renderedIds
    );
    if (
      !forceFull &&
      eventsRenderState.dirtyIds.size === 0 &&
      sameIds &&
      eventsRenderState.lastSearchTerm === searchTerm
    ) {
      ensureEventsScrollGuard(true);
      updateEventsScrollControls(true);
      return;
    }

    const filteredIdSet = new Set(filteredIds);
    const attachMap = new Map();

    for (const id of filteredIds) {
      const row = eventsRenderState.rowsById.get(id);
      if (row && row.parentElement === tbody) {
        attachMap.set(id, row);
      }
    }

    for (const existingId of eventsRenderState.renderedIds) {
      if (!filteredIdSet.has(existingId)) {
        eventsRenderState.rowsById.delete(existingId);
      }
    }

    const fragment = document.createDocumentFragment();
    for (let index = 0; index < filteredIds.length; index += 1) {
      const id = filteredIds[index];
      const event = filtered[index];
      let row = eventsRenderState.rowsById.get(id);
      if (!row) {
        row = createEventRow(event);
        eventsRenderState.rowsById.set(id, row);
      } else if (forceFull || eventsRenderState.dirtyIds.has(id)) {
        updateEventRow(row, event);
      }
      if (attachMap.has(id)) {
        const existingRow = attachMap.get(id);
        if (existingRow !== row) {
          attachMap.set(id, row);
        }
      }
      fragment.appendChild(row);
    }

    if (tbody.firstChild) {
      while (
        tbody.firstChild &&
        tbody.firstChild.id !== "events-scroll-guard"
      ) {
        tbody.removeChild(tbody.firstChild);
      }
    }

    tbody.insertBefore(
      fragment,
      document.getElementById("events-scroll-guard")
    );

    eventsRenderState.renderedIds = filteredIds.slice();
    eventsRenderState.dirtyIds.clear();
    eventsRenderState.lastSearchTerm = searchTerm;

    ensureEventsScrollGuard(true);
    updateEventsScrollControls(true);
  }

  // Get color for severity
  function getSeverityColor(severity) {
    const key = (severity || "").toLowerCase();
    const colors = {
      info: "var(--badge-online)",
      warn: "var(--badge-loading)",
      error: "var(--badge-error)",
      debug: "#6b7280",
    };
    return colors[key] || "#6b7280";
  }

  // Search events
  document.getElementById("eventSearch").addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    AppState.save("events_search", searchTerm);
    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }
    searchDebounceHandle = setTimeout(() => {
      eventsScrollState.filteredEnd = false;
      eventsScrollState.endReached = false;
      eventsScrollState.limitReached = false;
      scheduleEventsRender({ forceFull: true });
    }, 120);
  });

  // Filter by category
  document.getElementById("categoryFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying category filter...");
    AppState.save(
      "events_category",
      document.getElementById("categoryFilter").value
    );
    syncCategoryChips();
  });

  // Filter by severity
  document.getElementById("severityFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying severity filter...");
    AppState.save(
      "events_severity",
      document.getElementById("severityFilter").value
    );
    syncSeverityChips();
  });

  // Refresh button
  document
    .getElementById("refreshEvents")
    .addEventListener("click", () =>
      requestEventsSnapshot("Refreshing events...")
    );

  const clearFiltersButton = document.getElementById("clearFilters");
  if (clearFiltersButton) {
    clearFiltersButton.addEventListener("click", clearAllFilters);
  }

  document.querySelectorAll("[data-severity-chip]").forEach((chip) => {
    chip.addEventListener("click", () => {
      const severitySelect = document.getElementById("severityFilter");
      if (!severitySelect) return;
      const value = chip.getAttribute("data-severity-chip") || "";
      const current = severitySelect.value || "";
      const nextValue = current === value ? "" : value;
      if (current === nextValue) {
        syncSeverityChips();
        return;
      }
      severitySelect.value = nextValue;
      severitySelect.dispatchEvent(new Event("change"));
    });
  });

  document.querySelectorAll("[data-category-chip]").forEach((chip) => {
    chip.addEventListener("click", () => {
      const value = (
        chip.getAttribute("data-category-chip") || ""
      ).toLowerCase();
      const select = document.getElementById("categoryFilter");
      if (!select) return;
      const current = select.value || "";
      const nextValue = current === value ? "" : value;
      if (current === nextValue) {
        syncCategoryChips();
        return;
      }
      applyCategoryFilterValue(nextValue);
    });
  });

  document.querySelectorAll("[data-time-window]").forEach((chip) => {
    chip.addEventListener("click", () => {
      const valueAttr = chip.getAttribute("data-time-window") || "";
      const numeric = valueAttr === "" ? null : Number(valueAttr);
      const activeValue = eventsActiveFilters.timeWindowMinutes;
      const isActive =
        numeric === null ? activeValue === null : activeValue === numeric;
      if (numeric === null || isActive) {
        setTimeWindow(null);
        return;
      }
      setTimeWindow(valueAttr);
    });
  });

  document.getElementById("toggleEventsPause").addEventListener("click", () => {
    const nextPaused = !isEventsPaused();
    applyEventsPauseState(nextPaused, {
      message: nextPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : "Resuming events...",
    });
  });

  // Reference copy handler
  document
    .getElementById("eventsTableBody")
    .addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".event-ref-copy");
      if (copyBtn) {
        const encoded = copyBtn.getAttribute("data-ref");
        if (!encoded) return;
        const reference = decodeURIComponent(encoded);
        try {
          await Utils.copyToClipboard(reference);
          Utils.showToast("‚úÖ Reference copied to clipboard");
        } catch (err) {
          console.error("Failed to copy reference:", err);
          Utils.showToast("‚ùå Failed to copy reference", "error");
        }
        return;
      }

      const mintCopyBtn = event.target.closest(".event-mint-copy");
      if (mintCopyBtn) {
        const encodedMint = mintCopyBtn.getAttribute("data-mint");
        if (!encodedMint) return;
        const mintValue = decodeURIComponent(encodedMint);
        try {
          await Utils.copyToClipboard(mintValue);
          Utils.showToast("‚úÖ Mint copied to clipboard");
        } catch (err) {
          console.error("Failed to copy mint:", err);
          Utils.showToast("‚ùå Failed to copy mint", "error");
        }
        return;
      }

      const detailBtn = event.target.closest(".event-detail-btn");
      if (detailBtn) {
        const idAttr = detailBtn.getAttribute("data-event-id");
        const eventId = Number(idAttr);
        if (Number.isFinite(eventId)) {
          openEventDetailModal(eventId);
        }
      }
    });

  const eventDetailModal = document.getElementById("eventDetailModal");
  const eventDetailClose = document.getElementById("eventDetailClose");
  const eventDetailElements = {
    title: document.getElementById("eventDetailTitle"),
    category: document.getElementById("eventDetailCategory"),
    severity: document.getElementById("eventDetailSeverity"),
    subtype: document.getElementById("eventDetailSubtype"),
    time: document.getElementById("eventDetailTime"),
    created: document.getElementById("eventDetailCreated"),
    relative: document.getElementById("eventDetailRelative"),
    latency: document.getElementById("eventDetailLatency"),
    reference: document.getElementById("eventDetailReference"),
    mint: document.getElementById("eventDetailMint"),
    id: document.getElementById("eventDetailId"),
    message: document.getElementById("eventDetailMessage"),
    payload: document.getElementById("eventDetailPayload"),
    summary: document.getElementById("eventDetailSummary"),
    payloadToggle: document.getElementById("eventDetailPayloadToggle"),
  };

  var eventDetailState = {
    current: null,
    payloadMode: "pretty",
    payloadStrings: { pretty: "{}", compact: "{}" },
  };

  function resetEventDetailState() {
    eventDetailState.current = null;
    eventDetailState.payloadMode = "pretty";
    eventDetailState.payloadStrings = {
      pretty: "No payload data available.",
      compact: "No payload data available.",
    };
    if (eventDetailElements.title) {
      eventDetailElements.title.textContent = "Event Details";
    }
    if (eventDetailElements.category) {
      eventDetailElements.category.textContent = "‚Äî";
      eventDetailElements.category.title = "";
    }
    if (eventDetailElements.severity) {
      eventDetailElements.severity.textContent = "-";
      eventDetailElements.severity.style.background = "#6b7280";
      eventDetailElements.severity.style.color = "#fff";
      eventDetailElements.severity.title = "Severity";
    }
    if (eventDetailElements.subtype) {
      eventDetailElements.subtype.textContent = "‚Äî";
      eventDetailElements.subtype.title = "";
    }
    if (eventDetailElements.id) {
      eventDetailElements.id.textContent = "‚Äî";
      eventDetailElements.id.title = "";
    }
    if (eventDetailElements.time) {
      eventDetailElements.time.textContent = "‚Äî";
      eventDetailElements.time.title = "";
    }
    if (eventDetailElements.created) {
      eventDetailElements.created.textContent = "‚Äî";
      eventDetailElements.created.title = "";
    }
    if (eventDetailElements.relative) {
      eventDetailElements.relative.textContent = "‚Äî";
    }
    if (eventDetailElements.latency) {
      eventDetailElements.latency.textContent = "‚Äî";
    }
    if (eventDetailElements.reference) {
      eventDetailElements.reference.textContent = "‚Äî";
      eventDetailElements.reference.title = "";
    }
    if (eventDetailElements.mint) {
      eventDetailElements.mint.textContent = "‚Äî";
      eventDetailElements.mint.title = "";
    }
    if (eventDetailElements.message) {
      eventDetailElements.message.textContent = "‚Äî";
      eventDetailElements.message.title = "";
    }
    if (eventDetailElements.summary) {
      eventDetailElements.summary.innerHTML =
        '<div class="summary-empty">Open an event to view summary.</div>';
    }
    if (eventDetailElements.payload) {
      eventDetailElements.payload.textContent = "No payload data available.";
    }
    if (eventDetailElements.payloadToggle) {
      eventDetailElements.payloadToggle.textContent = "‚û°Ô∏è Compact JSON";
    }
  }

  function updateEventDetailPayload() {
    if (!eventDetailElements.payload) return;
    const mode =
      eventDetailState.payloadMode === "compact" ? "compact" : "pretty";
    const strings = eventDetailState.payloadStrings || {};
    const payloadText =
      mode === "compact"
        ? strings.compact ?? strings.pretty
        : strings.pretty ?? strings.compact;
    eventDetailElements.payload.textContent =
      payloadText || "No payload data available.";

    if (eventDetailElements.payloadToggle) {
      eventDetailElements.payloadToggle.textContent =
        mode === "compact" ? "‚¨ÖÔ∏è Pretty JSON" : "‚û°Ô∏è Compact JSON";
    }
  }

  function renderEventDetail() {
    if (!eventDetailState.current) return;
    const data = eventDetailState.current;

    const categoryLabel =
      data.categoryLabel || formatCategoryLabel(data.category) || "Event";
    if (eventDetailElements.title) {
      eventDetailElements.title.textContent = `${categoryLabel.toUpperCase()} ‚Ä¢ #${
        data.id ?? "?"
      }`;
    }
    if (eventDetailElements.category) {
      eventDetailElements.category.textContent = categoryLabel;
      eventDetailElements.category.title = categoryLabel;
    }
    if (eventDetailElements.severity) {
      const severityLabel =
        data.severityLabel ||
        (data.severity ? String(data.severity).toUpperCase() : "-");
      eventDetailElements.severity.textContent = severityLabel;
      const severityColor = getSeverityColor(data.severity);
      eventDetailElements.severity.style.background = severityColor;
      eventDetailElements.severity.style.color = "#fff";
      eventDetailElements.severity.title = severityLabel || "Severity";
    }
    if (eventDetailElements.subtype) {
      const subtypeText = data.subtype || "‚Äî";
      eventDetailElements.subtype.textContent = subtypeText;
      eventDetailElements.subtype.title =
        subtypeText !== "‚Äî" ? subtypeText : "";
    }
    if (eventDetailElements.id) {
      const idText =
        data.id !== undefined && data.id !== null ? String(data.id) : "‚Äî";
      eventDetailElements.id.textContent = idText;
      eventDetailElements.id.title = idText;
    }

    const eventTimeValue = data.event_time || data.eventTimeIso;
    const createdTimeValue = data.created_at || data.createdAtIso;
    if (eventDetailElements.time) {
      eventDetailElements.time.textContent = eventTimeValue
        ? Utils.formatTimestamp(eventTimeValue, { includeSeconds: true })
        : "‚Äî";
      eventDetailElements.time.title = eventTimeValue || "";
    }
    if (eventDetailElements.created) {
      eventDetailElements.created.textContent = createdTimeValue
        ? Utils.formatTimestamp(createdTimeValue, { includeSeconds: true })
        : "‚Äî";
      eventDetailElements.created.title = createdTimeValue || "";
    }
    const timeDate = data.eventTimeDate || parseDate(eventTimeValue);
    if (eventDetailElements.relative) {
      eventDetailElements.relative.textContent = timeDate
        ? Utils.formatTimeAgo(timeDate, { fallback: "‚Äî" })
        : "‚Äî";
    }
    if (eventDetailElements.latency) {
      eventDetailElements.latency.textContent = formatLatencyMs(data.latencyMs);
    }
    if (eventDetailElements.reference) {
      const referenceText = data.reference_id || "‚Äî";
      eventDetailElements.reference.textContent = referenceText;
      eventDetailElements.reference.title =
        referenceText !== "‚Äî" ? referenceText : "";
    }
    if (eventDetailElements.mint) {
      const mintText = data.mint || "‚Äî";
      eventDetailElements.mint.textContent = mintText;
      eventDetailElements.mint.title = mintText !== "‚Äî" ? mintText : "";
    }
    if (eventDetailElements.message) {
      const messageText = data.message || "‚Äî";
      eventDetailElements.message.textContent = messageText;
      eventDetailElements.message.title =
        messageText !== "‚Äî" ? messageText : "";
    }

    renderEventDetailSummary(data.payload);
    updateEventDetailPayload();
  }

  function openEventDetailModal(eventId) {
    if (!eventDetailModal) return;
    const eventData = eventsStore.get(eventId);
    if (!eventData) {
      Utils.showToast("‚ùå Event details unavailable", "error");
      return;
    }

    eventDetailState.current = eventData;
    eventDetailState.payloadMode = "pretty";

    if (eventData.payload !== null && eventData.payload !== undefined) {
      try {
        eventDetailState.payloadStrings = {
          pretty: JSON.stringify(eventData.payload, null, 2),
          compact: JSON.stringify(eventData.payload),
        };
      } catch (err) {
        console.error("[Events] Failed to stringify payload", err);
        const fallback = "Unable to render payload.";
        eventDetailState.payloadStrings = {
          pretty: fallback,
          compact: fallback,
        };
      }
    } else {
      resetEventDetailState();
      eventDetailState.current = eventData;
    }

    renderEventDetail();
    eventDetailModal.classList.add("show");
  }

  function closeEventDetailModal() {
    if (!eventDetailModal) return;
    eventDetailModal.classList.remove("show");
    resetEventDetailState();
  }

  async function copyDetailValue(target) {
    if (!eventDetailState.current) {
      Utils.showToast("‚ÑπÔ∏è Event details unavailable", "warn");
      return;
    }

    let value = "";
    switch (target) {
      case "reference":
        value = eventDetailState.current.reference_id;
        break;
      case "mint":
        value = eventDetailState.current.mint;
        break;
      case "message":
        value = eventDetailState.current.message;
        break;
      case "id":
        value =
          eventDetailState.current.id !== undefined &&
          eventDetailState.current.id !== null
            ? String(eventDetailState.current.id)
            : "";
        break;
      default:
        value = "";
    }

    if (!value) {
      Utils.showToast("‚ÑπÔ∏è Nothing to copy", "warn");
      return;
    }

    try {
      await Utils.copyToClipboard(value);
      Utils.showToast("‚úÖ Copied to clipboard");
    } catch (err) {
      console.error("[Events] Failed to copy detail", err);
      Utils.showToast("‚ùå Copy failed", "error");
    }
  }

  async function handleDetailAction(action) {
    if (!eventDetailState.current) {
      Utils.showToast("‚ÑπÔ∏è Event details unavailable", "warn");
      return;
    }

    switch (action) {
      case "copy-payload": {
        const payloadText =
          eventDetailState.payloadMode === "compact"
            ? eventDetailState.payloadStrings.compact
            : eventDetailState.payloadStrings.pretty;
        try {
          await Utils.copyToClipboard(payloadText || "{}");
          Utils.showToast("‚úÖ Payload copied");
        } catch (err) {
          console.error("[Events] Failed to copy payload", err);
          Utils.showToast("‚ùå Copy failed", "error");
        }
        break;
      }
      case "toggle-payload": {
        eventDetailState.payloadMode =
          eventDetailState.payloadMode === "pretty" ? "compact" : "pretty";
        updateEventDetailPayload();
        break;
      }
      case "filter-category": {
        ensureCategoryOption(
          eventDetailState.current.category,
          eventDetailState.current.categoryLabel
        );
        applyCategoryFilterValue(eventDetailState.current.category);
        closeEventDetailModal();
        Utils.showToast("‚úÖ Applied category filter");
        break;
      }
      case "filter-reference": {
        const reference = eventDetailState.current.reference_id;
        if (reference) {
          applySearchShortcut(reference);
          closeEventDetailModal();
          Utils.showToast("‚úÖ Filtering by reference");
        } else {
          Utils.showToast("‚ÑπÔ∏è No reference available", "warn");
        }
        break;
      }
      case "filter-mint": {
        const mint = eventDetailState.current.mint;
        if (mint) {
          applySearchShortcut(mint);
          closeEventDetailModal();
          Utils.showToast("‚úÖ Filtering by mint");
        } else {
          Utils.showToast("‚ÑπÔ∏è No mint available", "warn");
        }
        break;
      }
      default:
        break;
    }
  }

  resetEventDetailState();

  if (eventDetailClose) {
    eventDetailClose.addEventListener("click", closeEventDetailModal);
  }
  if (eventDetailModal) {
    eventDetailModal.addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".meta-copy-btn");
      if (copyBtn) {
        event.stopPropagation();
        const target = copyBtn.getAttribute("data-copy-target");
        await copyDetailValue(target);
        return;
      }

      const actionBtn = event.target.closest("[data-detail-action]");
      if (actionBtn) {
        event.stopPropagation();
        const action = actionBtn.getAttribute("data-detail-action");
        await handleDetailAction(action);
        return;
      }

      if (event.target === eventDetailModal) {
        closeEventDetailModal();
      }
    });
  }

  document.addEventListener("keydown", (event) => {
    if (
      event.key === "Escape" &&
      eventDetailModal &&
      eventDetailModal.classList.contains("show")
    ) {
      closeEventDetailModal();
    }
  });

  function restoreSavedFilters() {
    const categoryFilter = document.getElementById("categoryFilter");
    const severityFilter = document.getElementById("severityFilter");
    const searchInput = document.getElementById("eventSearch");

    if (categoryFilter) {
      const savedCategory = AppState.load("events_category", "");
      if (savedCategory) {
        ensureCategoryOption(savedCategory, formatCategoryLabel(savedCategory));
        categoryFilter.value = savedCategory;
      }
    }

    if (severityFilter) {
      const savedSeverity = AppState.load("events_severity", "");
      if (savedSeverity) severityFilter.value = savedSeverity;
    }

    if (searchInput) {
      const savedSearch = AppState.load("events_search", "");
      if (savedSearch) searchInput.value = savedSearch;
    }

    const savedWindow = AppState.load("events_time_window", "");
    if (savedWindow) {
      setTimeWindow(savedWindow, { silent: true, save: false });
    } else {
      setTimeWindow(null, { silent: true, save: false });
    }

    syncCategoryChips();
    syncSeverityChips();
    updateTimeWindowChips();
  }

  function initializePauseState() {
    updatePauseButtonUI();
    const savedPaused = AppState.load("events_paused", "") === "1";
    if (savedPaused) {
      eventsPauseState.paused = true;
      updatePauseButtonUI();
    }
  }

  // Global init function for Router to call during SPA navigation
  window.initEventsPage = async function () {
    console.log("[Events] Initializing page");
    await refreshCategoryOptions();
    restoreSavedFilters();
    initializePauseState();
    ensureEventsLifecycle();
    updateEventsLastUpdatedLabel();
    requestEventsSnapshot("Loading latest events...");
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  window.initEventsPage().catch((err) => {
    console.error("[Events] Failed to initialize events page", err);
    Utils.showToast("‚ö†Ô∏è Failed to initialize events page", "error");
  });
</script>
