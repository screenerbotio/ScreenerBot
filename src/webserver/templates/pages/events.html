<div class="page-table">
  <div class="toolbar">
    <span style="font-weight: 600">üì° Events</span>
    <input
      type="text"
      id="eventSearch"
      placeholder="üîç Search events..."
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <select
      id="categoryFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="">All Categories</option>
      <option value="swap">Swap</option>
      <option value="transaction">Transaction</option>
      <option value="pool">Pool</option>
      <option value="token">Token</option>
      <option value="position">Position</option>
      <option value="security">Security</option>
      <option value="entry">Entry</option>
      <option value="system">System</option>
    </select>
    <select
      id="severityFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="">All Severity</option>
      <option value="info">Info</option>
      <option value="warn">Warning</option>
      <option value="error">Error</option>
      <option value="debug">Debug</option>
    </select>
    <div class="spacer"></div>
    <span
      id="eventsCountText"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button id="toggleEventsPause" class="btn">‚è∏Ô∏è Pause</button>
    <button id="refreshEvents" class="btn btn-primary">üîÑ Refresh</button>
  </div>
  <style>
    .event-ref-cell {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: monospace;
    }

    .event-ref {
      color: var(--text-primary);
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .event-ref-copy {
      background: none;
      border: none;
      color: var(--link-color);
      cursor: pointer;
      font-size: 0.8em;
      padding: 2px 4px;
      border-radius: 4px;
      transition: color 0.2s ease;
    }

    .event-ref-copy:hover,
    .event-ref-copy:focus {
      color: var(--link-hover);
      outline: none;
    }

    .event-message-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .event-message-text {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .event-detail-btn {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.75em;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .event-detail-btn:hover,
    .event-detail-btn:focus {
      color: var(--link-color);
      border-color: var(--link-color);
      outline: none;
    }

    .event-detail-modal {
      max-width: 680px;
      width: calc(100% - 48px);
    }

    .event-detail-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .event-detail-meta .meta-label {
      display: block;
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .event-detail-meta .meta-value {
      display: block;
      font-size: 0.9em;
      color: var(--text-primary);
      word-break: break-all;
      margin-top: 2px;
    }

    .event-detail-json-wrapper {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      max-height: 320px;
      overflow: auto;
    }

    .event-detail-json {
      margin: 0;
      padding: 12px;
      font-size: 0.85em;
      line-height: 1.4;
      color: var(--text-primary);
    }
  </style>
  <div class="table-wrap">
    <table class="table" id="eventsTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Category</th>
          <th>Subtype</th>
          <th>Severity</th>
          <th>Message</th>
          <th>Reference</th>
        </tr>
      </thead>
      <tbody id="eventsTableBody">
        <tr>
          <td
            colspan="6"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading events...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <div id="eventDetailModal" class="modal-overlay">
    <div class="modal-content event-detail-modal">
      <div class="modal-header">
        <span class="modal-title" id="eventDetailTitle">Event Details</span>
        <button
          id="eventDetailClose"
          class="modal-close"
          type="button"
          aria-label="Close"
        >
          √ó
        </button>
      </div>
      <div class="modal-body">
        <div class="event-detail-meta">
          <div>
            <span class="meta-label">Category</span>
            <span class="meta-value" id="eventDetailCategory">-</span>
          </div>
          <div>
            <span class="meta-label">Severity</span>
            <span class="meta-value" id="eventDetailSeverity">-</span>
          </div>
          <div>
            <span class="meta-label">Time</span>
            <span class="meta-value" id="eventDetailTime">-</span>
          </div>
          <div>
            <span class="meta-label">Reference</span>
            <span class="meta-value" id="eventDetailReference">-</span>
          </div>
          <div>
            <span class="meta-label">Mint</span>
            <span class="meta-value" id="eventDetailMint">-</span>
          </div>
        </div>
        <div class="event-detail-json-wrapper">
          <pre id="eventDetailPayload" class="event-detail-json">
Loading...</pre
          >
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var allEventsData = [];
  var maxEventId = 0;
  var connectionStatus = "connecting"; // 'connecting', 'connected', 'disconnected', 'error'
  var eventsStore = window.eventsStore || new Map();
  var EVENTS_BROWSER_LIMIT = 5000; // hard ceiling for historical records kept client-side
  var EVENT_MAX_RECORDS = EVENTS_BROWSER_LIMIT; // keep store aligned with browser ceiling
  var EVENTS_SCROLL_PAGE_SIZE = 200;
  var searchDebounceHandle = null;
  var eventsPauseState = {
    paused: false,
    pending: false,
  };
  var eventsScrollState = {
    observer: null,
    loading: false,
    endReached: false,
    limitReached: false,
    pageSize: EVENTS_SCROLL_PAGE_SIZE,
    filteredEnd: false,
  };
  var eventsRenderState = {
    renderedIds: [],
    rowsById: new Map(),
    dirtyIds: new Set(),
    pending: false,
    rafId: null,
    forceFull: false,
    lastSearchTerm: "",
  };

  function resetEventsRenderState() {
    eventsRenderState.renderedIds = [];
    eventsRenderState.rowsById.clear();
    eventsRenderState.dirtyIds.clear();
    eventsRenderState.pending = false;
    if (eventsRenderState.rafId) {
      cancelAnimationFrame(eventsRenderState.rafId);
      eventsRenderState.rafId = null;
    }
    eventsRenderState.forceFull = false;
    eventsRenderState.lastSearchTerm = "";
  }

  function markEventDirty(eventId) {
    const idNum = Number(eventId);
    if (Number.isFinite(idNum)) {
      eventsRenderState.dirtyIds.add(idNum);
    }
  }

  function resetEventsScrollState() {
    if (eventsScrollState.observer) {
      eventsScrollState.observer.disconnect();
      eventsScrollState.observer = null;
    }
    eventsScrollState.loading = false;
    eventsScrollState.endReached = false;
    eventsScrollState.limitReached = false;
    eventsScrollState.filteredEnd = false;
  }

  function isEventsPaused() {
    return eventsPauseState.paused;
  }

  function updatePauseButtonUI() {
    const btn = document.getElementById("toggleEventsPause");
    if (!btn) return;
    const { paused, pending } = eventsPauseState;
    btn.disabled = pending;
    btn.classList.remove("btn-secondary");

    if (pending) {
      btn.textContent = paused ? "‚è≥ Resuming..." : "‚è≥ Pausing...";
      return;
    }

    if (paused) {
      btn.textContent = "‚ñ∂Ô∏è Resume";
      btn.classList.add("btn-secondary");
    } else {
      btn.textContent = "‚è∏Ô∏è Pause";
    }
  }

  function applyEventsPauseState(targetPaused, options) {
    const opts = Object.assign(
      {
        sendCommand: true,
        refreshSnapshot: !targetPaused,
        silent: false,
        force: false,
        message: null,
      },
      options || {}
    );

    if (eventsPauseState.pending) {
      return false;
    }

    if (!opts.force && eventsPauseState.paused === targetPaused) {
      if (opts.message) {
        const statusKey = targetPaused ? "paused" : "connected";
        updateConnectionStatus(statusKey, opts.message);
      }
      return true;
    }

    eventsPauseState.paused = targetPaused;
    AppState.save("events_paused", targetPaused ? "1" : "");
    updatePauseButtonUI();

    const statusMessage =
      opts.message ||
      (targetPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`);

    updateConnectionStatus(
      targetPaused ? "paused" : "connected",
      statusMessage
    );

    return true;
  }

  // Update connection status indicator
  function updateConnectionStatus(status, message) {
    connectionStatus = status;
    const indicator = document.getElementById("eventsCountText");
    if (!indicator) return;
    const colors = {
      connecting: "var(--text-secondary)",
      connected: "var(--badge-online)",
      disconnected: "var(--badge-loading)",
      error: "var(--badge-error)",
      paused: "var(--badge-loading)",
    };
    const icons = {
      connecting: "‚è≥",
      connected: "‚úÖ",
      disconnected: "‚ö†Ô∏è",
      error: "‚ùå",
      paused: "‚è∏Ô∏è",
    };
    const defaults = {
      connecting: "Connecting‚Ä¶",
      connected: "Connected",
      disconnected: "Disconnected",
      error: "Error",
      paused: "Paused",
    };
    const icon = icons[status] || "‚ÑπÔ∏è";
    const text = message || defaults[status] || "Status unavailable";
    indicator.style.color = colors[status] || "var(--text-secondary)";
    indicator.textContent = `${icon} ${text}`;
    indicator.dataset.status = status;
    indicator.title = text;
  }

  function clearEventsCache() {
    resetEventsScrollState();
    resetEventsRenderState();
    eventsStore.clear();
    allEventsData = [];
    snapshotState.totalAvailable = 0;
    snapshotState.received = 0;
    updateEventsScrollControls(false);
    eventsScrollState.filteredEnd = false;
    scheduleEventsRender({ forceFull: true, immediate: true });
  }

  function normalizeEvent(raw) {
    if (!raw || typeof raw !== "object") return null;
    const payload =
      raw.payload && typeof raw.payload === "object" ? raw.payload : {};
    const severity =
      typeof raw.severity === "string" ? raw.severity.toLowerCase() : "";
    const categoryRaw = typeof raw.category === "string" ? raw.category : "";
    const category = categoryRaw.toLowerCase();
    const categoryLabel = categoryRaw
      ? categoryRaw.charAt(0).toUpperCase() + categoryRaw.slice(1)
      : category
      ? category.charAt(0).toUpperCase() + category.slice(1)
      : "Unknown";
    const payloadMessage =
      typeof payload.message === "string" && payload.message.trim() !== ""
        ? payload.message
        : typeof payload.message_short === "string" &&
          payload.message_short.trim() !== ""
        ? payload.message_short
        : null;
    const rawMessage =
      typeof raw.message === "string" && raw.message.trim() !== ""
        ? raw.message
        : null;
    const message = rawMessage || payloadMessage || "No message";
    return {
      ...raw,
      category,
      categoryLabel,
      severity,
      message,
      payload,
    };
  }

  function hasEventChanged(existing, next) {
    if (!existing) return true;
    return (
      existing.message !== next.message ||
      existing.severity !== next.severity ||
      existing.category !== next.category ||
      existing.subtype !== next.subtype ||
      existing.reference_id !== next.reference_id ||
      existing.event_time !== next.event_time ||
      existing.mint !== next.mint ||
      JSON.stringify(existing.payload) !== JSON.stringify(next.payload)
    );
  }

  function matchesActiveFilters(event) {
    const category = document.getElementById("categoryFilter")?.value || "";
    const severity = document.getElementById("severityFilter")?.value || "";
    if (category && event.category !== category) return false;
    if (severity && event.severity !== severity) return false;
    return true;
  }

  function mergeEvents(events) {
    if (!Array.isArray(events) || events.length === 0) {
      return false;
    }

    let updated = false;
    for (const raw of events) {
      const event = normalizeEvent(raw);
      if (!event || typeof event.id !== "number") continue;
      if (!matchesActiveFilters(event)) continue;
      const eventId = Number(event.id);
      const existing = eventsStore.get(eventId);
      if (hasEventChanged(existing, event)) {
        eventsStore.set(eventId, event);
        markEventDirty(eventId);
        updated = true;
      }
    }

    if (!updated) {
      return false;
    }

    const orderedIds = Array.from(eventsStore.keys()).sort((a, b) => b - a);
    if (orderedIds.length > EVENT_MAX_RECORDS) {
      for (let i = EVENT_MAX_RECORDS; i < orderedIds.length; i++) {
        eventsStore.delete(orderedIds[i]);
      }
      orderedIds.length = EVENT_MAX_RECORDS;
    }

    allEventsData = orderedIds.map((id) => eventsStore.get(id));
    eventsScrollState.limitReached =
      allEventsData.length >= EVENTS_BROWSER_LIMIT;
    if (!eventsScrollState.limitReached) {
      eventsScrollState.endReached = false;
    }
    eventsScrollState.filteredEnd = false;
    scheduleEventsRender();
    return true;
  }

  // Render events in table
  function getSearchTerm() {
    return (document.getElementById("eventSearch")?.value || "").toLowerCase();
  }

  function matchesSearch(event, searchTerm) {
    if (!searchTerm) return true;
    const haystacks = [
      event.category,
      event.subtype,
      event.message,
      event.reference_id,
      event.mint,
    ];
    return haystacks.some(
      (value) =>
        typeof value === "string" && value.toLowerCase().includes(searchTerm)
    );
  }

  function formatEventCountLabel(count) {
    const safe = Number.isFinite(count) ? count : 0;
    const plural = safe === 1 ? "event" : "events";
    return `${safe.toLocaleString()} ${plural}`;
  }

  function formatReferenceSnippet(value) {
    if (typeof value !== "string") return "";
    if (value.length <= 12) return value;
    return `${value.slice(0, 6)}‚Ä¶${value.slice(-6)}`;
  }

  function ensureEventsScrollGuard(hasRows) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;
    let guard = document.getElementById("events-scroll-guard");

    if (!hasRows) {
      if (guard && guard.parentElement === tbody) {
        tbody.removeChild(guard);
      }
      return;
    }

    if (!guard) {
      guard = document.createElement("tr");
      guard.id = "events-scroll-guard";
      guard.className = "scroll-guard-row";
      const cell = document.createElement("td");
      cell.colSpan = 6;
      cell.className = "scroll-guard-cell";
      guard.appendChild(cell);
    }

    if (!guard.parentElement || guard.parentElement !== tbody) {
      if (guard.parentElement) {
        guard.parentElement.removeChild(guard);
      }
      tbody.appendChild(guard);
    } else if (tbody.lastElementChild !== guard) {
      tbody.appendChild(guard);
    }
  }

  function setEventsScrollGuardState(state) {
    const cell = document.querySelector(
      "#events-scroll-guard .scroll-guard-cell"
    );
    if (!cell) return;
    cell.dataset.state = state || "idle";
    cell.classList.toggle("loading", state === "loading");
    if (state === "loading") {
      cell.textContent = "Loading more events‚Ä¶";
    } else if (state === "limit") {
      cell.textContent = `Loaded browser limit (${EVENTS_BROWSER_LIMIT.toLocaleString()} events)`;
    } else if (state === "end") {
      cell.textContent = allEventsData.length ? "No more results" : "";
    } else if (state === "filtered") {
      cell.textContent =
        "No more results match the current search. Clear filters to load older events.";
    } else {
      cell.textContent = "";
    }
  }

  function setupEventsScrollObserver() {
    if (eventsScrollState.observer) {
      eventsScrollState.observer.disconnect();
      eventsScrollState.observer = null;
    }

    if (eventsScrollState.loading || eventsScrollState.endReached) {
      return;
    }

    const guard = document.getElementById("events-scroll-guard");
    const container = document.querySelector(".table-wrap");
    if (!guard || !container || !guard.parentElement) {
      return;
    }

    eventsScrollState.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadOlderEvents();
          }
        });
      },
      { root: container, rootMargin: "320px 0px 0px 0px", threshold: 0 }
    );

    eventsScrollState.observer.observe(guard);
  }

  function getOldestEventId() {
    if (!allEventsData || allEventsData.length === 0) return null;
    const last = allEventsData[allEventsData.length - 1];
    const id = Number(last?.id ?? last?.event_id ?? last?.eventId);
    return Number.isFinite(id) ? id : null;
  }

  function updateEventsScrollControls(hasRows) {
    ensureEventsScrollGuard(hasRows);

    if (!hasRows) {
      setEventsScrollGuardState("idle");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.filteredEnd) {
      setEventsScrollGuardState("filtered");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.limitReached) {
      setEventsScrollGuardState("limit");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.endReached) {
      setEventsScrollGuardState("end");
      if (eventsScrollState.observer) {
        eventsScrollState.observer.disconnect();
        eventsScrollState.observer = null;
      }
      return;
    }

    if (eventsScrollState.loading) {
      setEventsScrollGuardState("loading");
    } else {
      setEventsScrollGuardState("idle");
    }

    setupEventsScrollObserver();
  }

  async function loadOlderEvents() {
    if (
      eventsScrollState.loading ||
      eventsScrollState.endReached ||
      eventsScrollState.limitReached
    ) {
      return;
    }

    const searchTerm = getSearchTerm();
    if (searchTerm) {
      eventsScrollState.filteredEnd = true;
      eventsScrollState.endReached = true;
      updateEventsScrollControls(allEventsData.length > 0);
      return;
    }

    eventsScrollState.filteredEnd = false;

    if (allEventsData.length >= EVENTS_BROWSER_LIMIT) {
      eventsScrollState.limitReached = true;
      updateEventsScrollControls(true);
      return;
    }

    const oldestId = getOldestEventId();
    if (!Number.isFinite(oldestId)) {
      eventsScrollState.endReached = true;
      updateEventsScrollControls(allEventsData.length > 0);
      return;
    }

    const remainingBeforeRequest = Math.max(
      0,
      EVENTS_BROWSER_LIMIT - allEventsData.length
    );
    if (remainingBeforeRequest <= 0) {
      eventsScrollState.limitReached = true;
      updateEventsScrollControls(true);
      return;
    }

    eventsScrollState.loading = true;
    updateEventsScrollControls(allEventsData.length > 0);

    const params = new URLSearchParams();
    params.set("before_id", oldestId.toString());
    params.set(
      "limit",
      Math.min(eventsScrollState.pageSize, remainingBeforeRequest).toString()
    );
    const category = document.getElementById("categoryFilter")?.value;
    const severity = document.getElementById("severityFilter")?.value;
    if (category) params.set("category", category);
    if (severity) params.set("severity", severity);

    try {
      const res = await fetch(`/api/events/before?${params.toString()}`);
      if (!res.ok) {
        throw new Error(`Failed to load older events (${res.status})`);
      }

      const payload = await res.json();
      const rows = Array.isArray(payload?.events) ? payload.events : [];
      if (!rows.length) {
        eventsScrollState.endReached = true;
        updateEventsScrollControls(allEventsData.length > 0);
        return;
      }

      const normalizedRows = rows
        .map((raw) => normalizeEvent(raw))
        .filter((ev) => ev && typeof ev.id === "number")
        .sort((a, b) => b.id - a.id);

      if (!normalizedRows.length) {
        eventsScrollState.endReached = true;
        updateEventsScrollControls(allEventsData.length > 0);
        return;
      }

      const remainingCapacity = Math.max(
        0,
        EVENTS_BROWSER_LIMIT - allEventsData.length
      );
      if (remainingCapacity <= 0) {
        eventsScrollState.limitReached = true;
        updateEventsScrollControls(true);
        return;
      }

      const toAppend = normalizedRows.slice(0, remainingCapacity);
      const uniqueToAppend = [];
      toAppend.forEach((event) => {
        const id = Number(event.id);
        if (!Number.isFinite(id)) {
          return;
        }
        if (!eventsStore.has(id)) {
          uniqueToAppend.push(event);
        }
        eventsStore.set(id, event);
        markEventDirty(id);
      });

      if (uniqueToAppend.length) {
        allEventsData = allEventsData.concat(uniqueToAppend);
      }

      if (toAppend.length < normalizedRows.length) {
        eventsScrollState.limitReached = true;
      }

      eventsScrollState.endReached = false;

      const fetchedCount = Array.isArray(payload?.events)
        ? payload.events.length
        : Number(payload?.count) || 0;
      snapshotState.totalAvailable = Math.max(
        snapshotState.totalAvailable || 0,
        fetchedCount,
        allEventsData.length
      );

      scheduleEventsRender({ forceFull: true });
    } catch (err) {
      console.error("[Events] Failed to load older events", err);
      Utils.showToast("‚ö†Ô∏è Failed to load more events", "warn");
    } finally {
      eventsScrollState.loading = false;
      updateEventsScrollControls(allEventsData.length > 0);
    }
  }

  function areIdArraysEqual(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i += 1) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  function createEventRow(event) {
    const row = document.createElement("tr");
    row.className = "event-row";
    row.style.borderBottom = "1px solid var(--border-color)";
    row.dataset.eventId = String(event.id);
    updateEventRow(row, event);
    return row;
  }

  function updateEventRow(row, event) {
    if (!row) return;
    const time = Utils.formatTimeAgo(new Date(event.event_time), {
      fallback: "-",
    });
    const severityColor = getSeverityColor(event.severity);
    let referenceCell = "-";
    if (event.reference_id) {
      const snippet = Utils.escapeHtml(
        formatReferenceSnippet(event.reference_id)
      );
      const full = Utils.escapeHtml(event.reference_id);
      const encoded = encodeURIComponent(event.reference_id);
      referenceCell = `
        <span class="event-ref" title="${full}">${snippet}</span>
        <button class="event-ref-copy" type="button" data-ref="${encoded}" title="Copy reference">üìã</button>
      `;
    }
    const messageText = Utils.escapeHtml(event.message);
    const categoryLabel = event.categoryLabel || event.category || "-";
    const severityLabel = (event.severity || "-").toString().toUpperCase();

    row.dataset.eventId = String(event.id);
    row.innerHTML = `
      <td style="padding: 10px; white-space: nowrap;">${time}</td>
      <td style="padding: 10px;">
        <span style="background: var(--badge-loading); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
          ${Utils.escapeHtml(categoryLabel)}
        </span>
      </td>
      <td style="padding: 10px; font-size: 0.9em;">${event.subtype || "-"}</td>
      <td style="padding: 10px;">
        <span style="background: ${severityColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
          ${severityLabel}
        </span>
      </td>
      <td style="padding: 10px; max-width: 420px;">
        <div class="event-message-cell">
          <span class="event-message-text" title="${messageText}">${messageText}</span>
          <button class="event-detail-btn" type="button" data-event-id="${
            event.id
          }" title="View full event">Details</button>
        </div>
      </td>
      <td style="padding: 10px; font-size: 0.85em;">
        <span class="event-ref-cell">${referenceCell}</span>
      </td>
    `;
  }

  function collectFilteredEvents() {
    const searchTerm = getSearchTerm();
    const filtered = [];
    const ids = [];
    for (const event of allEventsData) {
      if (!event) continue;
      if (!matchesSearch(event, searchTerm)) continue;
      const idNum = Number(event.id ?? event.event_id ?? event.eventId);
      if (!Number.isFinite(idNum)) continue;
      filtered.push(event);
      ids.push(idNum);
    }
    return { events: filtered, ids, searchTerm };
  }

  function setEventsEmptyState(message) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;
    tbody.innerHTML = `
      <tr>
        <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-muted);">
          ${message}
        </td>
      </tr>
    `;
  }

  function scheduleEventsRender(options) {
    const opts = Object.assign(
      { forceFull: false, immediate: false },
      options || {}
    );
    if (opts.forceFull) {
      eventsRenderState.forceFull = true;
    }

    if (opts.immediate) {
      if (eventsRenderState.rafId) {
        cancelAnimationFrame(eventsRenderState.rafId);
        eventsRenderState.rafId = null;
      }
      eventsRenderState.pending = false;
      applyScheduledEventsRender();
      return;
    }

    if (eventsRenderState.pending) {
      return;
    }

    eventsRenderState.pending = true;
    eventsRenderState.rafId = window.requestAnimationFrame(() => {
      eventsRenderState.rafId = null;
      eventsRenderState.pending = false;
      applyScheduledEventsRender();
    });
  }

  function applyScheduledEventsRender() {
    const forceFull = eventsRenderState.forceFull;
    eventsRenderState.forceFull = false;
    performEventsRender(forceFull);
  }

  function performEventsRender(forceFull) {
    const tbody = document.getElementById("eventsTableBody");
    if (!tbody) return;

    const {
      events: filtered,
      ids: filteredIds,
      searchTerm,
    } = collectFilteredEvents();

    if (!filtered || filtered.length === 0) {
      eventsRenderState.renderedIds = [];
      eventsRenderState.rowsById.clear();
      eventsRenderState.dirtyIds.clear();
      eventsRenderState.lastSearchTerm = searchTerm;

      const message = snapshotState.inProgress
        ? "üì¶ Receiving snapshot..."
        : connectionStatus === "error"
        ? "‚ö†Ô∏è Error loading events. Please check server status."
        : connectionStatus === "connecting"
        ? "üîÑ Connecting to server..."
        : connectionStatus === "paused"
        ? "‚è∏Ô∏è Events paused. Resume to receive new activity."
        : connectionStatus === "disconnected"
        ? "üì¥ Realtime connection lost. Waiting to resync..."
        : "üìã No events found. Events will appear here as they occur.";

      setEventsEmptyState(message);
      updateEventsScrollControls(false);
      return;
    }

    const sameIds = areIdArraysEqual(
      filteredIds,
      eventsRenderState.renderedIds
    );
    if (
      !forceFull &&
      eventsRenderState.dirtyIds.size === 0 &&
      sameIds &&
      eventsRenderState.lastSearchTerm === searchTerm
    ) {
      ensureEventsScrollGuard(true);
      updateEventsScrollControls(true);
      return;
    }

    const filteredIdSet = new Set(filteredIds);
    const attachMap = new Map();

    for (const id of filteredIds) {
      const row = eventsRenderState.rowsById.get(id);
      if (row && row.parentElement === tbody) {
        attachMap.set(id, row);
      }
    }

    for (const existingId of eventsRenderState.renderedIds) {
      if (!filteredIdSet.has(existingId)) {
        eventsRenderState.rowsById.delete(existingId);
      }
    }

    const fragment = document.createDocumentFragment();
    for (let index = 0; index < filteredIds.length; index += 1) {
      const id = filteredIds[index];
      const event = filtered[index];
      let row = eventsRenderState.rowsById.get(id);
      if (!row) {
        row = createEventRow(event);
        eventsRenderState.rowsById.set(id, row);
      } else if (forceFull || eventsRenderState.dirtyIds.has(id)) {
        updateEventRow(row, event);
      }
      if (attachMap.has(id)) {
        const existingRow = attachMap.get(id);
        if (existingRow !== row) {
          attachMap.set(id, row);
        }
      }
      fragment.appendChild(row);
    }

    if (tbody.firstChild) {
      while (
        tbody.firstChild &&
        tbody.firstChild.id !== "events-scroll-guard"
      ) {
        tbody.removeChild(tbody.firstChild);
      }
    }

    tbody.insertBefore(
      fragment,
      document.getElementById("events-scroll-guard")
    );

    eventsRenderState.renderedIds = filteredIds.slice();
    eventsRenderState.dirtyIds.clear();
    eventsRenderState.lastSearchTerm = searchTerm;

    ensureEventsScrollGuard(true);
    updateEventsScrollControls(true);
  }

  // Get color for severity
  function getSeverityColor(severity) {
    const key = (severity || "").toLowerCase();
    const colors = {
      info: "var(--badge-online)",
      warn: "var(--badge-loading)",
      error: "var(--badge-error)",
      debug: "#6b7280",
    };
    return colors[key] || "#6b7280";
  }

  // Search events
  document.getElementById("eventSearch").addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    AppState.save("events_search", searchTerm);
    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }
    searchDebounceHandle = setTimeout(() => {
      eventsScrollState.filteredEnd = false;
      eventsScrollState.endReached = false;
      eventsScrollState.limitReached = false;
      scheduleEventsRender({ forceFull: true });
    }, 120);
  });

  // Filter by category
  document.getElementById("categoryFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying category filter...");
    AppState.save(
      "events_category",
      document.getElementById("categoryFilter").value
    );
  });

  // Filter by severity
  document.getElementById("severityFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying severity filter...");
    AppState.save(
      "events_severity",
      document.getElementById("severityFilter").value
    );
  });

  // Refresh button
  document
    .getElementById("refreshEvents")
    .addEventListener("click", () =>
      requestEventsSnapshot("Refreshing events...")
    );

  document.getElementById("toggleEventsPause").addEventListener("click", () => {
    const nextPaused = !isEventsPaused();
    applyEventsPauseState(nextPaused, {
      message: nextPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : "Resuming events...",
    });
  });

  // Reference copy handler
  document
    .getElementById("eventsTableBody")
    .addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".event-ref-copy");
      if (copyBtn) {
        const encoded = copyBtn.getAttribute("data-ref");
        if (!encoded) return;
        const reference = decodeURIComponent(encoded);
        try {
          await Utils.copyToClipboard(reference);
          Utils.showToast("‚úÖ Reference copied to clipboard");
        } catch (err) {
          console.error("Failed to copy reference:", err);
          Utils.showToast("‚ùå Failed to copy reference", "error");
        }
        return;
      }

      const detailBtn = event.target.closest(".event-detail-btn");
      if (detailBtn) {
        const idAttr = detailBtn.getAttribute("data-event-id");
        const eventId = Number(idAttr);
        if (Number.isFinite(eventId)) {
          openEventDetailModal(eventId);
        }
      }
    });

  const eventDetailModal = document.getElementById("eventDetailModal");
  const eventDetailClose = document.getElementById("eventDetailClose");

  function openEventDetailModal(eventId) {
    if (!eventDetailModal) return;
    const eventData = eventsStore.get(eventId);
    if (!eventData) {
      Utils.showToast("‚ùå Event details unavailable", "error");
      return;
    }

    const categoryLabel =
      eventData.categoryLabel || eventData.category || "event";
    document.getElementById(
      "eventDetailTitle"
    ).textContent = `${categoryLabel.toUpperCase()} ‚Ä¢ #${eventData.id}`;
    document.getElementById("eventDetailCategory").textContent = categoryLabel;
    document.getElementById("eventDetailSeverity").textContent = (
      eventData.severity || "-"
    ).toUpperCase();
    document.getElementById("eventDetailTime").textContent =
      eventData.event_time
        ? new Date(eventData.event_time).toLocaleString()
        : "-";
    document.getElementById("eventDetailReference").textContent =
      eventData.reference_id || "‚Äî";
    document.getElementById("eventDetailMint").textContent =
      eventData.mint || "‚Äî";

    const payloadEl = document.getElementById("eventDetailPayload");
    if (eventData.payload !== null && eventData.payload !== undefined) {
      try {
        payloadEl.textContent = JSON.stringify(eventData.payload, null, 2);
      } catch (err) {
        console.error("Failed to stringify payload:", err);
        payloadEl.textContent = "Unable to render payload.";
      }
    } else {
      payloadEl.textContent = "No payload data available.";
    }

    eventDetailModal.classList.add("show");
  }

  function closeEventDetailModal() {
    if (!eventDetailModal) return;
    eventDetailModal.classList.remove("show");
  }

  if (eventDetailClose) {
    eventDetailClose.addEventListener("click", closeEventDetailModal);
  }
  if (eventDetailModal) {
    eventDetailModal.addEventListener("click", (event) => {
      if (event.target === eventDetailModal) {
        closeEventDetailModal();
      }
    });
  }

  document.addEventListener("keydown", (event) => {
    if (
      event.key === "Escape" &&
      eventDetailModal &&
      eventDetailModal.classList.contains("show")
    ) {
      closeEventDetailModal();
    }
  });

  function restoreSavedFilters() {
    const categoryFilter = document.getElementById("categoryFilter");
    const severityFilter = document.getElementById("severityFilter");
    const searchInput = document.getElementById("eventSearch");

    if (categoryFilter) {
      const savedCategory = AppState.load("events_category", "");
      if (savedCategory) categoryFilter.value = savedCategory;
    }

    if (severityFilter) {
      const savedSeverity = AppState.load("events_severity", "");
      if (savedSeverity) severityFilter.value = savedSeverity;
    }

    if (searchInput) {
      const savedSearch = AppState.load("events_search", "");
      if (savedSearch) searchInput.value = savedSearch;
    }
  }

  function initializePauseState() {
    updatePauseButtonUI();
    const savedPaused = AppState.load("events_paused", "") === "1";
    if (savedPaused) {
      eventsPauseState.paused = true;
      updatePauseButtonUI();
    }
  }

  // Global init function for Router to call during SPA navigation
  window.initEventsPage = function () {
    console.log("[Events] Initializing page");
    restoreSavedFilters();
    initializePauseState();
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  window.initEventsPage();
</script>
