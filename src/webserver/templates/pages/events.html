<div class="page-section">
  <div class="toolbar">
    <span style="font-weight: 600">üì° Events</span>
    <input
      type="text"
      id="eventSearch"
      placeholder="üîç Search events..."
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <select
      id="categoryFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="  }

  // Silent refresh every secondies</option>
      <option value="swap">Swap</option>
      <option value="transaction">Transaction</option>
      <option value="pool">Pool</option>
      <option value="token">Token</option>
      <option value="position">Position</option>
      <option value="security">Security</option>
      <option value="entry">Entry</option>
      <option value="system">System</option>
    </select>
    <select
      id="severityFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="">All Severity</option>
      <option value="info">Info</option>
      <option value="warn">Warning</option>
      <option value="error">Error</option>
      <option value="debug">Debug</option>
    </select>
    <div class="spacer"></div>
    <span
      id="eventsCountText"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button id="refreshEvents" class="btn btn-primary">üîÑ Refresh</button>
  </div>
  <style>
    .event-ref-cell {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: monospace;
    }

    .event-ref {
      color: var(--text-primary);
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .event-ref-copy {
      background: none;
      border: none;
      color: var(--link-color);
      cursor: pointer;
      font-size: 0.8em;
      padding: 2px 4px;
      border-radius: 4px;
      transition: color 0.2s ease;
    }

    .event-ref-copy:hover,
    .event-ref-copy:focus {
      color: var(--link-hover);
      outline: none;
    }

    .event-message-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .event-message-text {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .event-detail-btn {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.75em;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .event-detail-btn:hover,
    .event-detail-btn:focus {
      color: var(--link-color);
      border-color: var(--link-color);
      outline: none;
    }

    .event-detail-modal {
      max-width: 680px;
      width: calc(100% - 48px);
    }

    .event-detail-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .event-detail-meta .meta-label {
      display: block;
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .event-detail-meta .meta-value {
      display: block;
      font-size: 0.9em;
      color: var(--text-primary);
      word-break: break-all;
      margin-top: 2px;
    }

    .event-detail-json-wrapper {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      max-height: 320px;
      overflow: auto;
    }

    .event-detail-json {
      margin: 0;
      padding: 12px;
      font-size: 0.85em;
      line-height: 1.4;
      color: var(--text-primary);
    }
  </style>
  <div class="table-scroll">
    <table class="table" id="eventsTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Category</th>
          <th>Subtype</th>
          <th>Severity</th>
          <th>Message</th>
          <th>Reference</th>
        </tr>
      </thead>
      <tbody id="eventsTableBody">
        <tr>
          <td
            colspan="6"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading events...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <div id="eventDetailModal" class="modal-overlay">
    <div class="modal-content event-detail-modal">
      <div class="modal-header">
        <span class="modal-title" id="eventDetailTitle">Event Details</span>
        <button
          id="eventDetailClose"
          class="modal-close"
          type="button"
          aria-label="Close"
        >
          √ó
        </button>
      </div>
      <div class="modal-body">
        <div class="event-detail-meta">
          <div>
            <span class="meta-label">Category</span>
            <span class="meta-value" id="eventDetailCategory">-</span>
          </div>
          <div>
            <span class="meta-label">Severity</span>
            <span class="meta-value" id="eventDetailSeverity">-</span>
          </div>
          <div>
            <span class="meta-label">Time</span>
            <span class="meta-value" id="eventDetailTime">-</span>
          </div>
          <div>
            <span class="meta-label">Reference</span>
            <span class="meta-value" id="eventDetailReference">-</span>
          </div>
          <div>
            <span class="meta-label">Mint</span>
            <span class="meta-value" id="eventDetailMint">-</span>
          </div>
        </div>
        <div class="event-detail-json-wrapper">
          <pre id="eventDetailPayload" class="event-detail-json">
Loading...</pre
          >
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var allEventsData = [];
  var eventsRefreshInterval = null;
  var maxEventId = 0;
  var connectionStatus = "connecting"; // 'connecting', 'connected', 'disconnected', 'error'
  var eventsStore = window.eventsStore || new Map();
  var EVENT_MAX_RECORDS = 1000;
  var eventsLoadInFlight = false;
  var pendingEventsLoad = false;
  var searchDebounceHandle = null;

  // Update connection status indicator
  function updateConnectionStatus(status, message) {
    connectionStatus = status;
    const indicator = document.getElementById("eventsCountText");
    if (!indicator) return;
    const colors = {
      connecting: "var(--text-secondary)",
      connected: "var(--badge-online)",
      disconnected: "var(--badge-loading)",
      error: "var(--badge-error)",
    };
    const icons = {
      connecting: "‚è≥",
      connected: "‚úÖ",
      disconnected: "‚ö†Ô∏è",
      error: "‚ùå",
    };
    const defaults = {
      connecting: "Connecting‚Ä¶",
      connected: "Connected",
      disconnected: "Disconnected",
      error: "Error",
    };
    const icon = icons[status] || "‚ÑπÔ∏è";
    const text = message || defaults[status] || "Status unavailable";
    indicator.style.color = colors[status] || "var(--text-secondary)";
    indicator.textContent = `${icon} ${text}`;
    indicator.dataset.status = status;
    indicator.title = text;
  }

  function clearEventsCache() {
    eventsStore.clear();
    allEventsData = [];
  }

  function normalizeEvent(raw) {
    if (!raw || typeof raw !== "object") return null;
    const severity = (raw.severity || "").toLowerCase();
    const message = raw.message ?? "No message";
    return {
      ...raw,
      severity,
      message,
      payload: raw.payload ?? null,
    };
  }

  function hasEventChanged(existing, next) {
    if (!existing) return true;
    return (
      existing.message !== next.message ||
      existing.severity !== next.severity ||
      existing.category !== next.category ||
      existing.subtype !== next.subtype ||
      existing.reference_id !== next.reference_id ||
      existing.event_time !== next.event_time ||
      existing.mint !== next.mint ||
      JSON.stringify(existing.payload) !== JSON.stringify(next.payload)
    );
  }

  function matchesActiveFilters(event) {
    const category = document.getElementById("categoryFilter")?.value || "";
    const severity = document.getElementById("severityFilter")?.value || "";
    if (category && event.category !== category) return false;
    if (severity && event.severity !== severity) return false;
    return true;
  }

  function mergeEvents(events) {
    if (!Array.isArray(events) || events.length === 0) {
      return false;
    }

    let updated = false;
    for (const raw of events) {
      const event = normalizeEvent(raw);
      if (!event || typeof event.id !== "number") continue;
      if (!matchesActiveFilters(event)) continue;
      const eventId = Number(event.id);
      const existing = eventsStore.get(eventId);
      if (hasEventChanged(existing, event)) {
        eventsStore.set(eventId, event);
        updated = true;
      }
    }

    if (!updated) {
      return false;
    }

    const orderedIds = Array.from(eventsStore.keys()).sort((a, b) => b - a);
    if (orderedIds.length > EVENT_MAX_RECORDS) {
      for (let i = EVENT_MAX_RECORDS; i < orderedIds.length; i++) {
        eventsStore.delete(orderedIds[i]);
      }
      orderedIds.length = EVENT_MAX_RECORDS;
    }

    allEventsData = orderedIds.map((id) => eventsStore.get(id));
    renderEvents();
    return true;
  }

  function stopEventsRefresh() {
    if (eventsRefreshInterval) {
      clearInterval(eventsRefreshInterval);
      eventsRefreshInterval = null;
    }
  }

  // Load events from API
  async function loadEvents(options = {}) {
    const { force = false } = options;
    if (eventsLoadInFlight) {
      if (force) {
        pendingEventsLoad = true;
      }
      return;
    }

    const category = document.getElementById("categoryFilter").value;
    const severity = document.getElementById("severityFilter").value;
    const params = new URLSearchParams();
    params.set("limit", "200");
    if (category) params.set("category", category);
    if (severity) params.set("severity", severity);

    let url = "";
    const isInitialLoad = force || maxEventId === 0;
    try {
      eventsLoadInFlight = true;
      if (isInitialLoad) {
        url = `/api/events/head?${params.toString()}`;
        updateConnectionStatus("connecting", "Loading events...");
      } else {
        params.set("after_id", String(maxEventId));
        url = `/api/events/since?${params.toString()}`;
      }

      const res = await fetch(url, { cache: "no-cache" });
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }

      const data = await res.json();
      const payload = Array.isArray(data.events) ? data.events : [];

      if (isInitialLoad) {
        clearEventsCache();
      }

      const added = mergeEvents(payload);
      if (added) {
        const highestFromPayload = payload.reduce(
          (max, evt) =>
            evt && typeof evt.id === "number" ? Math.max(max, evt.id) : max,
          0
        );
        maxEventId = Math.max(maxEventId, data.max_id || 0, highestFromPayload);
      } else if (isInitialLoad) {
        renderEvents();
        maxEventId = Math.max(maxEventId, data.max_id || 0);
      }

      const totalEvents = allEventsData.length;
      const countLabel = formatEventCountLabel(totalEvents);
      if (eventsRefreshInterval) {
        updateConnectionStatus("disconnected", `Polling ‚Ä¢ ${countLabel}`);
      } else {
        updateConnectionStatus("connected", `Realtime ‚Ä¢ ${countLabel}`);
      }

      AppState.save("events_category", category);
      AppState.save("events_severity", severity);
    } catch (error) {
      console.error("Failed to load events:", error);

      let errorMsg = "Failed to connect to server";
      if (error.message.includes("Failed to fetch")) {
        errorMsg = "Server not responding - check if bot is running";
      } else if (error.message.includes("HTTP")) {
        errorMsg = `Server error: ${error.message}`;
      }

      document.getElementById("eventsTableBody").innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px;">
                            <div style="color: var(--badge-error); margin-bottom: 10px;">‚ùå ${errorMsg}</div>
                            <div style="color: var(--text-muted); font-size: 0.9em;">
                                Retrying automatically... or click Refresh to try again
                            </div>
                        </td>
                    </tr>
                `;
      updateConnectionStatus("error", errorMsg);
      startEventsRefresh(3000);
    } finally {
      eventsLoadInFlight = false;
      if (pendingEventsLoad) {
        pendingEventsLoad = false;
        loadEvents();
      }
    }
  }

  // Render events in table
  function getSearchTerm() {
    return (document.getElementById("eventSearch")?.value || "").toLowerCase();
  }

  function matchesSearch(event, searchTerm) {
    if (!searchTerm) return true;
    const haystacks = [
      event.category,
      event.subtype,
      event.message,
      event.reference_id,
      event.mint,
    ];
    return haystacks.some(
      (value) =>
        typeof value === "string" && value.toLowerCase().includes(searchTerm)
    );
  }

  function formatEventCountLabel(count) {
    const safe = Number.isFinite(count) ? count : 0;
    const plural = safe === 1 ? "event" : "events";
    return `${safe.toLocaleString()} ${plural}`;
  }

  function formatReferenceSnippet(value) {
    if (typeof value !== "string") return "";
    if (value.length <= 12) return value;
    return `${value.slice(0, 6)}‚Ä¶${value.slice(-6)}`;
  }

  function renderEvents(forcedEvents) {
    const tbody = document.getElementById("eventsTableBody");
    const searchTerm = getSearchTerm();
    const events = Array.isArray(forcedEvents) ? forcedEvents : allEventsData;
    const filtered = events.filter((event) => matchesSearch(event, searchTerm));

    if (!filtered || filtered.length === 0) {
      const message =
        connectionStatus === "error"
          ? "‚ö†Ô∏è Error loading events. Please check server status."
          : connectionStatus === "connecting"
          ? "üîÑ Connecting to server..."
          : "üìã No events found. Events will appear here as they occur.";

      tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-muted);">
                            ${message}
                        </td>
                    </tr>
                `;
      return;
    }

    tbody.innerHTML = filtered
      .map((event) => {
        const time = Utils.formatTimeAgo(new Date(event.event_time), { fallback: "-" });
        const severityColor = getSeverityColor(event.severity);
        let referenceCell = "-";
        if (event.reference_id) {
          const snippet = Utils.escapeHtml(
            formatReferenceSnippet(event.reference_id)
          );
          const full = Utils.escapeHtml(event.reference_id);
          const encoded = encodeURIComponent(event.reference_id);
          referenceCell = `
                        <span class="event-ref" title="${full}">${snippet}</span>
                        <button class="event-ref-copy" type="button" data-ref="${encoded}" title="Copy reference">üìã</button>
                    `;
        }
        const messageText = Utils.escapeHtml(event.message);
        const detailButton = `<button class="event-detail-btn" type="button" data-event-id="${event.id}" title="View full event">Details</button>`;

        return `
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 10px; white-space: nowrap;">${time}</td>
                        <td style="padding: 10px;">
                            <span style="background: var(--badge-loading); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
                                ${event.category}
                            </span>
                        </td>
                        <td style="padding: 10px; font-size: 0.9em;">${
                          event.subtype || "-"
                        }</td>
                        <td style="padding: 10px;">
                            <span style="background: ${severityColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
                                ${event.severity.toUpperCase()}
                            </span>
                        </td>
                        <td style="padding: 10px; max-width: 420px;">
                            <div class="event-message-cell">
                                <span class="event-message-text" title="${messageText}">${messageText}</span>
                                ${detailButton}
                            </div>
                        </td>
                        <td style="padding: 10px; font-size: 0.85em;">
                            <span class="event-ref-cell">${referenceCell}</span>
                        </td>
                    </tr>
                `;
      })
      .join("");
  }

  // Get color for severity
  function getSeverityColor(severity) {
    const key = (severity || "").toLowerCase();
    const colors = {
      info: "var(--badge-online)",
      warn: "var(--badge-loading)",
      error: "var(--badge-error)",
      debug: "#6b7280",
    };
    return colors[key] || "#6b7280";
  }

  // Search events
  document.getElementById("eventSearch").addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    AppState.save("events_search", searchTerm);
    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }
    searchDebounceHandle = setTimeout(() => {
      renderEvents();
    }, 120);
  });

  // Filter by category
  document.getElementById("categoryFilter").addEventListener("change", () => {
    maxEventId = 0; // Reset to get fresh data with new filter
    allEventsData = [];
    clearEventsCache();
    loadEvents();
  });

  // Filter by severity
  document.getElementById("severityFilter").addEventListener("change", () => {
    maxEventId = 0; // Reset to get fresh data with new filter
    allEventsData = [];
    clearEventsCache();
    loadEvents();
  });

  // Refresh button
  document
    .getElementById("refreshEvents")
    .addEventListener("click", loadEvents);

  // Reference copy handler
  document
    .getElementById("eventsTableBody")
    .addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".event-ref-copy");
      if (copyBtn) {
        const encoded = copyBtn.getAttribute("data-ref");
        if (!encoded) return;
        const reference = decodeURIComponent(encoded);
        try {
          await Utils.copyToClipboard(reference);
          Utils.showToast("‚úÖ Reference copied to clipboard");
        } catch (err) {
          console.error("Failed to copy reference:", err);
          Utils.showToast("‚ùå Failed to copy reference", "error");
        }
        return;
      }

      const detailBtn = event.target.closest(".event-detail-btn");
      if (detailBtn) {
        const idAttr = detailBtn.getAttribute("data-event-id");
        const eventId = Number(idAttr);
        if (Number.isFinite(eventId)) {
          openEventDetailModal(eventId);
        }
      }
    });

  const eventDetailModal = document.getElementById("eventDetailModal");
  const eventDetailClose = document.getElementById("eventDetailClose");

  function openEventDetailModal(eventId) {
    if (!eventDetailModal) return;
    const eventData = eventsStore.get(eventId);
    if (!eventData) {
      Utils.showToast("‚ùå Event details unavailable", "error");
      return;
    }

    document.getElementById("eventDetailTitle").textContent = `${(
      eventData.category || "event"
    ).toUpperCase()} ‚Ä¢ #${eventData.id}`;
    document.getElementById("eventDetailCategory").textContent = (
      eventData.category || "-"
    ).toUpperCase();
    document.getElementById("eventDetailSeverity").textContent = (
      eventData.severity || "-"
    ).toUpperCase();
    document.getElementById("eventDetailTime").textContent =
      eventData.event_time
        ? new Date(eventData.event_time).toLocaleString()
        : "-";
    document.getElementById("eventDetailReference").textContent =
      eventData.reference_id || "‚Äî";
    document.getElementById("eventDetailMint").textContent =
      eventData.mint || "‚Äî";

    const payloadEl = document.getElementById("eventDetailPayload");
    if (eventData.payload !== null && eventData.payload !== undefined) {
      try {
        payloadEl.textContent = JSON.stringify(eventData.payload, null, 2);
      } catch (err) {
        console.error("Failed to stringify payload:", err);
        payloadEl.textContent = "Unable to render payload.";
      }
    } else {
      payloadEl.textContent = "No payload data available.";
    }

    eventDetailModal.classList.add("show");
  }

  function closeEventDetailModal() {
    if (!eventDetailModal) return;
    eventDetailModal.classList.remove("show");
  }

  if (eventDetailClose) {
    eventDetailClose.addEventListener("click", closeEventDetailModal);
  }
  if (eventDetailModal) {
    eventDetailModal.addEventListener("click", (event) => {
      if (event.target === eventDetailModal) {
        closeEventDetailModal();
      }
    });
  }

  document.addEventListener("keydown", (event) => {
    if (
      event.key === "Escape" &&
      eventDetailModal &&
      eventDetailModal.classList.contains("show")
    ) {
      closeEventDetailModal();
    }
  });

  // Time formatting
  function formatTimeAgo(date) {
    return Utils.formatTimeAgo(date, { fallback: "-" });
  }

  // HTML escape
  function escapeHtml(text) {
    return Utils.escapeHtml(text);
  }

  // Silent refresh every second
  function startEventsRefresh(intervalMs = 2000) {
    if (eventsRefreshInterval) return;
    eventsRefreshInterval = setInterval(() => {
      loadEvents();
    }, intervalMs);

    if (window.Router && typeof Router.registerCleanup === "function") {
      Router.registerCleanup(() => {
        if (eventsRefreshInterval) {
          clearInterval(eventsRefreshInterval);
          eventsRefreshInterval = null;
        }
      });
    }
  }

  // Handle incoming event from WebSocket
  function handleEventsWebSocket(event) {
    // Handle lag warning
    if (event.warning === "lagged") {
      console.warn("[Events] WebSocket lagged, catching up via HTTP");
      updateConnectionStatus(
        "disconnected",
        "Connection lagged, catching up..."
      );
      startEventsRefresh(1500);
      loadEvents();
      return;
    }

    // Add new event to list
    if (event && typeof event.id === "number") {
      if (!matchesActiveFilters(normalizeEvent(event))) {
        return;
      }
      maxEventId = Math.max(maxEventId, event.id);
      mergeEvents([event]);
      updateConnectionStatus(
        "connected",
        `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
      );
    }
  }

  // Handle WebSocket warnings (lag detection)
  function handleWebSocketWarning(data) {
    if (data.channel === "events") {
      console.warn("[Events] Channel warning:", data);
      updateConnectionStatus(
        "disconnected",
        `Polling ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
      );
      startEventsRefresh(2000);
      loadEvents();
    }
  }

  function handleEventsDisconnect() {
    console.warn("[Events] WebSocket disconnected, switching to polling");
    updateConnectionStatus(
      "disconnected",
      `Polling ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
    );
    startEventsRefresh(3000);
  }

  function handleEventsReconnect() {
    console.log("[Events] WebSocket reconnected");
    stopEventsRefresh();
    updateConnectionStatus(
      "connected",
      `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
    );
    if (!allEventsData.length) {
      loadEvents({ force: true });
    }
  }
  // Global init function for Router to call during SPA navigation
  window.initEventsPage = function () {
    console.log("[Events] Initializing page");

    // Restore saved filters (wait for DOM to be ready)
    const categoryFilter = document.getElementById("categoryFilter");
    const severityFilter = document.getElementById("severityFilter");
    const searchInput = document.getElementById("eventSearch");

    if (categoryFilter) {
      const savedCategory = AppState.load("events_category", "");
      if (savedCategory) categoryFilter.value = savedCategory;
    }

    if (severityFilter) {
      const savedSeverity = AppState.load("events_severity", "");
      if (savedSeverity) severityFilter.value = savedSeverity;
    }

    if (searchInput) {
      const savedSearch = AppState.load("events_search", "");
      if (savedSearch) searchInput.value = savedSearch;
    }

    // Initial load
    loadEvents({ force: true });
  };

  window.PageRealtime = window.PageRealtime || {};
  window.PageRealtime.events = {
    channels: {
      events: handleEventsWebSocket,
      _warning: handleWebSocketWarning,
      _disconnected: handleEventsDisconnect,
      _failed: handleEventsDisconnect,
      _connected: handleEventsReconnect,
    },
    onInitial(status) {
      if (status === "connected") {
        updateConnectionStatus(
          "connected",
          `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        );
        stopEventsRefresh();
      } else if (status === "connecting") {
        updateConnectionStatus("connecting", "Connecting to WebSocket...");
      } else {
        updateConnectionStatus(
          "disconnected",
          `Polling ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        );
        startEventsRefresh(3000);
      }
    },
    onUnavailable() {
      console.warn(
        "[Events] WebSocket unavailable, falling back to HTTP polling"
      );
      updateConnectionStatus("disconnected", "WebSocket unavailable (polling)");
      startEventsRefresh(3000);
    },
    onExit() {
      stopEventsRefresh();
    },
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  initEventsPage();
</script>
