<div class="page-section">
  <div class="toolbar">
    <span style="font-weight: 600">üì° Events</span>
    <input
      type="text"
      id="eventSearch"
      placeholder="üîç Search events..."
      style="
        flex: 1;
        min-width: 200px;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    />
    <select
      id="categoryFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="">All Categories</option>
      <option value="swap">Swap</option>
      <option value="transaction">Transaction</option>
      <option value="pool">Pool</option>
      <option value="token">Token</option>
      <option value="position">Position</option>
      <option value="security">Security</option>
      <option value="entry">Entry</option>
      <option value="system">System</option>
    </select>
    <select
      id="severityFilter"
      style="
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        color: var(--text-primary);
      "
    >
      <option value="">All Severity</option>
      <option value="info">Info</option>
      <option value="warn">Warning</option>
      <option value="error">Error</option>
      <option value="debug">Debug</option>
    </select>
    <div class="spacer"></div>
    <span
      id="eventsCountText"
      style="color: var(--text-secondary); font-size: 0.9em"
      >Loading...</span
    >
    <button id="toggleEventsPause" class="btn">‚è∏Ô∏è Pause</button>
    <button id="refreshEvents" class="btn btn-primary">üîÑ Refresh</button>
  </div>
  <style>
    .event-ref-cell {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: monospace;
    }

    .event-ref {
      color: var(--text-primary);
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .event-ref-copy {
      background: none;
      border: none;
      color: var(--link-color);
      cursor: pointer;
      font-size: 0.8em;
      padding: 2px 4px;
      border-radius: 4px;
      transition: color 0.2s ease;
    }

    .event-ref-copy:hover,
    .event-ref-copy:focus {
      color: var(--link-hover);
      outline: none;
    }

    .event-message-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .event-message-text {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .event-detail-btn {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.75em;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .event-detail-btn:hover,
    .event-detail-btn:focus {
      color: var(--link-color);
      border-color: var(--link-color);
      outline: none;
    }

    .event-detail-modal {
      max-width: 680px;
      width: calc(100% - 48px);
    }

    .event-detail-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }

    .event-detail-meta .meta-label {
      display: block;
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .event-detail-meta .meta-value {
      display: block;
      font-size: 0.9em;
      color: var(--text-primary);
      word-break: break-all;
      margin-top: 2px;
    }

    .event-detail-json-wrapper {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      max-height: 320px;
      overflow: auto;
    }

    .event-detail-json {
      margin: 0;
      padding: 12px;
      font-size: 0.85em;
      line-height: 1.4;
      color: var(--text-primary);
    }
  </style>
  <div class="table-scroll">
    <table class="table" id="eventsTable">
      <thead>
        <tr>
          <th>Time</th>
          <th>Category</th>
          <th>Subtype</th>
          <th>Severity</th>
          <th>Message</th>
          <th>Reference</th>
        </tr>
      </thead>
      <tbody id="eventsTableBody">
        <tr>
          <td
            colspan="6"
            style="text-align: center; padding: 20px; color: var(--text-muted)"
          >
            Loading events...
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <div id="eventDetailModal" class="modal-overlay">
    <div class="modal-content event-detail-modal">
      <div class="modal-header">
        <span class="modal-title" id="eventDetailTitle">Event Details</span>
        <button
          id="eventDetailClose"
          class="modal-close"
          type="button"
          aria-label="Close"
        >
          √ó
        </button>
      </div>
      <div class="modal-body">
        <div class="event-detail-meta">
          <div>
            <span class="meta-label">Category</span>
            <span class="meta-value" id="eventDetailCategory">-</span>
          </div>
          <div>
            <span class="meta-label">Severity</span>
            <span class="meta-value" id="eventDetailSeverity">-</span>
          </div>
          <div>
            <span class="meta-label">Time</span>
            <span class="meta-value" id="eventDetailTime">-</span>
          </div>
          <div>
            <span class="meta-label">Reference</span>
            <span class="meta-value" id="eventDetailReference">-</span>
          </div>
          <div>
            <span class="meta-label">Mint</span>
            <span class="meta-value" id="eventDetailMint">-</span>
          </div>
        </div>
        <div class="event-detail-json-wrapper">
          <pre id="eventDetailPayload" class="event-detail-json">
Loading...</pre
          >
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  var allEventsData = [];
  var maxEventId = 0;
  var connectionStatus = "connecting"; // 'connecting', 'connected', 'disconnected', 'error'
  var eventsStore = window.eventsStore || new Map();
  var EVENT_MAX_RECORDS = 100;
  var EVENTS_SNAPSHOT_TIMEOUT_MS = 12000;
  var searchDebounceHandle = null;
  var snapshotState = {
    inProgress: false,
    started: false,
    expected: 0,
    received: 0,
    totalAvailable: 0,
    requestId: null,
    context: null,
    timeoutHandle: null,
    lastTimerReason: null,
  };
  var eventsPauseState = {
    paused: false,
    pending: false,
  };

  function isEventsPaused() {
    return eventsPauseState.paused;
  }

  function updatePauseButtonUI() {
    const btn = document.getElementById("toggleEventsPause");
    if (!btn) return;
    const { paused, pending } = eventsPauseState;
    btn.disabled = pending;
    btn.classList.remove("btn-secondary");

    if (pending) {
      btn.textContent = paused ? "‚è≥ Resuming..." : "‚è≥ Pausing...";
      return;
    }

    if (paused) {
      btn.textContent = "‚ñ∂Ô∏è Resume";
      btn.classList.add("btn-secondary");
    } else {
      btn.textContent = "‚è∏Ô∏è Pause";
    }
  }

  function applyEventsPauseState(targetPaused, options) {
    const opts = Object.assign(
      {
        sendCommand: true,
        refreshSnapshot: !targetPaused,
        silent: false,
        force: false,
        message: null,
      },
      options || {}
    );

    if (eventsPauseState.pending) {
      return false;
    }

    if (!opts.force && eventsPauseState.paused === targetPaused) {
      if (opts.message) {
        const statusKey = targetPaused ? "paused" : "connected";
        updateConnectionStatus(statusKey, opts.message);
      }
      return true;
    }

    if (opts.sendCommand) {
      const realtime = window.Realtime;
      if (!realtime || typeof realtime.setEventsPaused !== "function") {
        if (!opts.silent) {
          Utils.showToast("‚ö†Ô∏è Realtime controller unavailable", "warn");
        }
        return false;
      }

      eventsPauseState.pending = true;
      updatePauseButtonUI();

      const success = realtime.setEventsPaused("events", targetPaused);
      if (!success) {
        eventsPauseState.pending = false;
        updatePauseButtonUI();
        if (!opts.silent) {
          Utils.showToast("‚ö†Ô∏è Failed to update realtime pause state", "warn");
        }
        return false;
      }

      eventsPauseState.pending = false;
    }

    eventsPauseState.paused = targetPaused;
    AppState.save("events_paused", targetPaused ? "1" : "");
    updatePauseButtonUI();

    const statusMessage =
      opts.message ||
      (targetPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`);

    if (targetPaused) {
      updateConnectionStatus("paused", statusMessage);
      if (opts.refreshSnapshot) {
        requestEventsSnapshot(
          opts.message || "Refreshing events while paused..."
        );
      }
    } else if (opts.refreshSnapshot !== false) {
      requestEventsSnapshot(opts.message || "Resuming events...");
    } else {
      updateConnectionStatus("connected", statusMessage);
    }

    return true;
  }

  // Update connection status indicator
  function updateConnectionStatus(status, message) {
    connectionStatus = status;
    const indicator = document.getElementById("eventsCountText");
    if (!indicator) return;
    const colors = {
      connecting: "var(--text-secondary)",
      connected: "var(--badge-online)",
      disconnected: "var(--badge-loading)",
      error: "var(--badge-error)",
      paused: "var(--badge-loading)",
    };
    const icons = {
      connecting: "‚è≥",
      connected: "‚úÖ",
      disconnected: "‚ö†Ô∏è",
      error: "‚ùå",
      paused: "‚è∏Ô∏è",
    };
    const defaults = {
      connecting: "Connecting‚Ä¶",
      connected: "Connected",
      disconnected: "Disconnected",
      error: "Error",
      paused: "Paused",
    };
    const icon = icons[status] || "‚ÑπÔ∏è";
    const text = message || defaults[status] || "Status unavailable";
    indicator.style.color = colors[status] || "var(--text-secondary)";
    indicator.textContent = `${icon} ${text}`;
    indicator.dataset.status = status;
    indicator.title = text;
  }

  function clearEventsCache() {
    eventsStore.clear();
    allEventsData = [];
    snapshotState.totalAvailable = 0;
    snapshotState.received = 0;
  }

  function clearEventsSnapshotTimer() {
    if (snapshotState.timeoutHandle) {
      clearTimeout(snapshotState.timeoutHandle);
      snapshotState.timeoutHandle = null;
    }
    snapshotState.lastTimerReason = null;
  }

  function scheduleEventsSnapshotTimer(reason) {
    clearEventsSnapshotTimer();

    if (
      !Number.isFinite(EVENTS_SNAPSHOT_TIMEOUT_MS) ||
      EVENTS_SNAPSHOT_TIMEOUT_MS <= 0
    ) {
      return;
    }

    snapshotState.lastTimerReason = reason || null;
    snapshotState.timeoutHandle = setTimeout(() => {
      snapshotState.timeoutHandle = null;
      if (!snapshotState.inProgress) {
        return;
      }

      console.warn(
        `[Events] Snapshot timeout (${
          snapshotState.lastTimerReason || "unknown"
        })`
      );

      if (snapshotState.received > 0) {
        handleEventsSnapshotEnd({
          topic: "events.new",
          sent: snapshotState.received,
          request_id: snapshotState.requestId,
          context: Object.assign(
            {
              request_id: snapshotState.requestId,
              total_selected: snapshotState.received,
              total_available: snapshotState.totalAvailable,
            },
            snapshotState.context || {}
          ),
        });
      } else {
        updateConnectionStatus(
          "connecting",
          "Snapshot timeout ‚Äî retrying events"
        );
        requestEventsSnapshot("Retrying events snapshot...");
      }
    }, EVENTS_SNAPSHOT_TIMEOUT_MS);
  }

  function requestEventsSnapshot(message) {
    const statusKey = isEventsPaused() ? "paused" : "connecting";
    const statusMessage =
      message ||
      (isEventsPaused()
        ? "Paused snapshot requested..."
        : "Requesting snapshot...");
    updateConnectionStatus(statusKey, statusMessage);

    snapshotState.inProgress = true;
    snapshotState.started = false;
    snapshotState.expected = 0;
    snapshotState.received = 0;
    snapshotState.totalAvailable = 0;
    snapshotState.context = null;
    snapshotState.requestId = null;
    scheduleEventsSnapshotTimer("request");

    if (window.Realtime && typeof Realtime.updateFilters === "function") {
      const result =
        Realtime.updateFilters({
          snapshotTopics: ["events.new", "events"],
        }) || {};
      const requestId = result["events.new"] || result["events"] || null;
      if (requestId) {
        snapshotState.requestId = requestId;
      }
    } else {
      console.warn(
        "[Events] Realtime controller unavailable; cannot request snapshot"
      );
    }
  }

  function normalizeEvent(raw) {
    if (!raw || typeof raw !== "object") return null;
    const payload =
      raw.payload && typeof raw.payload === "object" ? raw.payload : {};
    const severity =
      typeof raw.severity === "string" ? raw.severity.toLowerCase() : "";
    const categoryRaw = typeof raw.category === "string" ? raw.category : "";
    const category = categoryRaw.toLowerCase();
    const categoryLabel = categoryRaw
      ? categoryRaw.charAt(0).toUpperCase() + categoryRaw.slice(1)
      : category
      ? category.charAt(0).toUpperCase() + category.slice(1)
      : "Unknown";
    const payloadMessage =
      typeof payload.message === "string" && payload.message.trim() !== ""
        ? payload.message
        : typeof payload.message_short === "string" &&
          payload.message_short.trim() !== ""
        ? payload.message_short
        : null;
    const rawMessage =
      typeof raw.message === "string" && raw.message.trim() !== ""
        ? raw.message
        : null;
    const message = rawMessage || payloadMessage || "No message";
    return {
      ...raw,
      category,
      categoryLabel,
      severity,
      message,
      payload,
    };
  }

  function hasEventChanged(existing, next) {
    if (!existing) return true;
    return (
      existing.message !== next.message ||
      existing.severity !== next.severity ||
      existing.category !== next.category ||
      existing.subtype !== next.subtype ||
      existing.reference_id !== next.reference_id ||
      existing.event_time !== next.event_time ||
      existing.mint !== next.mint ||
      JSON.stringify(existing.payload) !== JSON.stringify(next.payload)
    );
  }

  function matchesActiveFilters(event) {
    const category = document.getElementById("categoryFilter")?.value || "";
    const severity = document.getElementById("severityFilter")?.value || "";
    if (category && event.category !== category) return false;
    if (severity && event.severity !== severity) return false;
    return true;
  }

  function mergeEvents(events) {
    if (!Array.isArray(events) || events.length === 0) {
      return false;
    }

    let updated = false;
    for (const raw of events) {
      const event = normalizeEvent(raw);
      if (!event || typeof event.id !== "number") continue;
      if (!matchesActiveFilters(event)) continue;
      const eventId = Number(event.id);
      const existing = eventsStore.get(eventId);
      if (hasEventChanged(existing, event)) {
        eventsStore.set(eventId, event);
        updated = true;
      }
    }

    if (!updated) {
      return false;
    }

    const orderedIds = Array.from(eventsStore.keys()).sort((a, b) => b - a);
    if (orderedIds.length > EVENT_MAX_RECORDS) {
      for (let i = EVENT_MAX_RECORDS; i < orderedIds.length; i++) {
        eventsStore.delete(orderedIds[i]);
      }
      orderedIds.length = EVENT_MAX_RECORDS;
    }

    allEventsData = orderedIds.map((id) => eventsStore.get(id));
    renderEvents();
    return true;
  }

  // Render events in table
  function getSearchTerm() {
    return (document.getElementById("eventSearch")?.value || "").toLowerCase();
  }

  function matchesSearch(event, searchTerm) {
    if (!searchTerm) return true;
    const haystacks = [
      event.category,
      event.subtype,
      event.message,
      event.reference_id,
      event.mint,
    ];
    return haystacks.some(
      (value) =>
        typeof value === "string" && value.toLowerCase().includes(searchTerm)
    );
  }

  function formatEventCountLabel(count) {
    const safe = Number.isFinite(count) ? count : 0;
    const plural = safe === 1 ? "event" : "events";
    return `${safe.toLocaleString()} ${plural}`;
  }

  function formatReferenceSnippet(value) {
    if (typeof value !== "string") return "";
    if (value.length <= 12) return value;
    return `${value.slice(0, 6)}‚Ä¶${value.slice(-6)}`;
  }

  function renderEvents(forcedEvents) {
    const tbody = document.getElementById("eventsTableBody");
    const searchTerm = getSearchTerm();
    const events = Array.isArray(forcedEvents) ? forcedEvents : allEventsData;
    const filtered = events.filter((event) => matchesSearch(event, searchTerm));

    if (!filtered || filtered.length === 0) {
      const message = snapshotState.inProgress
        ? "üì¶ Receiving snapshot..."
        : connectionStatus === "error"
        ? "‚ö†Ô∏è Error loading events. Please check server status."
        : connectionStatus === "connecting"
        ? "üîÑ Connecting to server..."
        : connectionStatus === "paused"
        ? "‚è∏Ô∏è Events paused. Resume to receive new activity."
        : connectionStatus === "disconnected"
        ? "üì¥ Realtime connection lost. Waiting to resync..."
        : "üìã No events found. Events will appear here as they occur.";

      tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-muted);">
                            ${message}
                        </td>
                    </tr>
                `;
      return;
    }

    tbody.innerHTML = filtered
      .map((event) => {
        const time = Utils.formatTimeAgo(new Date(event.event_time), {
          fallback: "-",
        });
        const severityColor = getSeverityColor(event.severity);
        let referenceCell = "-";
        if (event.reference_id) {
          const snippet = Utils.escapeHtml(
            formatReferenceSnippet(event.reference_id)
          );
          const full = Utils.escapeHtml(event.reference_id);
          const encoded = encodeURIComponent(event.reference_id);
          referenceCell = `
                        <span class="event-ref" title="${full}">${snippet}</span>
                        <button class="event-ref-copy" type="button" data-ref="${encoded}" title="Copy reference">üìã</button>
                    `;
        }
        const messageText = Utils.escapeHtml(event.message);
        const detailButton = `<button class="event-detail-btn" type="button" data-event-id="${event.id}" title="View full event">Details</button>`;

        return `
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 10px; white-space: nowrap;">${time}</td>
            <td style="padding: 10px;">
              <span style="background: var(--badge-loading); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
                ${Utils.escapeHtml(
                  event.categoryLabel || event.category || "-"
                )}
                            </span>
                        </td>
                        <td style="padding: 10px; font-size: 0.9em;">${
                          event.subtype || "-"
                        }</td>
                        <td style="padding: 10px;">
                            <span style="background: ${severityColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.85em;">
                                ${event.severity.toUpperCase()}
                            </span>
                        </td>
                        <td style="padding: 10px; max-width: 420px;">
                            <div class="event-message-cell">
                                <span class="event-message-text" title="${messageText}">${messageText}</span>
                                ${detailButton}
                            </div>
                        </td>
                        <td style="padding: 10px; font-size: 0.85em;">
                            <span class="event-ref-cell">${referenceCell}</span>
                        </td>
                    </tr>
                `;
      })
      .join("");
  }

  // Get color for severity
  function getSeverityColor(severity) {
    const key = (severity || "").toLowerCase();
    const colors = {
      info: "var(--badge-online)",
      warn: "var(--badge-loading)",
      error: "var(--badge-error)",
      debug: "#6b7280",
    };
    return colors[key] || "#6b7280";
  }

  // Search events
  document.getElementById("eventSearch").addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    AppState.save("events_search", searchTerm);
    if (searchDebounceHandle) {
      clearTimeout(searchDebounceHandle);
    }
    searchDebounceHandle = setTimeout(() => {
      renderEvents();
    }, 120);
  });

  // Filter by category
  document.getElementById("categoryFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying category filter...");
    AppState.save(
      "events_category",
      document.getElementById("categoryFilter").value
    );
  });

  // Filter by severity
  document.getElementById("severityFilter").addEventListener("change", () => {
    maxEventId = 0;
    clearEventsCache();
    requestEventsSnapshot("Applying severity filter...");
    AppState.save(
      "events_severity",
      document.getElementById("severityFilter").value
    );
  });

  // Refresh button
  document
    .getElementById("refreshEvents")
    .addEventListener("click", () =>
      requestEventsSnapshot("Refreshing events...")
    );

  document.getElementById("toggleEventsPause").addEventListener("click", () => {
    const nextPaused = !isEventsPaused();
    applyEventsPauseState(nextPaused, {
      message: nextPaused
        ? `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        : "Resuming events...",
    });
  });

  // Reference copy handler
  document
    .getElementById("eventsTableBody")
    .addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".event-ref-copy");
      if (copyBtn) {
        const encoded = copyBtn.getAttribute("data-ref");
        if (!encoded) return;
        const reference = decodeURIComponent(encoded);
        try {
          await Utils.copyToClipboard(reference);
          Utils.showToast("‚úÖ Reference copied to clipboard");
        } catch (err) {
          console.error("Failed to copy reference:", err);
          Utils.showToast("‚ùå Failed to copy reference", "error");
        }
        return;
      }

      const detailBtn = event.target.closest(".event-detail-btn");
      if (detailBtn) {
        const idAttr = detailBtn.getAttribute("data-event-id");
        const eventId = Number(idAttr);
        if (Number.isFinite(eventId)) {
          openEventDetailModal(eventId);
        }
      }
    });

  const eventDetailModal = document.getElementById("eventDetailModal");
  const eventDetailClose = document.getElementById("eventDetailClose");

  function openEventDetailModal(eventId) {
    if (!eventDetailModal) return;
    const eventData = eventsStore.get(eventId);
    if (!eventData) {
      Utils.showToast("‚ùå Event details unavailable", "error");
      return;
    }

    const categoryLabel =
      eventData.categoryLabel || eventData.category || "event";
    document.getElementById(
      "eventDetailTitle"
    ).textContent = `${categoryLabel.toUpperCase()} ‚Ä¢ #${eventData.id}`;
    document.getElementById("eventDetailCategory").textContent = categoryLabel;
    document.getElementById("eventDetailSeverity").textContent = (
      eventData.severity || "-"
    ).toUpperCase();
    document.getElementById("eventDetailTime").textContent =
      eventData.event_time
        ? new Date(eventData.event_time).toLocaleString()
        : "-";
    document.getElementById("eventDetailReference").textContent =
      eventData.reference_id || "‚Äî";
    document.getElementById("eventDetailMint").textContent =
      eventData.mint || "‚Äî";

    const payloadEl = document.getElementById("eventDetailPayload");
    if (eventData.payload !== null && eventData.payload !== undefined) {
      try {
        payloadEl.textContent = JSON.stringify(eventData.payload, null, 2);
      } catch (err) {
        console.error("Failed to stringify payload:", err);
        payloadEl.textContent = "Unable to render payload.";
      }
    } else {
      payloadEl.textContent = "No payload data available.";
    }

    eventDetailModal.classList.add("show");
  }

  function closeEventDetailModal() {
    if (!eventDetailModal) return;
    eventDetailModal.classList.remove("show");
  }

  if (eventDetailClose) {
    eventDetailClose.addEventListener("click", closeEventDetailModal);
  }
  if (eventDetailModal) {
    eventDetailModal.addEventListener("click", (event) => {
      if (event.target === eventDetailModal) {
        closeEventDetailModal();
      }
    });
  }

  document.addEventListener("keydown", (event) => {
    if (
      event.key === "Escape" &&
      eventDetailModal &&
      eventDetailModal.classList.contains("show")
    ) {
      closeEventDetailModal();
    }
  });

  // Handle incoming event from WebSocket
  function handleEventsWebSocket(data, envelope) {
    if (!data || typeof data !== "object") {
      return;
    }

    const paused = isEventsPaused();

    const normalized = normalizeEvent(data);
    if (!normalized || typeof normalized.id !== "number") {
      return;
    }

    if (!matchesActiveFilters(normalized)) {
      return;
    }

    if (paused && !snapshotState.inProgress) {
      return;
    }

    maxEventId = Math.max(maxEventId, normalized.id);
    mergeEvents([normalized]);
    snapshotState.totalAvailable = Math.max(
      snapshotState.totalAvailable,
      eventsStore.size
    );

    if (envelope?.meta && envelope.meta.snapshot) {
      const meta = envelope.meta;
      const chunkRequestId =
        meta?.extra?.request_id ||
        meta?.extra?.requestId ||
        meta?.request_id ||
        meta?.requestId ||
        null;
      if (
        snapshotState.requestId &&
        chunkRequestId &&
        chunkRequestId !== snapshotState.requestId
      ) {
        if (window.__DEBUG_REALTIME) {
          console.warn("[Events] Ignoring snapshot chunk for stale request", {
            chunkRequestId,
            stateRequestId: snapshotState.requestId,
          });
        }
        return;
      }
      if (!snapshotState.started) {
        if (window.__DEBUG_REALTIME) {
          console.warn("[Events] Snapshot chunk arrived before begin", {
            meta,
          });
        }
        return;
      }
      snapshotState.received += 1;
      const totalMeta =
        meta?.extra?.total_selected || meta?.extra?.total || meta?.total;
      if (Number.isFinite(totalMeta)) {
        snapshotState.totalAvailable = Math.max(
          snapshotState.totalAvailable,
          Number(totalMeta)
        );
      } else {
        snapshotState.totalAvailable = Math.max(
          snapshotState.totalAvailable,
          eventsStore.size
        );
      }
      scheduleEventsSnapshotTimer("chunk");
      return;
    }

    if (!snapshotState.inProgress) {
      const statusKey = paused ? "paused" : "connected";
      const prefix = paused ? "Paused" : "Realtime";
      updateConnectionStatus(
        statusKey,
        `${prefix} ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
      );
    }
  }

  function handleEventsSnapshotBegin(payload) {
    const topic = payload?.topic || "events.new";
    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;

    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds[topic] ||
          realtime.lastSnapshotRequestIds["events"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      snapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Events] Ignoring stale snapshot_begin", {
          requestId,
          latestRequestId,
          stateRequestId: snapshotState.requestId,
        });
      }
      return;
    }

    if (requestId) {
      snapshotState.requestId = requestId;
    }

    snapshotState.context = context || null;
    snapshotState.inProgress = true;
    snapshotState.started = true;
    snapshotState.received = 0;
    const totalSelected =
      Number(context.total_selected ?? context.total ?? payload?.total) || 0;
    const totalAvailable =
      Number(context.total_available ?? totalSelected) || 0;
    snapshotState.expected = totalSelected;
    snapshotState.totalAvailable = totalAvailable;
    clearEventsCache();
    scheduleEventsSnapshotTimer("begin");

    const statusKey = isEventsPaused() ? "paused" : "connecting";
    const label = isEventsPaused()
      ? "Paused ‚Ä¢ Receiving snapshot..."
      : totalSelected > 0
      ? `Receiving snapshot (${formatEventCountLabel(totalSelected)})`
      : "Receiving snapshot...";
    updateConnectionStatus(statusKey, label);
  }

  function handleEventsSnapshotEnd(payload) {
    clearEventsSnapshotTimer();

    const topic = payload?.topic || "events.new";
    const context = (payload && payload.context) || {};
    const requestId =
      context.request_id ||
      context.requestId ||
      payload?.request_id ||
      payload?.requestId ||
      null;

    const realtime = window.Realtime;
    const latestRequestId =
      realtime && realtime.lastSnapshotRequestIds
        ? realtime.lastSnapshotRequestIds[topic] ||
          realtime.lastSnapshotRequestIds["events"] ||
          null
        : null;

    if (
      requestId &&
      latestRequestId &&
      requestId !== latestRequestId &&
      snapshotState.requestId !== requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Events] Ignoring stale snapshot_end", {
          requestId,
          latestRequestId,
          stateRequestId: snapshotState.requestId,
        });
      }
      return;
    }

    if (
      requestId &&
      snapshotState.requestId &&
      requestId !== snapshotState.requestId
    ) {
      if (window.__DEBUG_REALTIME) {
        console.warn("[Events] snapshot_end request mismatch", {
          requestId,
          stateRequestId: snapshotState.requestId,
        });
      }
      return;
    }

    if (requestId) {
      snapshotState.requestId = requestId;
    }

    if (context && Object.keys(context).length > 0) {
      snapshotState.context = context;
    }

    const sent = Number(
      context.total_selected ??
        context.total ??
        payload?.sent ??
        snapshotState.received
    );
    if (Number.isFinite(sent)) {
      snapshotState.received = sent;
    }

    const available = Number(
      context.total_available ?? snapshotState.totalAvailable ?? sent
    );
    if (Number.isFinite(available)) {
      snapshotState.totalAvailable = Math.max(
        snapshotState.totalAvailable,
        available
      );
    }

    snapshotState.inProgress = false;
    snapshotState.started = false;

    const paused = isEventsPaused();
    const statusKey = paused ? "paused" : "connected";
    const prefix = paused ? "Paused" : "Realtime";
    const totalDisplayed = Math.max(
      allEventsData.length,
      Number.isFinite(snapshotState.totalAvailable)
        ? snapshotState.totalAvailable
        : allEventsData.length
    );
    updateConnectionStatus(
      statusKey,
      `${prefix} ‚Ä¢ ${formatEventCountLabel(totalDisplayed)}`
    );
    renderEvents();
  }

  function handleWebSocketWarning(message) {
    if (!message || message.alias !== "events") return;
    console.warn("[Events] Channel warning", {
      code: message?.code,
      text: message?.message,
    });
    updateConnectionStatus("connecting", "Warning received, resyncing...");
    requestEventsSnapshot("Resyncing after warning...");
  }

  function handleEventsDisconnect() {
    updateConnectionStatus("disconnected", "Disconnected from realtime");
  }

  function handleEventsReconnect() {
    if (isEventsPaused()) {
      applyEventsPauseState(true, {
        force: true,
        refreshSnapshot: true,
        message: "Paused ‚Ä¢ Syncing after reconnect...",
      });
    } else {
      updateConnectionStatus("connecting", "Reconnected, syncing events...");
      requestEventsSnapshot("Syncing after reconnect...");
    }
  }
  function restoreSavedFilters() {
    const categoryFilter = document.getElementById("categoryFilter");
    const severityFilter = document.getElementById("severityFilter");
    const searchInput = document.getElementById("eventSearch");

    if (categoryFilter) {
      const savedCategory = AppState.load("events_category", "");
      if (savedCategory) categoryFilter.value = savedCategory;
    }

    if (severityFilter) {
      const savedSeverity = AppState.load("events_severity", "");
      if (savedSeverity) severityFilter.value = savedSeverity;
    }

    if (searchInput) {
      const savedSearch = AppState.load("events_search", "");
      if (savedSearch) searchInput.value = savedSearch;
    }
  }

  function initializePauseState() {
    updatePauseButtonUI();
    const realtime = window.Realtime;
    const realtimePaused = !!(realtime &&
    typeof realtime.isEventsPaused === "function"
      ? realtime.isEventsPaused("events")
      : false);
    const savedPaused = AppState.load("events_paused", "") === "1";
    const shouldPause = realtimePaused || savedPaused;
    if (shouldPause) {
      applyEventsPauseState(true, {
        force: true,
        refreshSnapshot: false,
        message: `Paused ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`,
        silent: true,
      });
    } else if (eventsPauseState.paused) {
      applyEventsPauseState(false, {
        force: true,
        refreshSnapshot: false,
        silent: true,
        message: `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`,
      });
    }
  }

  // Global init function for Router to call during SPA navigation
  window.initEventsPage = function () {
    console.log("[Events] Initializing page");
    restoreSavedFilters();
    initializePauseState();
    const message = isEventsPaused()
      ? "Paused ‚Ä¢ Loading events..."
      : "Loading events...";
    requestEventsSnapshot(message);
  };

  window.PageRealtime = window.PageRealtime || {};
  window.PageRealtime.events = {
    topics: ["events"],
    channels: {
      events: handleEventsWebSocket,
      "snapshot_begin:events.new": handleEventsSnapshotBegin,
      "snapshot_end:events.new": handleEventsSnapshotEnd,
      _warning: handleWebSocketWarning,
      _disconnected: handleEventsDisconnect,
      _failed: handleEventsDisconnect,
      _connected: handleEventsReconnect,
    },
    getFilters() {
      const filters = {};
      const category = document.getElementById("categoryFilter")?.value;
      const severity = document.getElementById("severityFilter")?.value;
      const searchTerm = getSearchTerm();
      const topic = "events.new";

      filters[topic] = {};
      if (category) filters[topic].category = category;
      if (severity) filters[topic].severity = severity;
      if (searchTerm) filters[topic].search = searchTerm;
      return filters;
    },
    onInitial(status) {
      if (status === "connected") {
        updateConnectionStatus(
          "connected",
          `Realtime ‚Ä¢ ${formatEventCountLabel(allEventsData.length)}`
        );
      } else if (status === "connecting") {
        updateConnectionStatus("connecting", "Connecting to realtime...");
      } else {
        updateConnectionStatus("disconnected", "Realtime unavailable");
      }
    },
    onUnavailable() {
      updateConnectionStatus("disconnected", "Realtime unavailable");
    },
    onEnter() {
      initializePauseState();
      const message = isEventsPaused()
        ? "Paused ‚Ä¢ Loading events..."
        : "Loading events...";
      requestEventsSnapshot(message);
    },
    onExit() {
      snapshotState.inProgress = false;
      snapshotState.started = false;
      snapshotState.requestId = null;
      clearEventsSnapshotTimer();
    },
  };

  // Execute initialization immediately (works for both initial load and SPA navigation)
  window.initEventsPage();
</script>
